<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDA调试方法与常见技巧</title>
    <url>/2020/12/13/CTF-re-IDA-tips/</url>
    <content><![CDATA[<ul>
<li>使用IDA Remote Windows Debugger进行调试；</li>
<li>断点。</li>
</ul>
<a id="more"></a>

<h1 id="如何使用IDA进行调试"><a href="#如何使用IDA进行调试" class="headerlink" title="如何使用IDA进行调试"></a>如何使用IDA进行调试</h1><p>在Windows系统上使用IDA调试，需要用到两个文件<code>win32_remote.exe</code>和<code>win64_remote.exe</code>（在文件夹<code>\IDA 7.0\dbgsrv</code>中）:</p>
<img src="/2020/12/13/CTF-re-IDA-tips/image-20201213183001919.png" alt="image-20201213183001919" style="zoom: 80%;">

<p>这两个文件分别对应32位的IDA和64位的IDA，<strong>在调试过程中，IDA和remote文件需要对应</strong>。</p>
<p>（以64位为例）首先打开remote文件（之后将其最小化即可）：</p>
<img src="/2020/12/13/CTF-re-IDA-tips/image-20201213185817136.png" alt="image-20201213185817136" style="zoom: 67%;">

<p>在IDA界面选择<code>Remote Windows debugger</code>，</p>
<img src="/2020/12/13/CTF-re-IDA-tips/image-20201213190129549.png" alt="image-20201213190129549" style="zoom:80%;">

<p>点击左侧绿色的箭头开始调试。在第一次调试时可能会出现下面的错误：</p>
<img src="/2020/12/13/CTF-re-IDA-tips/image-20201213190615181.png" alt="image-20201213190615181" style="zoom:80%;">

<p>不断点确定，会出现一个setup窗口。其中<code>Application</code>和<code>Input File</code>均填写待调试文件的<strong>绝对路径</strong>，<code>Directory</code>填写待调试文件所在的文件夹，<code>Hostname</code>填写<code>127.0.0.1</code>表示当前主机。</p>
<p><strong>为了防止之后每次调试都设置一遍，可以将<code>Save network settings as default</code>选中，保存网络设置。</strong>完整的填写示例如下：</p>
<p><img src="/2020/12/13/CTF-re-IDA-tips/image-20201213190544390.png" alt="image-20201213190544390"></p>
<p>之后即可正常出现调试界面。</p>
<p><img src="/2020/12/13/CTF-re-IDA-tips/image-20201213190816616.png" alt="image-20201213190816616"></p>
<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>在反编译模式（F5）下，可以点击代码左侧的蓝色按钮设置（多个）断点，如下：</p>
<p><img src="/2020/12/13/CTF-re-IDA-tips/image-20201213191034981.png" alt="image-20201213191034981"></p>
<p>之后，进入调试，可以看到，程序在执行到断点的位置后会停止。</p>
<p><img src="/2020/12/13/CTF-re-IDA-tips/image-20201213191147562.png" alt="image-20201213191147562"></p>
<p>此时，可以将鼠标悬停到某个变量实时预览变量的值，也可以进行其他工作。</p>
<p>在菜单<code>debuger</code>处可以执行各种和调试有关的操作（例如继续执行、结束调试等等）。<strong>通常在界面上方的工具栏也有这些选项</strong>。</p>
<p><img src="/2020/12/13/CTF-re-IDA-tips/image-20201213191329335.png" alt="image-20201213191329335"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Reverse_逆向</category>
        <category>IDA</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Reference Chapter 1 变量和基本类型</title>
    <url>/2020/12/11/cpp-chapter1/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<ul>
<li>C++中常用的算术类型介绍</li>
<li>类型转换（包括隐式类型转换和强制转换）</li>
<li>字面值常量</li>
<li>变量的声明、定义、初始化</li>
<li>标识符与命名</li>
</ul>
<a id="more"></a>

<h1 id="Chapter-1-变量和基本类型"><a href="#Chapter-1-变量和基本类型" class="headerlink" title="Chapter 1  变量和基本类型"></a>Chapter 1  变量和基本类型</h1><h2 id="1-1-基本内置类型"><a href="#1-1-基本内置类型" class="headerlink" title="1.1 基本内置类型"></a><strong>1.1 基本内置类型</strong></h2><p>C++的基本数据类型包括<strong>算数类型</strong>和**空类型<code>void</code>**。其中：</p>
<ul>
<li>算数类型包括<strong>字符</strong>，<strong>整型数</strong>，<strong>布尔值</strong>和<strong>浮点数</strong>。</li>
<li>空类型不对应具体的值，仅用作一些特殊的场合（例如函数的返回值）。</li>
</ul>
<p>数据类型可以告诉我们<strong>数据的意义以及我们能在数据上执行的操作</strong>。</p>
<h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><h4 id="常见的算数类型"><a href="#常见的算数类型" class="headerlink" title="常见的算数类型"></a>常见的算数类型</h4><p>算数类型分为<strong>整型</strong>（包括字符、布尔类型）和<strong>浮点型</strong>。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bool</code></td>
<td align="center">布尔类型</td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">短整型</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">整型</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center"><code>long long</code></td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">单精度浮点数</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td align="center"><code>long double</code></td>
<td align="center">扩展精度浮点数</td>
</tr>
</tbody></table>
<blockquote>
<p>对于他们的大小，C++语言有这样的规范：</p>
<p>一个<code>char</code>的空间应该确保可以存放机器基本字符集中的任意字符对应的数字值。也就是说，一个<code>char</code>的大小和一个机器字节一样。</p>
<p>一个<code>int</code>至少和一个<code>short</code>一样大，一个<code>long</code>至少和一个<code>int</code>一样大，一个<code>long long</code>至少和一个<code>long</code>一样大。</p>
</blockquote>
<h5 id="符号类型和无符号类型"><a href="#符号类型和无符号类型" class="headerlink" title="符号类型和无符号类型"></a>符号类型和无符号类型</h5><p>在上述提到的基本算珠类型中，除去布尔型，其他整型都可以划分为<strong>带符号</strong>和<strong>无符号</strong>两种类型。带符号类型使用<code>signed</code>表示，无符号类型使用<code>unsigned</code>表示。</p>
<table>
<thead>
<tr>
<th>有符号类型</th>
<th>无符号类型</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>(signed) int</code></td>
<td><code>unsigned int</code>/<strong><code>unsigned</code></strong></td>
<td><code>(signed)short</code></td>
<td><code>unsigned short</code></td>
</tr>
<tr>
<td><code>(signed)long</code></td>
<td><code>unsigned long</code></td>
<td><code>(signed)long long</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody></table>
<blockquote>
<p>字符整型被分为<code>signed char</code>和<code>unsigned char</code>三种类型。与其他类型不同，类型<code>char</code>和<code>signed char</code>并不相同。<code>char</code>类型是否带符号取决于不同的编译器。</p>
</blockquote>
<h4 id="扩展的字符型"><a href="#扩展的字符型" class="headerlink" title="扩展的字符型"></a>扩展的字符型</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>wchar_t</code></td>
<td align="center">宽字符</td>
<td align="center">用于确保可以存放机器最大扩展字符集中的任意一个字符。</td>
</tr>
<tr>
<td align="center"><code>char16_t</code></td>
<td align="center">Unicode字符</td>
<td align="center">用于Unicode字符集。</td>
</tr>
<tr>
<td align="center"><code>char32_t</code></td>
<td align="center">Unicode字符</td>
<td align="center">用于Unicode字符集。</td>
</tr>
</tbody></table>
<h4 id="如何选用类型"><a href="#如何选用类型" class="headerlink" title="如何选用类型"></a>如何选用类型</h4><blockquote>
<p><strong>如何选用类型:</strong></p>
<ul>
<li>如果数值不可能为负时，选用无符号类型。</li>
<li>使用<code>int</code>执行整型运算，如果数值超出<code>int</code>表示范围，使用<code>long long</code>。</li>
<li>只有表示字符时使用<code>char</code>，只有表示布尔值时使用<code>bool</code>。</li>
<li>在使用字符型表示小整数时，注明<code>signed char</code>还是<code>unsigned char</code>。</li>
<li>执行浮点数使用<code>double</code>。</li>
</ul>
</blockquote>
<h3 id="如何使用代码查看各个基本类型的范围和大小"><a href="#如何使用代码查看各个基本类型的范围和大小" class="headerlink" title="如何使用代码查看各个基本类型的范围和大小"></a>如何使用代码查看各个基本类型的范围和大小</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;	//&lt;climits&gt;库中储存了各个类型的范围</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如何查看某个变量类型的大小</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用&lt;climits&gt;查看变量范围</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int from &quot;</span> &lt;&lt; INT_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; INT_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long from &quot;</span> &lt;&lt; LONG_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; LONG_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char from &quot;</span> &lt;&lt; CHAR_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; CHAR_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-类型转换"><a href="#1-2-类型转换" class="headerlink" title="1.2 类型转换"></a><strong>1.2 类型转换</strong></h2><h3 id="将一种算术类型的值赋给另一种类型"><a href="#将一种算术类型的值赋给另一种类型" class="headerlink" title="将一种算术类型的值赋给另一种类型"></a>将一种算术类型的值赋给另一种类型</h3><ul>
<li>将非布尔值赋给布尔类型，初始值为0，则结果为<code>false</code>，初始值不为0，则结果为<code>true</code>。</li>
<li>将布尔值赋给非布尔类型，初始值为<code>true</code>，则结果为1，初始值为<code>false</code>，则结果为0。</li>
<li>将浮点数赋给整数类型，进行了近似处理，结果值仅保留浮点数中小数点之前的部分。</li>
<li>将整数赋给浮点类型，小数部分记为0 。如果整数所占空间超过浮点类型容量，精度可能损失。</li>
</ul>
<p>在赋值过程中，如果<strong>将超出某一类型范围的值</strong>赋给该类型变量时：</p>
<ul>
<li>赋给无符号类型的结果是<strong>对无符号类型表示的最大数值取模的余数</strong>。</li>
<li>赋给有符号类型的结果是<font color="red"><strong>未定义</strong></font>的。</li>
</ul>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><h4 id="何时会发生隐式类型转换"><a href="#何时会发生隐式类型转换" class="headerlink" title="何时会发生隐式类型转换"></a>何时会发生隐式类型转换</h4><p>当两个运算对象类型不同时，C++语言不会直接将两个不同类型的值做运算，而是先根据类型转换规则设法将运算对象的类型统一之后再求值。上述的类型转换是自动执行的，因此，它们被称为<strong>隐式类型转换</strong>。</p>
<p>隐式转换的设计原则是<strong>尽可能避免损失精度</strong>。</p>
<blockquote>
<p>具体来说，出现下面这些情况时会发生隐式类型转换：</p>
<ul>
<li>在表达式中，比<code>int</code>类型小的整型值会首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值会转换为布尔值。</li>
<li>初始化过程中，初始值转换为变量的类型。</li>
<li>赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换为一种类型。</li>
<li>函数调用时发生的类型转换。</li>
</ul>
</blockquote>
<h4 id="最主要的隐式转换：算数转换"><a href="#最主要的隐式转换：算数转换" class="headerlink" title="最主要的隐式转换：算数转换"></a>最主要的隐式转换：算数转换</h4><p>算数转换是把一种算术类型转换为另一种算术类型。</p>
<h5 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h5><p>整型提升负责<strong>将小整数类型转换为较大的整数类型</strong>。</p>
<p>对于<code>bool</code>,<code>char</code>,<code>singed char</code>,<code>unsigned char</code>,<code>short</code>,<code>unsigned short</code>等类型来说，只要它们所有可能的值都能存在<code>int</code>类型中，它们就会提升为<code>int</code>类型，否则，提升为<code>unsigned int</code>类型（在一般的编译器下，一个<code>int</code>占用32bits的空间，因此他们都会被转换为<code>int</code>类型）。</p>
<p>较大的字符型，比如<code>wchar_t</code>,<code>char16_t</code>,<code>char32_t</code>，会按照<code>int</code>,<code>unsigned int</code>,<code>long</code>,<code>unsigned long</code>,<code>long long </code>,<code>unsigned long long </code>的顺序依次检查，在能容纳所有可能的值的前提下选择最小的一种类型转换。</p>
<h5 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h5><p>如果运算对象一个是有符号的，一个是无符号的，则根据两个整数类型的相对大小进行转换（小类型向大类型转换）。</p>
<p><strong>如果两个类型占用的字节数不同，则小字节类型转换为大字节类型；如果相同，有符号类型转换为无符号类型。</strong></p>
<h5 id="算数转换的步骤"><a href="#算数转换的步骤" class="headerlink" title="算数转换的步骤"></a>算数转换的步骤</h5><ol>
<li><p>首先对<code>char</code>,<code>bool</code>等小整型进行<strong>整型提升</strong>。</p>
</li>
<li><p>如果整型提升之后类型不匹配：</p>
<ol>
<li><p>如果运算对象中有浮点类型，则<strong>所有运算对象转换为相应的浮点类型</strong>。</p>
</li>
<li><p>如果没有浮点类型：</p>
<p><strong>根据类型大小规则，将所有类型全部转换为最大的一个类型。具体地说：</strong></p>
<ol>
<li>如果提升后的运算对象都是带符号的，或者都是不带符号的，则<strong>小类型运算对象转换成较大的类型</strong>。</li>
<li>如果提升后的运算对象既有有符号的，也有无符号的，则根据<strong>无符号类型的运算对象</strong>中的规则进行转换。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h4><ul>
<li><p>数组转换为指针<font color="blue">【参考数组部分】</font></p>
</li>
<li><p>指针的转换<font color="blue">【参考指针部分】</font></p>
<p>例如：常量整数值<code>0</code>和字面值<code>nullptr</code>可以转换成任意指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如我们经常这样初始化指针：</span></span><br><span class="line">	<span class="keyword">int</span>* ptr_i = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* ptr_llong = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>指向非常量的指针能转换为<code>void*</code>，指向任意对象的指针能转换为<code>const void*</code>。</p>
</li>
</ul>
<h3 id="显式类型转换（强制类型转换）"><a href="#显式类型转换（强制类型转换）" class="headerlink" title="显式类型转换（强制类型转换）"></a>显式类型转换（强制类型转换）</h3><p><strong>字符和字符串字面值</strong></p>
<p>一个命名的强制类型转换具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cast-name &lt;type&gt; (expression)</span><br></pre></td></tr></table></figure>

<p>其中:<code>type</code>是转换的目标类型。<code>expression</code>是要转换的值。<br><code>cast-name</code>是<code>static_cast</code>,<code>dynamic_cast</code>,<code>const_cast</code>,<code>reinterpret_cast</code>中的一种，下面将对这三种转换分别说明。<font color="blue">【该部分涉及<code>const</code>的有关内容，参考常量部分】</font></p>
<p><strong><code>static_cast</code></strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用static_cast执行强制执行浮点运算</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">3</span>, j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / j;</span><br><span class="line"><span class="comment">//将一个较大的算术类型赋值给较小的类型</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.2</span>);</span><br><span class="line"><span class="comment">//执行编译器无法自动执行的类型转换</span></span><br><span class="line"><span class="keyword">double</span> fval = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">void</span>* p = &amp;fval;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p));</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>static_cast</code>并不支持指针类型的转换。</p>
<p><strong><code>const_cast</code></strong></p>
<p><code>const_cast</code>只能改变运算对象的底层<code>const</code>。因此**<code>const_cast</code>中的类型必须是指针、引用或指向对象类型成员的指针**。</p>
<p>将常量对象转换成非常量对象的行为一般称为<strong>“去掉<code>const</code>性质”</strong>。</p>
<p><strong>需要注意的是尽管<code>const_cast</code>可以去掉指针的<code>const</code>属性，但是所指位置的值仍然不会被修改。</strong></p>
<p>只有<code>const_cast</code>能改变表达式的常量属性。其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同时，<code>const_cast</code>不能改变表达式的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>, cch = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pch = &amp;ch, * pcch = &amp;cch;</span><br><span class="line"><span class="keyword">char</span>* p1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pch);    <span class="comment">//正确。</span></span><br><span class="line"><span class="keyword">char</span>* p2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pcch);   <span class="comment">//正确，但由于cch本身是一个常量，所以通过p2写值是未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; crval = val;</span><br><span class="line"><span class="keyword">int</span>&amp; rval = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(crval); <span class="comment">//错误：static_cast无法丢掉常量或其他类型限定符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> fval = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">double</span>* pfval = &amp;fval;</span><br><span class="line"><span class="keyword">int</span>* pint = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(fval);  <span class="comment">//错误：const_cast 只能调节类型限定符；不能更改基础类型</span></span><br></pre></td></tr></table></figure>

<p><strong><code>reinterpret_cast</code></strong></p>
<p><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释。<font color="red">使用<code>reinterpret_cast</code>是十分危险的行为</font>。</p>
<h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>旧式的强制类型转换包含两种形式：</p>
<p><code>type (expr)</code>和<code>(type) expr</code></p>
<p>根据所涉及的类型不同，旧式的强制类型转换分别具有与<code>static_cast</code>,<code>const_cast</code>,<code>reinterpret_cast</code>相似的行为。</p>
<p>如果替换为<code>static_cast</code>或<code>const_cast</code>合法，则其行为与对应的命名转换一致。如果不合法，则执行与<code>reinterpret_cast</code>类似的功能。</p>
<p><strong>使用新式的方式执行强制类型转换有助于代码阅读以及编译器查找错误。</strong></p>
<h2 id="1-3-字面值常量"><a href="#1-3-字面值常量" class="headerlink" title="1.3 字面值常量"></a><strong>1.3 字面值常量</strong></h2><h3 id="整型字面值及类型"><a href="#整型字面值及类型" class="headerlink" title="整型字面值及类型"></a>整型字面值及类型</h3><p><strong>整型字面值分为十进制数，八进制数或十六进制数</strong>。</p>
<p><strong>以<code>0</code>开头的整数代表8进制数，以<code>0x</code>或<code>0X</code>开头的整数代表16进制数。</strong>因此，为了表示十进制中的20，可以采用如下方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span><span class="comment">/*dec*/</span>    <span class="number">024</span><span class="comment">/*oct*/</span>    <span class="number">0x14</span><span class="comment">/*hec*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>-</code>不是字面值（例如<code>int x = -23;</code>），它的作用仅是对字面值取负。</strong></p>
<p><strong>字面值类型是能容纳其数值的<code>int</code>,<code>unsigned int</code>,<code>long</code>,<code>unsigned long</code>,<code>long long</code>,<code>unsigned long long</code>中的最小的一个</strong>。</p>
<blockquote>
<p>如果有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-4294967290</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这样类似的写法，编译器会报错: 一元负运算符应用于无符号类型，结果仍为无符号类型。</p>
<p>原因：当字面值为4294967290时，编译器发现<code>int</code>类型无法容纳，则决定使用<code>unsigned int</code>容纳。因此出现了一元负运算符应用于无符号类型的错误，这也应证了<code>-</code>不包括在字面值中，他的作用仅仅是对字面值取负号。</p>
</blockquote>
<h3 id="浮点型字面值及类型"><a href="#浮点型字面值及类型" class="headerlink" title="浮点型字面值及类型"></a><span id="浮点型字面值及类型">浮点型字面值及类型</span></h3><p><strong>所有浮点型字面值的默认类型为<code>double</code>。</strong></p>
<p><strong>小数型字面值</strong></p>
<p>下面均是可行的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>   <span class="number">.1234</span><span class="comment">/*0.1234*/</span>    <span class="number">34.</span><span class="comment">/*34.0*/</span></span><br></pre></td></tr></table></figure>

<p><strong>科学计数法</strong>使用<code>E</code>或<code>e</code>表示指数部分。</p>
<p>下面均是可行的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0.314159E1</span>    <span class="number">3e1</span>    <span class="number">0E0</span></span><br></pre></td></tr></table></figure>

<h3 id="字符、字符串字面值及类型"><a href="#字符、字符串字面值及类型" class="headerlink" title="字符、字符串字面值及类型"></a><span id="字符、字符串字面值及类型">字符、字符串字面值及类型</span></h3><p><strong>由单引号括起来的一个字符称为<code>char</code>型字面型。</strong></p>
<p><strong>由双引号括起来的零个或多个字符构成字符串型字面值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>    <span class="string">&#x27;b&#x27;</span>    <span class="string">&#x27; &#x27;</span> <span class="comment">//char</span></span><br><span class="line"><span class="string">&quot;Hello World.&quot;</span>      <span class="string">&quot;&quot;</span> <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串字面值实际上是由常量字符构成的数组</strong>，编译器在每个字符串的结尾处添加一个空字符<code>&#39;\0&#39;</code>,因此，<strong>字符串字面值的实际长度比它的内容多1</strong><font size="2" color="blue">【参考字符串部分】</font>。</p>
<h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3><p><code>true</code>和<code>false</code>是<code>bool</code>类型的字面值。</p>
<p><code>nullptr</code>是指针字面值<font size="2" color="blue">【参考指针部分】</font>。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a><span id="转义序列">转义序列</span></h3><p>有些在C++语言中有特殊含义的字符（比如单引号、双引号）不能直接在字符（串）字面值中使用。在这些情况下需要使用<strong>转义序列</strong>。</p>
<p>常见的转义序列：</p>
<table>
<thead>
<tr>
<th align="center">字符字面值不可使用</th>
<th align="center">字符串字面值不可使用</th>
<th align="center">有特殊含义</th>
<th align="center">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\\</code> 反斜线</td>
<td align="center"><code>\\</code> 反斜线</td>
<td align="center"><code>\n</code> 换行符</td>
<td align="center"><code>\?</code> 问号</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code> 单引号</td>
<td align="center"><code>\&quot;</code>双引号</td>
<td align="center"><code>\r</code> 回车符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\t</code> 横向制表符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\b</code> 退格符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\a</code> 报警（响铃）符</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>泛化的转义序列</p>
<p>泛化的转义字符的形式是<code>\x</code>后面跟着一位或多位十六进制字符，或者<code>\</code>后面跟着1位、2位或3位八进制数，转义序列不可以识别十进制数。</p>
<blockquote>
<p>十六进制数最多识别四位，八进制数最多识别三位。如果十六进制数或八进制数太大，编译器会报错。</p>
</blockquote>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加一些前缀和后缀，可以改变字面值的类型。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>Unicode 16 字符</td>
<td><code>char16_t</code>    (VS中的<code>cout &lt;&lt; </code>转换为<code>int</code>)</td>
</tr>
<tr>
<td><code>U</code></td>
<td>Unicode 32 字符</td>
<td><code>char32_t</code>    (VS中的<code>cout &lt;&lt; </code>转换为``unisgned int`)</td>
</tr>
<tr>
<td><code>L</code></td>
<td>宽字符</td>
<td><code>wchar_t</code>       (VS中的<code>cout &lt;&lt; </code>转换为<code>int</code>)`</td>
</tr>
<tr>
<td><code>u8</code></td>
<td>UTF-8</td>
<td><code>char</code></td>
</tr>
</tbody></table>
<p><strong>浮点型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>f</code>或<code>F</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>l</code>或<code>L</code></td>
<td><code>long double</code></td>
</tr>
</tbody></table>
<p><strong>整型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code>或<code>U</code></td>
<td><code>unsigned</code></td>
</tr>
<tr>
<td><code>l</code>或<code>L</code></td>
<td><code>long</code></td>
</tr>
<tr>
<td><code>ll</code>或<code>LL</code></td>
<td><code>long long</code></td>
</tr>
</tbody></table>
<blockquote>
<p>整型字面值后缀<code>u</code>可以和另外两个合在一起使用。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">12U</span>LL, y = <span class="number">12L</span>Lu;</span><br></pre></td></tr></table></figure>

<p>如果字面值大于后缀最小匹配类型，C++会自动寻找更大的可以容纳的类型。</p>
</blockquote>
<h2 id="1-4-变量"><a href="#1-4-变量" class="headerlink" title="1.4 变量"></a><strong>1.4 变量</strong></h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式是：<strong>基本数据类型 + 声明符列表</strong>，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p>对于基本类型，其声明符即为其标识符（名字）。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><font color="blue">【初始化部分涉及到的字符串、数组、向量、自定义数据类型等交叉内容，参考各相关部分】</font></p>
<p><font color="blue">【某种类型特殊的初始化方式，参考各部分】</font></p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化</strong>了。</p>
<blockquote>
<p>在同一条定义语句中，可以用先定义的变量值初始化后定义的其他变量。</p>
</blockquote>
<p><font color="red">初始化和赋值是两个完全不同的操作</font>。<strong>初始化的含义是创建变量时赋予其一个初始值</strong>，而<strong>赋值的含义是把对象当前的值擦除，而以一个新的值来代替</strong>。</p>
<h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>C++语言定义了多种初始化方式。如果使用等号<code>=</code>初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化</strong>。</p>
<p>以初始化<code>string</code>对象为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> str0 = <span class="string">&quot;Value0&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str1 = str0;</span><br><span class="line"><span class="built_in">string</span> str2 = (<span class="string">&quot;Value2&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str3 = &#123; <span class="string">&quot;Value3&quot;</span> &#125;; <span class="comment">//这种初始化方式也被称为列表初始化</span></span><br><span class="line"><span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">&quot;Value4&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，在拷贝初始化中，是否添加括号并没有影响。</p>
<p>当初始值只有一个时，拷贝初始化和直接初始化的效果是相同的。如果初始值有多个，一般只能使用直接初始化。</p>
<blockquote>
<p>对于<code>string</code>对象和<code>vector</code>来说，可以以如下方式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//等价于 string str = &quot;cccccccccc&quot;;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>; <span class="comment">//等价于 vector&lt;int&gt; vec = &#123;1, 1, 1&#125;;</span></span><br></pre></td></tr></table></figure>

<p>该类初始化使用了两个初始值，因此只能使用直接初始化。</p>
</blockquote>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>用花括号<code>&#123;&#125;</code>来初始化变量的形式被称为<strong>列表初始化</strong>，<strong>列表初始化分为直接列表初始化和拷贝列表初始化</strong>。一般来说，使用直接初始化或间接初始化都只能对一个数据类型做初始化，对于数组、向量等数据类型，可以使用列表初始化对各个变量做初始化，<strong>该类初始化不能使用圆括号</strong>。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//拷贝列表初始化。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; LlongVec &#123;<span class="number">12L</span>L, <span class="number">23L</span>L&#125;; <span class="comment">//直接列表初始化。</span></span><br></pre></td></tr></table></figure>

<p>对于单个元素和内置类型来说，也可以使用列表初始化，此时可以看作是对只有一个元素的数组做初始化。<strong>需要注意的是，使用内置类型的变量时，列表初始化有一个重要的特点：如果初始值存在丢失信息的风险，则编译器将报错</strong>。</p>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量时没有进行初始化操作，则变量被<strong>默认初始化</strong>。</p>
<p><strong>内置类型</strong></p>
<p>如果内置类型没有显式初始化，它的值由定义域决定。<strong>定义域任何函数体之外的变量被初始化为0</strong>.<strong>定义在函数体内部的内置类型变量将不被初始化</strong>。试图访问此类值将会引发错误。</p>
<p><strong>内置类型的数组类型</strong></p>
<p>如果数组类型被定义在函数体之内，则每个元素都没有做初始化，如果定义在函数体之外，则每个元素都被初始化为0.</p>
<p>和内置类型不同的是，**访问未被初始化的数组元素不会引发编译错误，<font color="red">但该行为是未定义的</font>**。</p>
<p><strong>自定义数据类型（类）</strong></p>
<p>每个类各自决定初始化对象的方式（即构造函数）。</p>
<p>如果构造函数没有覆盖所有对象的初始化，则未被覆盖的对象按照对应类型的默认初始化规则进行初始化。</p>
<p><strong><code>string</code>类规定如果没有指定初值则生成一个空串</strong></p>
<h4 id="值初始化、zero初始化和聚合类型初始化"><a href="#值初始化、zero初始化和聚合类型初始化" class="headerlink" title="值初始化、zero初始化和聚合类型初始化"></a>值初始化、<code>zero</code>初始化和聚合类型初始化</h4><p><strong>在一般情况下，可以将这三种初始化类型都看作值初始化。其一般规则为，基本内置类型为0，<code>string</code>类型为空串，其他类型遵循各自的规则。</strong></p>
<p>值初始化用于有初始化器但初始化器为空时的情形。<code>zero</code>初始化没有显式调用的语法，在某些值初始化的情况下会调用<code>zero</code>初始化。</p>
<blockquote>
<p>Zero initialization is performed in the following situations:</p>
<ul>
<li>For every named variable with static or thread-local storage duration that is not subject to constant initialization, before any other initialization.</li>
<li>As part of value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided.</li>
<li>When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">&#125;; <span class="comment">// implicit default constructor</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">    T2(<span class="keyword">const</span> T2&amp;) &#123; &#125; <span class="comment">// user-provided copy constructor</span></span><br><span class="line">&#125;;                    <span class="comment">// no default constructor</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">    T3() &#123; &#125; <span class="comment">// user-provided default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s&#123;&#125;; <span class="comment">// class =&gt; default-initialization, the value is &quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n&#123;&#125;;                <span class="comment">// scalar =&gt; zero-initialization, the value is 0</span></span><br><span class="line">    <span class="keyword">double</span> f = <span class="keyword">double</span>();    <span class="comment">// scalar =&gt; zero-initialization, the value is 0.0</span></span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// array =&gt; value-initialization of each element</span></span><br><span class="line">                            <span class="comment">//          the value of each element is 0</span></span><br><span class="line">    T1 t1&#123;&#125;;                <span class="comment">// class with implicit default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t1.mem1 is zero-initialized, the value is 0</span></span><br><span class="line">                            <span class="comment">//     t1.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line"><span class="comment">//  T2 t2&#123;&#125;;                // error: class with no default constructor</span></span><br><span class="line">    T3 t3&#123;&#125;;                <span class="comment">// class with user-provided default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t3.mem1 is default-initialized to indeterminate value</span></span><br><span class="line">                            <span class="comment">//     t3.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// value-initialization of each element</span></span><br><span class="line">                            <span class="comment">// the value of each element is 0</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于聚合类型和<code>array</code>类型来说，在有初始化器但初始化器为空时的情形下，执行聚合类型初始化而不是值初始化。</p>
<blockquote>
<p>聚合类型：</p>
<p>class type (typically, struct or union), that has</p>
<ul>
<li>no private or protected direct non-static data members</li>
<li>no user-provided constructors (explicitly defaulted or deleted constructors are allowed)</li>
<li>no virtual or private base classes</li>
<li>no virtual member functions</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s1 = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;;</span><br><span class="line">    S s2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// same, but with brace elision</span></span><br><span class="line">    S s3&#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;; <span class="comment">// same, using direct-list-initialization syntax</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// ar is int[3]</span></span><br><span class="line">    <span class="keyword">char</span> cr[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// array initialized as &#123;&#x27;a&#x27;, &#x27;\0&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ar2d1[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">// fully-braced 2D array: &#123;1, 2&#125;</span></span><br><span class="line">                                        <span class="comment">//                        &#123;3, 4&#125;</span></span><br><span class="line">    <span class="keyword">int</span> ar2d2[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// brace elision: &#123;1, 2&#125;</span></span><br><span class="line">                                    <span class="comment">//                &#123;3, 4&#125;</span></span><br><span class="line">    <span class="keyword">int</span> ar2d3[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;;   <span class="comment">// only first column: &#123;1, 0&#125;</span></span><br><span class="line">                                    <span class="comment">//                    &#123;2, 0&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; std_ar2&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;    <span class="comment">// std::array is an aggregate</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; std_ar1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// brace-elision okay</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ars[] = &#123;<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;one&quot;</span>), <span class="comment">// copy-initialization</span></span><br><span class="line">                         <span class="string">&quot;two&quot;</span>,              <span class="comment">// conversion, then copy-initialization</span></span><br><span class="line">                         &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125; &#125;; <span class="comment">// list-initialization</span></span><br><span class="line"> </span><br><span class="line">    U u1 = &#123;<span class="number">1</span>&#125;; <span class="comment">// OK, first member of the union</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// aggregate</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base1</span> &#123;</span> <span class="keyword">int</span> b1, b2 = <span class="number">42</span>; &#125;;</span><br><span class="line"><span class="comment">// non-aggregate</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base2</span> &#123;</span></span><br><span class="line">  base2() : b3(<span class="number">42</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> b3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="声明值初始化的变量"><a href="#声明值初始化的变量" class="headerlink" title="声明值初始化的变量"></a>声明值初始化的变量</h5><p>需要注意的是，如下的表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">x</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>并不会声明一个被值初始化的<code>long long</code>型变量。编译器会将其视作一个函数。正确的表达形式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = <span class="keyword">long</span> <span class="keyword">long</span>();</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化还是元素数量？"><a href="#列表初始化还是元素数量？" class="headerlink" title="列表初始化还是元素数量？"></a>列表初始化还是元素数量？</h4><p>通常来说，直接初始化使用圆括号<code>()</code>，列表初始化使用花括号<code>&#123;&#125;</code>。然而，有时单纯依靠括号的类型难以区分。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">3</span>, <span class="number">4</span> &#125;;	<span class="comment">//vec = &#123;3, 4&#125;;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;		<span class="comment">//vec2 = &#123;4, 4, 4&#125;;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果使用的是圆括号，我们可以认为括号内提供的值是用来构造（construct）对象的。</strong>编译器会寻找最合适的构造函数执行初始化操作，否则报错。</p>
<p><strong>如果使用的是花括号，编译器会首先认为我们希望列表初始化（list-initialize）对象。</strong>初始化过程会尽可能把花括号内的值当成是元素的初始值来处理，只有当无法执行列表初始化时才考虑吧其他的初始化方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec0(<span class="number">3</span>, <span class="string">&quot;Value&quot;</span>);	<span class="comment">//construct the vector;</span></span><br><span class="line"><span class="comment">//	vector &lt;string&gt; vec1(3, 4);			//error: construct the vector</span></span><br><span class="line">										<span class="comment">//but can&#x27;t find proper constructor;</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec2&#123; <span class="string">&quot;Value1&quot;</span>, <span class="string">&quot;Value2&quot;</span> &#125;;<span class="comment">//list-initialize;</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec3&#123; <span class="number">2</span>, <span class="string">&quot;Value&quot;</span> &#125;;	<span class="comment">//can&#x27;t list-initialize</span></span><br><span class="line">										<span class="comment">//change to fit constructor;</span></span><br><span class="line"><span class="comment">//	vector &lt;string&gt; vec4&#123; 3, 4 &#125;;		//error: change to constructor</span></span><br><span class="line">										<span class="comment">//can&#x27;t find proper constructor;</span></span><br></pre></td></tr></table></figure>

<h3 id="标识符与命名"><a href="#标识符与命名" class="headerlink" title="标识符与命名"></a>标识符与命名</h3><p>C++的标识符（identifier）由<strong>字母、数字和下划线</strong>组成，并且<strong>必须以字母或下划线开头</strong>。标识符<strong>对长度没有限制，但是对大小写字母敏感</strong>。</p>
<p>C++保留了一些名字供该语言本身使用（即关键字），这些名字不能被使用。</p>
<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h4><ul>
<li>C++为标准库保留了一些名字，因此用户自定义的标识符中不应该连续出现两个下划线，也不应该以下划线紧连大写字母开头。并且定义在函数体外的标识符不应该以下划线开头。</li>
<li>标识符要能体现实际含义。</li>
<li>变量名一般都使用小写字母，如<code>index</code>，不要使用<code>Index</code>或<code>INDEX</code>。</li>
<li>用户自定义的类名一般以大写字母开头，如<code>Sales_Items</code>。</li>
<li>如果标识符由多个单词组成，则单词之间应该有明显区分。常见的方法有<code>studentLoan</code>、<code>student_loan</code>。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++ Primer Reference</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Reference Chapter 2 复合类型</title>
    <url>/2020/12/11/cpp-chapter2/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<ul>
<li>计算机存储与对象地址</li>
<li>复合类型[包括(左值)引用和指针]</li>
<li>常量（包括<code>const</code>和<code>constexpr</code>）</li>
<li>如何利用类型别名（如<code>typedef</code>）和<code>auto</code>类型说明符处理复杂类型</li>
</ul>
<a id="more"></a>

<h1 id="Chapter-2-复合类型"><a href="#Chapter-2-复合类型" class="headerlink" title="Chapter 2 复合类型"></a>Chapter 2 复合类型</h1><p><strong>复合类型</strong>是指基于其他类型定义的类型。C++语言有多种复合类型，其中最基础的时引用和指针。</p>
<p>在变量声明部分，我们指出，变量定义的基本形式是：<strong>基本数据类型 + 声明符列表</strong>，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p>对于基本类型，其声明符即为其标识符（名字）。然而，<strong>对于复合类型，其声明符不仅包含标识符，也包含类型修饰符</strong>。</p>
<h2 id="2-1-对象的地址"><a href="#2-1-对象的地址" class="headerlink" title="2.1 对象的地址"></a><strong>2.1 对象的地址</strong></h2><p>计算机以比特序列存储数据。可寻址的最小内存块称为<strong>字节<code>byte</code>**，存储的基本单元称为</strong>字<code>word</code>**，它通常由几个字节组成。</p>
<p>大多数计算机将内存中的每个字节与一个（通常为16进制的）数字关联起来。<strong>与内存中每个字节相关联的数字被称为地址（address）</strong>。我们能够使用某个地址来表示从这个地址开始的大小不同的比特串（比如<code>int</code>类型是4个字节，<code>long long</code>是8个字节）。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。<strong>类型决定了数据所占的比特数以及该如何解释这些比特的内容</strong>。</p>
<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3><p>为了获得某个对象在计算机中所在的地址，需要使用**取地址符<code>&amp;</code>**。结合<code>sizeof</code>运算符可以得到某个对象在计算机中存储的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> lval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* ladr = &amp;lval;</span><br><span class="line">	<span class="keyword">int</span>* adr = &amp;val;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lval : from &quot;</span> &lt;&lt; ladr &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (ladr + <span class="keyword">int</span>(<span class="keyword">sizeof</span>(lval))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val : from &quot;</span> &lt;&lt; adr &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (adr + <span class="keyword">int</span>(<span class="keyword">sizeof</span>(val))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a><strong>2.2 引用</strong></h2><p><font color="blue">【引用与const的结合，参考常量部分】</font></p>
<p><strong>引用</strong>(reference)为对象起了另外一个名字，引用类型引用另外一种类型。</p>
<p><strong>通过将声明符写成<code>&amp;val</code>的形式来定义引用类型。其中<code>val</code>是变量的标识符。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refIval = ival;</span><br></pre></td></tr></table></figure>

<h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3><p><strong>引用并非对象</strong>，相反，他只是为一个已经存在的对象另外起一个名字。</p>
<p>在定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p>从地址的角度来说，对对象本身和它的引用取地址，得到的地址是相同的。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。</p>
<p>由于引用本身不是一个对象，因此<strong>不能定义引用的引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line"><span class="comment">//	int&amp; refIval2;	//Error: 引用必须初始化</span></span><br><span class="line">	ival = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;, refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	refIval += <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;, refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of ival: &quot;</span> &lt;&lt; &amp;ival</span><br><span class="line">		&lt;&lt; <span class="string">&quot;, address of refIval: &quot;</span> &lt;&lt; &amp;refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定还是赋值？"><a href="#绑定还是赋值？" class="headerlink" title="绑定还是赋值？"></a>绑定还是赋值？</h3><p>如果写出如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>, ival1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line">refIval = ival1;</span><br></pre></td></tr></table></figure>

<p>看起来我们更改了<code>refIval</code>的绑定对象，将其绑定到了<code>ival1</code>对象上。但是，如果执行如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>, ival1 = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line">	refIval = ival1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;address of ival is &quot;</span> &lt;&lt; &amp;ival &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;address of refIval is &quot;</span> &lt;&lt; &amp;refIval &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;address of ival1 is &quot;</span> &lt;&lt; &amp;ival1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现<code>ival</code>的值变为2，并且<code>refIval</code>的地址与<code>ival</code>相同而不是<code>ival1</code>。</p>
<p>在这里，编译器将<code>refIval = ival1;</code>看作是赋值语句而不是绑定语句。因此，其和<code>ival = ival1</code>是等价的。因此，执行该条代码的效果是将<code>ival1</code>的值赋给了<code>ival</code>。</p>
<h2 id="2-3-指针"><a href="#2-3-指针" class="headerlink" title="2.3 指针"></a><strong>2.3 指针</strong></h2><p><font color="blue">【指针与const的结合，参考常量部分】</font></p>
<p>定义指针的方法是将声明符写成<code>*d</code>的形式。<strong>指针存放某个对象的地址</strong>，其实现了对某个对象的间接访问。</p>
<p>除了某些特殊情况，<strong>指针的类型需要和他所指的对象严格匹配</strong>。</p>
<p>如果指针指向了一个对象，则可以使用**解引用符<code>*</code>**来访问该对象。</p>
<p>和引用不同的是，指针属于对象，因此可以定义指针的指针，也可以定义指针的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* pVal = &amp;val;</span><br><span class="line"><span class="comment">//	double* pDVal = &amp;val; //Error.</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *pVal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	*pVal += <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p><strong>空指针不指向任何一个对象</strong>。以下是几个生成空指针的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">int</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span>* ptr3 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><code>void*</code>指针</h3><p><strong><code>void*</code>指针是一种特殊的指针类型，可用于存放任意对象的地址。</strong>我们仅能够将此类指针和其他指针比较，作为函数的输入和输出，或者赋给另一个<code>void*</code>指针（而不能赋给其他类型的指针），而不能直接操作指针所指向的对象。</p>
<blockquote>
<p>简单来说，<code>void*</code>指针仅保存了某一个地址。由于我们不知道该地址存储着什么类型的值，所以我们无法访问内存空间中所存的对象。</p>
</blockquote>
<p><strong>由于<code>void*</code>指针可以存放任意对象的地址，因此任意对象的地址都可以使用<code>static_cast</code>转换为<code>void*</code>指针。此外，由于<code>void*</code>可以存放任意对象的地址，因此使用<code>static_cast</code>可以将<code>void*</code>转换为任意类型对象的指针</strong>。</p>
<h3 id="基于指针的操作"><a href="#基于指针的操作" class="headerlink" title="基于指针的操作"></a>基于指针的操作</h3><h4 id="条件值"><a href="#条件值" class="headerlink" title="条件值"></a>条件值</h4><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算数值作为条件遵循的规则类似，如果指针的值为0，条件取<code>false</code>，任何非0指针对应的条件值都是<code>true</code>。</p>
<h4 id="相等与比较"><a href="#相等与比较" class="headerlink" title="相等与比较"></a>相等与比较</h4><p>对于<strong>两个类型相同且均合法</strong>的指针，可以用相等操作符<code>==</code>和不等操作符<code>!=</code>来比较他们。如果两个指针的地址相同，则它们相等，反之不相等。</p>
<p><strong>对于两个指针，如果某个指针指向的位置在另一个指针所指向的位置之后，则说第一个指针大于<code>&gt;</code>后一个指针。反之则小于。</strong></p>
<h4 id="递增、与整数的运算"><a href="#递增、与整数的运算" class="headerlink" title="递增、与整数的运算"></a>递增、与整数的运算</h4><p>C++支持指针加上或减去一个整数，其效果是将指针指向的位置相前或向后移动指定的偏移量。</p>
<p><strong>对于指针来说，指针移动的最小偏移量是其所指的类型的大小</strong>。由于<code>void*</code>不指向某种特定的类型，因此<code>void*</code>指针不支持算术运算。</p>
<p>此外，指针还可以使用递增运算符<code>++</code>和递减运算符<code>--</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* ptr = &amp;(arr[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(++ptr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr += <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(ptr - <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="两指针的运算"><a href="#两指针的运算" class="headerlink" title="两指针的运算"></a>两指针的运算</h4><p>可以令两个指针相减，其结果是两者的距离。也就是说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">	<span class="keyword">int</span> delta = ptr1 - ptr2</span><br><span class="line">then</span><br><span class="line">	ptr1 = ptr2 + delta</span><br></pre></td></tr></table></figure>

<p>**两指针相减的结果类型为<code>ptrdiff_t</code>**，通常也写为<code>int</code>。</p>
<h3 id="使用指针的危险性"><a href="#使用指针的危险性" class="headerlink" title="使用指针的危险性"></a>使用指针的危险性</h3><p><strong><font color="red">错误地使用指针会导致无法预计的后果</font></strong></p>
<p>指针的值应该属于下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置（一般用于迭代器）</li>
<li>空指针</li>
<li>无效指针</li>
</ul>
<p>其中，<font color="red">试图访问无效指针的值将引发无法预计的后果</font>，因此，程序员必须清楚任意给定的指针是否是有效的。除此之外，第二种和第三种形式的指针尽管是有效的，但是他们的使用受到很大的限制。<font color="red">对该类指针使用解引用符也会引发无法预计的后果</font>。</p>
<p><strong><font color="red">使用未经初始化的指针是引发运行时错误的一大原因</font></strong></p>
<p>和其他变量一样，未经初始化的指针的值时未定义的，但是和基本类型不同的是，<font color="red">编译器不负责检查未初始化指针造成的错误</font>。因此，在使用过程中，应在定义了对象之后再定义指向它的指针，并且保证<strong>初始化所有指针</strong>，包括还不清楚应该指向何处的（初始化为空指针）。</p>
<p><strong>在可能的情况下， 避免使用指针</strong></p>
<h2 id="2-4-复杂复合类型的声明"><a href="#2-4-复杂复合类型的声明" class="headerlink" title="2.4 复杂复合类型的声明"></a><strong>2.4 复杂复合类型的声明</strong></h2><p>如前所述，变量的定义包含一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只能有一个，但是声明符的形式却可以不同。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>, * ptr = &amp;val, &amp; ref = val;</span><br><span class="line"><span class="comment">//ptr是指向val的指针，ref是val的引用。</span></span><br></pre></td></tr></table></figure>

<p>并且，<strong>在定义语句中，类型修饰符仅作用于紧随它的一个变量</strong>，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;val, val2 = <span class="number">3</span>;<span class="comment">//ptr是指针，而val2是int型变量。</span></span><br></pre></td></tr></table></figure>

<p>由于指针可以嵌套使用，因此复合类型的声明可能会非常复杂。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* pVal = &amp;val;		<span class="comment">//pVal是指向val的指针</span></span><br><span class="line">	<span class="keyword">int</span>** ppVal = &amp;pVal;		<span class="comment">//ppVal是指向pVal的指针</span></span><br><span class="line">	<span class="keyword">int</span>**&amp; rppVal = ppVal;		<span class="comment">//rppVal是ppVal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左阅读有利于理解其真实含义</strong>。除此之外，也可以使用<code>auto</code>和<code>typedef</code>简化理解复杂声明语句。</p>
<h2 id="2-5-常量"><a href="#2-5-常量" class="headerlink" title="2.5 常量"></a><strong>2.5 常量</strong></h2><h3 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a><code>const</code>对象</h3><p>常量是其值不能被改变的变量。我们可以<strong>使用关键字<code>const</code>对变量的类型加以限定，定义常量</strong>。</p>
<p>由于<code>const</code>对象一旦定义后其值不可以再改变，<strong>因此<code>const</code>常量必须初始化</strong>，并且任何试图改变常量值的操作都会引发错误。</p>
<h4 id="const对象仅在文件内有效"><a href="#const对象仅在文件内有效" class="headerlink" title="const对象仅在文件内有效"></a><code>const</code>对象仅在文件内有效</h4><p>当编译<code>const</code>对象时，编译器将在编译过程中把用到该变量的地方都替换为对应的值。为了执行上述替换，编译器必须知道常量的初始值。如果程序包含多个文件，则在每一个用到变量的文件中都有它的定义。为了支持这一做法，并且避免对同一变量的重复定义，默认情况下， <strong><code>const</code>对象被设置为仅在当前文件有效</strong>，也就是说，当多个文件中出现了同名的<code>const</code>变量时，等同于在不同文件中分别定义了独立的变量。</p>
<p><strong>如果想在多个文件之间共享<code>const</code>对象，必须在变量的定义之前添加<code>extern</code>关键字</strong>。</p>
<h3 id="const与复合类型"><a href="#const与复合类型" class="headerlink" title="const与复合类型"></a><code>const</code>与复合类型</h3><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>可以把引用绑定到<code>const</code>对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span>&amp; ref = PI;</span><br><span class="line"><span class="comment">//	ref = 3.15; //Error 不能修改常量值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指向常量的指针-amp-指针常量"><a href="#指向常量的指针-amp-指针常量" class="headerlink" title="指向常量的指针&amp;指针常量"></a>指向常量的指针&amp;指针常量</h4><p>和引用不同，指针和指针指向的位置都是对象。<strong>指向常量的指针</strong>是指指针中储存的地址可以改变，但是指针指向的那片内存对应的是常量类型。而<strong>指针常量</strong>是指指针本身是一个常量，即存储地址的那片内存不可修改，然而该地址所指向的对象不一定是常量。</p>
<p>和复杂声明类似，区分两者的方法是从右向左阅读。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> cVal = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> CptrToVal = &amp;val;	<span class="comment">//指向int的常量指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* ptrToCval = &amp;cVal;	<span class="comment">//指向const int的指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> CptrToCval = &amp;cVal;	<span class="comment">//指向const int的常量指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对<code>const</code>的引用可能引用一个并非<code>const</code>的对象</h4><p>对于常量引用呵指向常量的指针来说，其<code>const</code>属性仅仅是对引用和指针的操作做出了限定，<strong>对于引用对象本身是不是一个常量未作限定</strong>。换句话说，指向常量的指针或引用，仅仅是引用和指针把其对象看作一个常量所以不去修改它，但是这个对象到底可以不可以修改则不确定。<strong>更简单地来说，可以将变量看作常量，但不可以把常量看作变量</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> fval = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; cref = val;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* cptr = &amp;val;	<span class="comment">//可以对变量做常量引用</span></span><br><span class="line"><span class="comment">//	cref = 3;	//但是不能通过cref修改val的值</span></span><br><span class="line"><span class="comment">//	double* ptr = &amp;fval;	//常量只能做常量引用或指向常量的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层<code>const</code>与底层<code>const</code></h3><p>对于指针来说，指针本身是一个对象，但是它又可以指向另外一个对象，因此，指针本身是不是常量（即是不是<strong>指针常量</strong>）以及指针所指的对象是不是一个常量（即是不是<strong>指向常量的指针</strong>）就是两个相互独立的问题。</p>
<p>我们用名词<strong>顶层<code>const</code>**表示指针本身是一个常量，用名词</strong>底层<code>const</code>**表示指针所指的对象是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cval = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr1 = &amp;cval;	<span class="comment">//底层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;val;		<span class="comment">//顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr3 = &amp;cval;	<span class="comment">//顶层const &amp; 底层const</span></span><br></pre></td></tr></table></figure>

<p>更一般地来说， 顶层<code>const</code>可以表示任意对象是常量，这一点对任何数据类型都适用，如算术类型、指针、类等；而底层<code>const</code>则与指针和引用等复合类型的基本类型部分有关。</p>
<h4 id="const与拷贝"><a href="#const与拷贝" class="headerlink" title="const与拷贝"></a><code>const</code>与拷贝</h4><p>当执行对象的拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显。</p>
<p>一方面，由于执行拷贝操作并不会改变被拷贝对象的值，因此<strong>顶层<code>const</code>对拷贝过程无影响</strong>。而另一方面，<strong>底层<code>const</code>的限制却不能忽略</strong>。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层<code>const</code>资格（或者两个对象的数据类型必须能够转换，一般来说，<strong>非常量可以转换为常量，反之则不行</strong>）。</p>
<h4 id="使用const简化参数传递"><a href="#使用const简化参数传递" class="headerlink" title="使用const简化参数传递"></a>使用<code>const</code>简化参数传递</h4><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。然而，对于较大的类类型对象，拷贝过程将非常低效，甚至有的类类型不支持拷贝操作。因此，<strong>在某些情况，我们需要通过引用形参访问该类型的对象</strong>。<font color="blue">【参考函数部分】</font></p>
<p>然而，如果将形参定义为引用，我们将不能向其中传递（字面值）常量（即使我们并无意修改形参的值）。例如下面的程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	function(3); 	//error:3不是一个可修改的左值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种常用的方法是定义重载函数，另一方面,利用<strong>非常量可以转换为常量</strong>的性质，<strong>当我们不需要修改形参的值（即不将其作为左值）时，我们也可以使用<code>const</code>简化参数传递</strong>。该方法常见于运算符重载中。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="built_in">string</span> str) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;The String is : &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	function(<span class="number">3</span>); 	<span class="comment">//Valid.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-constexpr和常量表达式"><a href="#2-6-constexpr和常量表达式" class="headerlink" title="2.6 constexpr和常量表达式"></a><strong>2.6 <code>constexpr</code>和常量表达式</strong></h2><p><strong>常量表达式</strong>是指值不会改变，并且在<strong>编译过程中</strong>就可以得到计算结果的表达式。显然，<strong>字面值属于常量表达式</strong>。</p>
<p>一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_FILES = getsize();</span><br><span class="line"><span class="keyword">int</span> LIMIT = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>

<p><code>MAX_FILES</code>和<code>LIMIT</code>均不是常量表达式。对于第一个，虽然该对象有<code>const</code>前缀，但是<code>getsize()</code>的返回值只有等到运行时才能获取到，所以不是常量表达式。对于第二个，虽然该对象的初始值是一个字面值常量，但由于它的数据类型只是一个普通<code>int</code>而非<code>const int</code>，所以也不属于常量表达式。</p>
<p>由于常量表达式的逻辑非常复杂，因此在一个复杂系统中，几乎不可能分辨出一个初始值到底是不是常量表达式。因此，C++11允许<strong>将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否为一个常量表达式</strong>。</p>
<p><strong>声明为<code>constexpr</code>的变量一定是一个常量，并且必须用常量表达式初始化</strong>。对于不符合要求的初始化的常量表达式（即编译器在编译过程中无法确定被定义为<code>constexpr</code>对象的值），编译器将在编译过程中报错。</p>
<p>同样，我们以可以将函数类型定义为<code>constexpr</code>。被定义为该类型的函数可以被用作初始化<code>constexpr</code>变量。但该函数的定义有很大的限制。<font color="blue">【参考函数部分】</font>例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">21</span>;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_FILES = getsize();</span><br></pre></td></tr></table></figure>

<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>常量表达式的值需要在编译时就得到计算，因此对声明<code>constexpr</code>时用到的类型必须有所限制。因为这些类型比较简单，值也显而易见，因此将其成为字面值类型。</p>
<p>**算术类型、引用、指针都属于字面值类型，（大部分）自定义类类型、IO库、<code>string</code>类型不属于字面值类型，也就不能被定义为<code>constexpr</code>**。</p>
<p><font color="blue">【还有一些其他特殊的类型属于字面值类型，参考字面值类类型和枚举类型部分】</font></p>
<h3 id="字面值类型与复合类型"><a href="#字面值类型与复合类型" class="headerlink" title="字面值类型与复合类型"></a>字面值类型与复合类型</h3><p>尽管指针和引用都可以被定义为<code>constexpr</code>，但是他们的初始值受到严格的限制。</p>
<p><code>constexpr</code>指针的初始值必须是**<code>nullptr</code>或者<code>0</code><strong>，或者是某个</strong>存储于固定地址中的对象**。</p>
<blockquote>
<p>函数体内部定义的变量一般来说存放于非固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反的，定义于所有函数体之外的对象的地址不变，因此可以指向这样的对象。此外，C++允许函数定义有效范围超出函数本身的变量，这些变量也有固定的地址。</p>
<p><font color="blue">【参考函数部分】</font></p>
</blockquote>
<h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和<code>constexpr</code></h4><p>在<code>constexpr</code>中如果声明了一个指针，限定符<code>constexpr</code>仅对指针有效，与指针所指对象无关。换句话说，**<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>**。与其他常量指针类似，<code>constexpr</code>指针既可以指向常量也可以指向一个非常量。如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">23</span>;	<span class="comment">//static参见函数部分</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> bVal = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span>* ptr = &amp;val;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">bool</span>* bPtr = &amp;bVal;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-处理类型"><a href="#2-7-处理类型" class="headerlink" title="2.7 处理类型"></a><strong>2.7 处理类型</strong></h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名是一个名字，它是某种类型的同义词，使用类型别名可以让复杂的类型名字变得简单明了、易于理解和使用。并且有助于程序员清楚地知道使用该类型的真实目的。有两种方法可以定义类型别名：</p>
<p><strong>使用关键字<code>typedef</code>定义类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* ptrToInt;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">23</span>;</span><br><span class="line">ptrToInt ptr = &amp;val;</span><br></pre></td></tr></table></figure>

<p><strong>使用别名声明定义类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Flag = <span class="keyword">bool</span>;</span><br><span class="line">Flag flg = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><p>类型别名区别于宏，简单地把类型别名替换成其本来的样子以理解该语句会导致错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的代码里面，<code>cptr</code>和<code>ptr</code>的类型并不相同。看起来将<code>pstring</code>直接替换为<code>char *</code>非常合适，但是在替换之后，<code>*</code>从原来的类型名的一部分变成了变量说明符。换句话说，<code>cptr</code>前的<code>const</code>修饰的是<code>pstring</code>，即修饰的时<code>char*</code>，而<code>ptr</code>前的<code>const</code>修饰的是<code>char</code>。因此，<code>cptr</code>是常量指针，而<code>ptr</code>是指向常量的指针变量。如果要借助类型别名定义指向常量的指针，应该参考下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span>* pstring;</span><br><span class="line">pstring cptr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a><code>auto</code>类型说明符</h3><p><font color="blue">【<code>auto</code>类型说明符作用于数组类型见数组部分】</font></p>
<p>一些变量的类型非常复杂，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator x = vec.begin();</span><br><span class="line"><span class="keyword">ptrdiff_t</span> dif = vec.end() - vec.begin();</span><br></pre></td></tr></table></figure>

<p>并且在复杂程序中，判断一个变量的类型并不是一件轻松的事情。为了解决这个问题，C++11引入了<code>auto</code>类型说明符，它能够让编译器替我们去分析表达式所属的类型。<code>auto</code>让编译器<strong>通过初始值来推算变量的类型</strong>，因此，**<code>auto</code>定义的变量必须有初始值，并且一条声明语句中所有变量的初始值的基本数据类型应该都相同**。</p>
<h4 id="推断规则"><a href="#推断规则" class="headerlink" title="推断规则"></a>推断规则</h4><p>编译器推断出来的<code>auto</code>类型和初始值往往不完全相同。编译器会适当地改变结果类型使其更符合初始化规则。</p>
<ol>
<li><p>使用引用其实是使用引用的对象，因此，<strong>当引用被作为初始值时，<code>auto</code>将依照被引用对象的类型推断</strong>。为了声明引用类型，可以利用说明符。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>, &amp; ref = val;</span><br><span class="line"><span class="keyword">auto</span> i = ref;	<span class="comment">//i的类型为int</span></span><br><span class="line"><span class="keyword">auto</span>&amp; k = ref;	<span class="comment">//k的类型为int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto</code>一般<strong>会忽略顶层<code>const</code>**，但是</strong>会保留底层<code>const</code>**。如果希望推断出的是一个顶层<code>const</code>，则需要明确指出。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> cptr = &amp;val;</span><br><span class="line"><span class="keyword">auto</span> i = cptr;	<span class="comment">//i的类型为int*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> k = cptr;	<span class="comment">//k的类型为int* const</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a><code>decltype</code>类型指示符</h3><p><font color="blue">【<code>decltype</code>类型指示符作用于数组类型见数组部分】</font></p>
<p>如果我们希望从表达式的类型推断出要定义的新的变量的类型，但是不想用该表达式的值初始化变量，我们可以使用类型说明符<code>decltype</code>。它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式的值并得到他的类型，但是不实际计算表达式的值。其用法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">decltype</span>(isValid()) flag = <span class="literal">false</span>;	<span class="comment">//flag的类型为bool</span></span><br></pre></td></tr></table></figure>

<h4 id="推断规则-1"><a href="#推断规则-1" class="headerlink" title="推断规则"></a>推断规则</h4><p><code>decltype</code>类型说明符的推断规则比较复杂。</p>
<ul>
<li>如果<code>decltype</code>使用的表达式是一个变量，则<strong>其返回类型和该变量完全相同（包括引用和顶层<code>const</code>，这一点和<code>auto</code>不同）</strong>。</li>
<li>如果<code>decltype</code>使用的表达式是一个变量，<strong>但是给变量加上了一层或多层括号，则其返回类型会得到引用</strong>。</li>
</ul>
<p>见下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cval = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr1 = &amp;cval;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr3 = ptr1;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; cref = cval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(val) x1;	<span class="comment">/*int */</span>					<span class="keyword">decltype</span>((val)) k1 = val;	<span class="comment">/*int&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(cval) x2 = <span class="number">1</span>;	<span class="comment">/*const int */</span>			<span class="keyword">decltype</span>((cval)) k2 = cval;	<span class="comment">/*const int&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr1) x3;	<span class="comment">/*const int* */</span>				<span class="keyword">decltype</span>((ptr1)) k3;	<span class="comment">/*const int*&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr2) x4 = <span class="literal">nullptr</span>;	<span class="comment">/*int* const */</span>	<span class="keyword">decltype</span>((ptr2)) k4 = x4;	<span class="comment">/*int* const */</span></span><br><span class="line"><span class="keyword">decltype</span>(ref) x5 = val; <span class="comment">/*int&amp; */</span>				<span class="keyword">decltype</span>((ref)) k5 = val; <span class="comment">/*int&amp; 引用的引用还是引用*/</span></span><br><span class="line"><span class="keyword">decltype</span>(cref) x6 = cval;	<span class="comment">/*const int&amp; */</span>		<span class="keyword">decltype</span>((cref)) k6 = cval;	<span class="comment">/*const int&amp; 引用的引用还是引用*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>decltype</code>使用的表达式不是一个变量，则其返回对象的类型与表达式返回的类型是相同的，而<strong>是否添加引用取决于该表达式返回的值能否作为一条赋值语句的左值</strong><font color="blue">【参考函数部分和表达式部分】</font>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, * p = &amp;i, &amp; r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;	<span class="comment">//int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i;	<span class="comment">//int&amp;</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>r</code>是一个引用，但是由于<code>r+0</code>返回的值是 <code>int</code>，并且该值不可做为左值，因此<code>b</code>的类型为<code>int</code>。</p>
<p>相反，虽然<code>*p</code>的类型为<code>int</code>，但是由于<code>*p</code>可以作为左值，因此<code>c</code>的类型为<code>int&amp;</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++ Primer Reference</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDA的技巧汇总</title>
    <url>/2020/12/13/CTF-re-tipsForIDA/</url>
    <content><![CDATA[<p><strong>本文汇总了一些使用IDA调试的技巧。掌握这些技巧可以极大方便日常使用。</strong></p>
<a id="more"></a>

<h1 id="自定义类型和变量"><a href="#自定义类型和变量" class="headerlink" title="自定义类型和变量"></a>自定义类型和变量</h1><h2 id="修改变量标识符"><a href="#修改变量标识符" class="headerlink" title="修改变量标识符"></a>修改变量标识符</h2><p>例如在反汇编状态下有如下的一个函数：</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213192949341.png" alt="image-20201213192949341"></p>
<p>可以看出以下的一些信息：</p>
<blockquote>
<p><code>a1</code>是函数形参，并且是一个<code>char</code>类型的数组；</p>
<p><code>v4</code>表示了数组<code>a1</code>的长度；</p>
</blockquote>
<p>因此，为了便于我们阅读，我们可以修改这些变量的标识符。<strong>其方法为将光标放在需要修改的变量上，右键，可以看到<code>Rename Ival</code>选项，单击该选项，（也可以直接使用快捷键<code>N</code>）即可以进行修改。</strong></p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213193630775.png" alt="image-20201213193630775"></p>
<p>下面是修改后的代码：</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213193802256.png" alt="image-20201213193802256"></p>
<h2 id="修改变量类型"><a href="#修改变量类型" class="headerlink" title="修改变量类型"></a>修改变量类型</h2><p>再看下面的函数：</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213194334019.png" alt="image-20201213194334019"></p>
<p>我们可以发现：<strong>虽然<code>v9</code>在这里是一个<code>long long </code>类型的变量，但是后续的使用全部将其看作<code>char</code>类型数组进行访问。</strong>因此我们有必要，也完全可以将其进行类型转换。**转换方法和前述相同，在右键菜单中选择<code>Set Ival type</code>，或者使用快捷键<code>y</code>**。下面是转换过后的函数代码：</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213194911482.png" alt="image-20201213194911482"></p>
<p>可以看到，转换后的代码更加清晰明了。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>例如如下代码：</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213195145545.png" alt="image-20201213195145545"></p>
<p>我们可以看到如下的信息：</p>
<blockquote>
<p><code>Dst</code>是一个16字节的变量，初始状态下为0。<code>v5</code>（一个指向内存大小为16个字节的指针）指向<code>Dst</code>的地址。在循环中，<code>v1</code>同样是一个16字节的变量，其前八个字节被定义为一个变量，值为<code>Str[i]</code>，后八个字节被设置为全0.而<code>v5</code>的后八个字节存储着<code>v1</code>的地址。之后<code>v5</code>更新为<code>v1</code>，在后续的循环中<code>v1</code>又重新声明内存。</p>
</blockquote>
<p>因此我们猜测这是一个添加链表元素的过程。因此我们可以在IDA中新建一个结构体，显式地定义List结构体。</p>
<p><strong>打开<code>View-Open subviews-Local types</code>窗口</strong></p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213201115105.png" alt="image-20201213201115105"></p>
<p><strong>点<code>insert</code>，在新出现的窗口输入希望创建的结构体对应的C代码</strong></p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213201441268.png" alt="image-20201213201441268"></p>
<p>之后，就可以将其看作正常的结构，使用上面的方法进行修改。</p>
<p><img src="/2020/12/13/CTF-re-tipsForIDA/image-20201213201630912.png" alt="image-20201213201630912"></p>
<p>可以看到，在使用自定义结构体之后，整个函数就变得非常简洁明了。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Reverse_逆向</category>
        <category>IDA</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>编码算法:Base 64</title>
    <url>/2020/12/13/base64/</url>
    <content><![CDATA[<p><strong>Base 64编码算法详解</strong></p>
<a id="more"></a>

<h1 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h1><p>在计算机中。字符一般使用8位（即1个字节）大小的内存进行存储，该1个字节大小的内存可以表示从0到255之间的整数。而ASCII编码表在这里就定义了数字到字符的一一对应关系。因此，给定一个二进制串，计算机可以按照每八位为一个单位，查表得到整个字符串；反过来，给定一个字符串，也可以查表得到该字符串对应的二进制串。</p>
<p><strong>而对于Base 64来说，其使用六位来表示一个字符</strong>。因此，编码后的字符串仅包括64个不同的字符（还有一个字符<code>=</code>用于补位，因此准确地说是65个不同的字符）。下面通过实例来说明Base 64的编码原理。</p>
<p>标准的Base 64也有一个<strong>编码表</strong>，通常表示为</p>
<p><code>lookup = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</code></p>
<p>具体如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><strong>A</strong></td>
<td align="center">17</td>
<td align="center"><strong>R</strong></td>
<td align="center">34</td>
<td align="center"><strong>i</strong></td>
<td align="center">51</td>
<td align="center"><strong>z</strong></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><strong>B</strong></td>
<td align="center">18</td>
<td align="center"><strong>S</strong></td>
<td align="center">35</td>
<td align="center"><strong>j</strong></td>
<td align="center">52</td>
<td align="center"><strong>0</strong></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>C</strong></td>
<td align="center">19</td>
<td align="center"><strong>T</strong></td>
<td align="center">36</td>
<td align="center"><strong>k</strong></td>
<td align="center">53</td>
<td align="center"><strong>1</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><strong>D</strong></td>
<td align="center">20</td>
<td align="center"><strong>U</strong></td>
<td align="center">37</td>
<td align="center"><strong>l</strong></td>
<td align="center">54</td>
<td align="center"><strong>2</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>E</strong></td>
<td align="center">21</td>
<td align="center"><strong>V</strong></td>
<td align="center">38</td>
<td align="center"><strong>m</strong></td>
<td align="center">55</td>
<td align="center"><strong>3</strong></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><strong>F</strong></td>
<td align="center">22</td>
<td align="center"><strong>W</strong></td>
<td align="center">39</td>
<td align="center"><strong>n</strong></td>
<td align="center">56</td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><strong>G</strong></td>
<td align="center">23</td>
<td align="center"><strong>X</strong></td>
<td align="center">40</td>
<td align="center"><strong>o</strong></td>
<td align="center">57</td>
<td align="center"><strong>5</strong></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><strong>H</strong></td>
<td align="center">24</td>
<td align="center"><strong>Y</strong></td>
<td align="center">41</td>
<td align="center"><strong>p</strong></td>
<td align="center">58</td>
<td align="center"><strong>6</strong></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><strong>I</strong></td>
<td align="center">25</td>
<td align="center"><strong>Z</strong></td>
<td align="center">42</td>
<td align="center"><strong>q</strong></td>
<td align="center">59</td>
<td align="center"><strong>7</strong></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><strong>J</strong></td>
<td align="center">26</td>
<td align="center"><strong>a</strong></td>
<td align="center">43</td>
<td align="center"><strong>r</strong></td>
<td align="center">60</td>
<td align="center"><strong>8</strong></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><strong>K</strong></td>
<td align="center">27</td>
<td align="center"><strong>b</strong></td>
<td align="center">44</td>
<td align="center"><strong>s</strong></td>
<td align="center">61</td>
<td align="center"><strong>9</strong></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><strong>L</strong></td>
<td align="center">28</td>
<td align="center"><strong>c</strong></td>
<td align="center">45</td>
<td align="center"><strong>t</strong></td>
<td align="center">62</td>
<td align="center"><strong>+</strong></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><strong>M</strong></td>
<td align="center">29</td>
<td align="center"><strong>d</strong></td>
<td align="center">46</td>
<td align="center"><strong>u</strong></td>
<td align="center">63</td>
<td align="center"><strong>/</strong></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><strong>N</strong></td>
<td align="center">30</td>
<td align="center"><strong>e</strong></td>
<td align="center">47</td>
<td align="center"><strong>v</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><strong>O</strong></td>
<td align="center">31</td>
<td align="center"><strong>f</strong></td>
<td align="center">48</td>
<td align="center"><strong>w</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><strong>P</strong></td>
<td align="center">32</td>
<td align="center"><strong>g</strong></td>
<td align="center">49</td>
<td align="center"><strong>x</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><strong>Q</strong></td>
<td align="center">33</td>
<td align="center"><strong>h</strong></td>
<td align="center">50</td>
<td align="center"><strong>y</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101</code></p>
<p>如果我们将其按照三个一组进行分组，就可以得到<code>001 110 101 110 101 011 101 011 101 010 000 101</code></p>
<p>现在，我们每两组作为一个单位，可以得到<code>\14\46\43\43\42\5</code></p>
<p>通过查表，既可以得到编码后的字符串为**<code>OurrqF</code>**</p>
</blockquote>
<p>上面说的是理想的情况，通常情况下，<strong>字符串对应的二进制串的长度是8的倍数，但很有可不是6的倍数</strong>。为了解决这个办法，Base 64要求在原二进制串后填0，将该字符串扩充为长度是6的倍数，并使用字符<code>=</code>进行补位（等号的个数取决于补位的0的数量）。补位有两种可能出现的情况，接下来将分别说明。</p>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111 1110</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 111 10</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 111111 10[0000]</code></strong></p>
<p>另一种情况，假设我们有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 1</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 1111[00]</code></strong></p>
</blockquote>
<p>实际上我们可以证明，补位仅有两种情况。因此Base 64编码规定，如果在二进制串末尾补0的个数为2，则在编码后字符串末尾添加一个等号<code>=</code>。如果补0的个数为4，则添加两个等号<code>==</code>。</p>
<blockquote>
<p>因此，上面两个二进制串经过编码得到的字符串为：</p>
<p><strong><code>OurrqF/g==</code>**和</strong><code>OurrqF8=</code>**</p>
</blockquote>
<p>在知道编码原理之后，解码的过程就容易理解了。</p>
<h1 id="换表Base-64"><a href="#换表Base-64" class="headerlink" title="换表Base 64"></a>换表Base 64</h1><p>由上面的讨论可以看出，如果知道了Base 64的检索表，就可以完全将编码反编码。因此，为了保证更高的安全性（或者提高问题的难度），通常会使用新的检索表（而不是标准检索表）。</p>
<p>对于换表Base 64，一种方法是在函数中定义新的检索表，直接进行编码和文本之间的转换，另一种方法是做两次变换，将换表Base 64看作<strong>Text &lt;-&gt; 旧表下的Code &lt;-&gt;新表下的Code</strong>这样的函数的复合。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong><a href="https://base64.us/">在线编码网站</a></strong></p>
<p>Python中内置了Base 64编码库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;加密&quot;&quot;&quot;</span></span><br><span class="line">byte_text = text.encode()   </span><br><span class="line">		<span class="comment">#base64模块使用byte而不是str类型</span></span><br><span class="line">code = base64.b64encode(byte_text).decode()</span><br><span class="line">		<span class="comment">#b64encode()函数用于将字符串进行转换，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(code)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;解密&quot;&quot;&quot;</span></span><br><span class="line">de_text = base64.b64decode(code.encode()).decode()   </span><br><span class="line">		<span class="comment">#b64decode()函数是b64encode()的逆过程，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(de_text)</span><br></pre></td></tr></table></figure>

<p>Python函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_encode</span>(<span class="params">text, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(text, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> text])</span><br><span class="line">    remainder = <span class="built_in">len</span>(bin_str) % <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        bin_str += <span class="string">&quot;0&quot;</span> * (<span class="number">6</span> - remainder)</span><br><span class="line">    bin_str += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    code = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_str) // <span class="number">6</span>):</span><br><span class="line">        code += lookup[<span class="built_in">int</span>(bin_str[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        code += <span class="string">&quot;=&quot;</span> * ((<span class="number">6</span> - remainder) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_decode</span>(<span class="params">code, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(code, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> code[-<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>:    code = code[<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> code[-<span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>:  code = code[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line">    bin_code = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> code])</span><br><span class="line">    text = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_code) // <span class="number">8</span>):</span><br><span class="line">        text += <span class="built_in">chr</span>(<span class="built_in">int</span>(bin_code[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
        <category>常用知识点</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【WP】逆向-CrackMe</title>
    <url>/2020/12/15/CTF-RE-WP-CRACKME/</url>
    <content><![CDATA[<p><strong>CrackMe.exe  2020年12月15日</strong></p>
<ul>
<li>通过引导字符串确定关键函数；</li>
<li>常见的比较字符串相同的函数；</li>
<li>使用断点调试确定函数功能；</li>
<li>Base 64加密。</li>
</ul>
<a id="more"></a>

<h1 id="确定关键函数"><a href="#确定关键函数" class="headerlink" title="确定关键函数"></a>确定关键函数</h1><p>在IDA中打开CrackMe.exe文件，进入反编译窗口，可以看到主函数：</p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215192616383.png" alt="image-20201215192616383"></p>
<p>主函数中有</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">puts(<span class="string">&quot;input your flag:&quot;</span>)<span class="comment">;</span></span><br><span class="line">scanf(<span class="string">&quot;%s&quot;</span>, <span class="symbol">&amp;v5</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>非常明显的标志，因此可以看出<code>sub_4020A0()</code>函数没有实际用途，并且<code>v5</code>是输入的字符串。</p>
<p>此外，进入函数<code>sub_401540(&amp;v6, &quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;)</code>，可以看到：</p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215192952032.png" alt="image-20201215192952032"></p>
<p>下面的语句是<strong>常见的比较两个字符串是相同的</strong>函数。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">if</span> ( *<span class="built_in">a1</span> == *<span class="built_in">a2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">v3</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span> ( len != ++<span class="built_in">v3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">if</span> ( <span class="built_in">a1</span>[<span class="built_in">v3</span>] != <span class="built_in">a2</span>[<span class="built_in">v3</span>] )</span><br><span class="line">        return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return puts(<span class="string">&quot;you win!!&quot;</span>)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>因此， 我们可以初步得出程序的结构，即</p>
<p><strong>程序输入一个字符串<code>v5</code>后，通过函数<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>得到一个字符串<code>v6</code>，如果该字符串为<code>&quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;</code>,则说明该字符串为最后的flag。</strong></p>
<p>因此，我们需要重点关注<code>sub_401500(aAbcdefghijklmn)</code>和<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>函数。</p>
<h1 id="函数逆向"><a href="#函数逆向" class="headerlink" title="函数逆向"></a>函数逆向</h1><h2 id="sub-401500-aAbcdefghijklmn"><a href="#sub-401500-aAbcdefghijklmn" class="headerlink" title="sub_401500(aAbcdefghijklmn)"></a><code>sub_401500(aAbcdefghijklmn)</code></h2><p>通过IDA可以看到：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">.data:<span class="number">00403040</span> aAbcdefghijklmn db &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz<span class="number">0123456789</span>+/&#x27;,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>变量<code>aAbcdefghijklmn</code>是一个字符串。该函数如下：</p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215194438600.png" alt="image-20201215194438600"></p>
<p>该函数对传入的数组进行了一些修改。<strong>由于我们传入的是一个已知的字符串变量，因此我们可以利用调试查出执行该函数后的变量值</strong>。</p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215194802943.png" alt="image-20201215194802943"></p>
<p>从这里可以看出，修改后的变量为</p>
<p><code>ghijklmnopqrstuvxxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef</code></p>
<h2 id="sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4"><a href="#sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4" class="headerlink" title="sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)"></a><code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code></h2><p><strong>如果对Base 64编码比较熟悉的话， 从上一个函数得到的字符串来看，包括A-Z、a-z、0-9以及+和/，很容易想到这可能是一个Base 64的换表加密。再加上一些比较明显的标记，例如</strong></p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215195712853.png" alt="image-20201215195712853"></p>
<p><strong>和</strong></p>
<p><img src="/2020/12/15/CTF-RE-WP-CRACKME/image-20201215195755086.png" alt="image-20201215195755086"></p>
<p><strong>应该可以确定该函数就是一个换表Base 64加密</strong>。</p>
<p>我们可以利用将最后一个函数的比较字符串通过换表Base 64函数还原到原字符串来确定我们猜测的正确性。</p>
<p>经过换表Base 64的反编码，我们得到了字符串</p>
<p><code>flag&#123;th1s_1s_base64_exc1ange!&#125;</code></p>
<p>我们能够断定我们的猜测是正确的。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Reverse_逆向</category>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配——KMP算法</title>
    <url>/2020/12/19/KMP/</url>
    <content><![CDATA[<p><strong>KMP算法是由Knuth、Morris和Pratt三人设计的线性时间字符串匹配算法。该算法通过预先计算辅助函数$\pi$使匹配时间减少一个因子$n$，总的复杂度为$O(N)$。</strong></p>
<p>参考《算法导论》。</p>
<a id="more"></a>

<h1 id="模式的前缀函数-pi"><a href="#模式的前缀函数-pi" class="headerlink" title="模式的前缀函数 $\pi$"></a>模式的前缀函数 $\pi$</h1><h2 id="什么是前缀函数-pi"><a href="#什么是前缀函数-pi" class="headerlink" title="什么是前缀函数 $\pi$"></a>什么是前缀函数 $\pi$</h2><p>首先考虑朴素的字符串匹配算法的操作过程。</p>
<p>假设文本$T$和模式$P=ababaca$.在下面这个情况下，模式$P$的前5个字符已经匹配成功，但是在匹配第6个字符时失败了。对于朴素的字符串匹配算法来说，下一次匹配将尝试匹配$P[1]$和$T[4]$。</p>
<img src="/2020/12/19/KMP/image-20201219201107723.png" alt="image-20201219201229846" style="zoom:80%;">

<p>但是，在该实例里面，利用我们已知的信息（即模式串$P$和文本串$T[1…7]$），我们可以知道，将$P[1]$和$T[4]$进行匹配一定是失败的，因为在这个偏移量下，<strong>在重新匹配到$T[8]$位置前就会发生失败</strong>。此外，我们还可以看出来，下一个可能的匹配过程出现在将$P$右移两个单位处，因为<strong>如果将模式串向右移动两个距离，直到匹配到$T[7]$，该位置之前的模式字串依然是匹配的</strong>。</p>
<img src="/2020/12/19/KMP/image-20201219201605890.png" alt="image-20201219201605890" style="zoom:80%;">

<p>从上面的例子抽象出我们的目的，<strong>在朴素字符串匹配过程中，当我们检测到偏移量$s$是无效的时，我们忽略了检测无效$s$时所获得的信息（即当前匹配位置前的字串）。因此，如果我们能够有效地利用我们已知的信息，计算出可能匹配成功的偏移量，我们就能提高匹配的效率。</strong>这种情况下，我们无需让文本$T$上的指针向前移动，而是可以继续匹配当前位置上的字符（因为我们可以确定之前的位置都是匹配的）。</p>
<p>因此，我们的目的是，对于模式的每一个位置，我们都可以知道<strong>在该位置如果出现不匹配之后，需要将$P$向右移动多少各单位，保证该位置前的模式字串依然是匹配的</strong>，这就是前缀函数$\pi$的目的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设文本是一个长度为$n$的数组$T[1…n]$，而模式是一个长度为$m$的数组$P[1…m]$。则一般地来说，我们希望知道</p>
<p><strong>如果$P[q]$和$T[s+q]$是最后一个匹配的位置（即$P[1…q]=T[s+1…s+q]，P[q+1]\neq T[s+q+1]$），那么满足</strong><br>$$<br>P[1…q-k]=T[s+1+k…s+q]<br>$$<br><strong>的最小的偏移量$k$是多少。</strong></p>
<p>换句话说，**我们希望知道 $P[1…q]$的是$P[1…q]$的真后缀的最长真前缀 **。</p>
<img src="/2020/12/19/KMP/image-20201219203554704.png" alt="image-20201219203554704" style="zoom:80%;">

<p>而<strong>前缀函数$\pi$并不直接定义为上面的$k$ 。</strong>其形式化定义为<br>$$<br>\pi [q]=max(k:0\leq k&lt;q且P[1…k]是P[1…q]的后缀)<br>$$<br>也就是说，如果可以找到前述的最小偏移量$k$，那么<br>$$<br>\pi [q]=q-k<br>$$<br>否则<br>$$<br>\pi [q]=0<br>$$</p>
<p>即<strong>在$P[q+1]$的位置匹配失败了（即$P[1…q]$和$T[s+1…s+q]$是最后一个匹配的位置）后，如果位置$q$的前缀函数不为0，那么可以在不移动文本$T$的指针的情况下将模式$P$的指针移动到$P[\pi[q]]=P[q-k]$继续尝试匹配</strong>。</p>
<p>例如对于模式串$P=ababaca$，其前缀函数为</p>
<img src="/2020/12/19/KMP/image-20201219204344861.png" alt="image-20201219204344861" style="zoom: 80%;">

<p>即</p>
<img src="/2020/12/19/KMP/image-20201219210301510.png" alt="image-20201219210301510" style="zoom:80%;">

<h1 id="如何利用前缀函数-pi-进行字符串匹配"><a href="#如何利用前缀函数-pi-进行字符串匹配" class="headerlink" title="如何利用前缀函数 $\pi$ 进行字符串匹配"></a>如何利用前缀函数 $\pi$ 进行字符串匹配</h1><p>利用前缀函数$\pi$进行字符串匹配的KMP算法的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KMP-MATCHER(T, P):</span><br><span class="line">	n = T.length()</span><br><span class="line">	m = P.length()</span><br><span class="line">	PI[<span class="number">1.</span>..m] <span class="keyword">is</span> prefix function.</span><br><span class="line">	</span><br><span class="line">	matched_num = <span class="number">0</span>	<span class="comment">#number of characters matched.</span></span><br><span class="line">	<span class="keyword">for</span> (t_ptr=<span class="number">1</span> to n):</span><br><span class="line">		<span class="keyword">while</span> (P[matched_num + <span class="number">1</span>] != T[t_ptr] <span class="keyword">and</span> matched_num &gt; <span class="number">0</span>):</span><br><span class="line">            matched_num = PI[matched_num]</span><br><span class="line">        <span class="keyword">if</span> (P[matched_num + <span class="number">1</span>] == T[t_ptr]):</span><br><span class="line">           	matched_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (matched_num == m):</span><br><span class="line">            <span class="string">&#x27;MATCH_SUCCESSFULLY&#x27;</span></span><br><span class="line">        	matched_num = PI[matched_num]	<span class="comment">#Next mathch.      </span></span><br></pre></td></tr></table></figure>

<p>该算法中，<code>t_ptr</code>是文本$T$的指针，<code>matched_num</code>是当前已经匹配的字串长度。在每层循环中，如果该位置匹配失败，则利用前缀函数寻找下一个可能的匹配位置，不断重复直到已匹配字串为空或者该位置匹配成功。</p>
<p>以$T=ababababaca，P=ababaca$为例的KMP匹配过程如下。 </p>
<img src="/2020/12/19/KMP/image-20201220000604237.png" alt="image-20201220000911132" style="zoom: 67%;">

<h1 id="如何计算前缀函数-pi"><a href="#如何计算前缀函数-pi" class="headerlink" title="如何计算前缀函数 $\pi$"></a>如何计算前缀函数 $\pi$</h1><p>实际上计算前缀函数的过程类似于模式串和自身进行匹配的过程，因此他和KMP算法的形式非常类似。计算前缀函数的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION(P):</span><br><span class="line">    let PI[<span class="number">1.</span>..m] be a new array.</span><br><span class="line">    PI[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span> to m):</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> <span class="keyword">and</span> P[k+<span class="number">1</span>] != P[q]):</span><br><span class="line">            k = PI[k]	<span class="comment">#如果当前位置不匹配，利用已经计算出的PI函数进行偏移，以寻找下一个可能的匹配。</span></span><br><span class="line">        <span class="keyword">if</span> (P[k+<span class="number">1</span>] == P[i])</span><br><span class="line">        	k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时，如果P[k+1] == P[q]，则k为模式与自身在该位置之前的最大匹配串长度 + 1</span></span><br><span class="line">        <span class="comment"># 否则，k=0，表示该位置前没有可以匹配的字串</span></span><br><span class="line">      	PI[i] = k</span><br></pre></td></tr></table></figure>

<p>以$P=ababaca$为例的前缀函数计算过程如下。 </p>
<img src="/2020/12/19/KMP/image-20201220002442115.png" alt="image-20201220002442115" style="zoom:80%;">

<img src="/2020/12/19/KMP/image-20201220002709819.png" alt="image-20201220002709819" style="zoom:80%;">

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><code>Kmp.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> pat;</span><br><span class="line">	<span class="keyword">int</span>* prefix_func;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !KMP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Kmp.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KMP.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kmp::Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat)</span><br><span class="line">&#123;</span><br><span class="line">	pat = <span class="string">&quot; &quot;</span> + _Pat;	<span class="comment">// Start at pat[1]</span></span><br><span class="line">	<span class="keyword">int</span> m = _Pat.size();</span><br><span class="line">	prefix_func = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];	<span class="comment">//Start at prefix_func[1]</span></span><br><span class="line">	prefix_func[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; pat[matched + <span class="number">1</span>] != pat[i])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (pat[matched + <span class="number">1</span>] == pat[i])</span><br><span class="line">			matched++;</span><br><span class="line">		prefix_func[i] = matched;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kmp::search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = _Text.size();</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = _Start; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; _Text[i] != pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (_Text[i] == pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched++;</span><br><span class="line">		<span class="keyword">if</span> (matched == pat.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - (pat.size() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span>(<span class="params">text, pat, start = <span class="number">0</span>, end = -<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">isinstance</span>(text, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(pat, <span class="built_in">str</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError</span><br><span class="line">    n, m = <span class="built_in">len</span>(text), <span class="built_in">len</span>(pat)</span><br><span class="line">    pat = <span class="string">&quot; &quot;</span> + pat     <span class="comment">#Start at 1</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    prefix_func = [<span class="number">0</span>] * (m + <span class="number">1</span>)     <span class="comment">#Start at 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">and</span> pat[k + <span class="number">1</span>] != pat[i]):</span><br><span class="line">            k = prefix_func[k]</span><br><span class="line">        <span class="keyword">if</span> pat[k + <span class="number">1</span>] == pat[i]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        prefix_func[i] = k</span><br><span class="line"></span><br><span class="line">    matched, ind = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text[start:end]:</span><br><span class="line">        <span class="keyword">if</span> (matched <span class="keyword">and</span> pat[matched + <span class="number">1</span>] != i):</span><br><span class="line">            matched = prefix_func[matched]</span><br><span class="line">        <span class="keyword">if</span> pat[matched + <span class="number">1</span>] ==i:</span><br><span class="line">            matched += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matched == m:</span><br><span class="line">            <span class="keyword">return</span> start + ind - m + <span class="number">1</span></span><br><span class="line">        ind += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串的特征向量-next-i"><a href="#字符串的特征向量-next-i" class="headerlink" title="字符串的特征向量 $next[i]$"></a>字符串的特征向量 $next[i]$</h1><p>《数据结构与算法》在讲到KMP算法时没有使用前缀函数$\pi$，而是字符串的特征向量 $next[i]$。使用特征向量在理解上要困难与前缀函数，但<strong>使用字符串的特征向量遵守了在绝大多数编程语言中，数组（包括字符串）下标从0开始的约定，并且减少了不匹配情况出现时的循环次数</strong>，使得在实际实现时更方便一些。</p>
<h2 id="优化前的特征向量"><a href="#优化前的特征向量" class="headerlink" title="优化前的特征向量"></a>优化前的特征向量</h2><p>字符串的特征向量定义为<br>$$<br>next[i]=<br>\begin{cases}<br>-1,如果i=0,\<br>max(k:0&lt;k&lt;i并且P[0…k-1]=P[i-k…i-1]),如果k存在,\<br>0,otherwise.<br>\end{cases}<br>$$</p>
<p>和前缀函数进行比较，<strong>在含义上，除了$next[0]$之外，$next[i]$表示如果在位置$i$处匹配失败，则应该将模式$P$上的指针移动到哪一个位置（的下标）</strong>。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和前缀函数为</p>
<img src="/2020/12/19/KMP/image-20201220103510586.png" alt="image-20201220103510586" style="zoom:80%;">

<h2 id="特征向量的优化"><a href="#特征向量的优化" class="headerlink" title="特征向量的优化"></a>特征向量的优化</h2><p>假设求出的$next[i]=k$，当匹配时发现$P[i] \neq T[j]$，按照特征向量的定义，需要把模式向右移动$i-k$位，即用$P[k]$与$T[j]$进行比较。<strong>如果$P[i]=P[k]$，则$T[j] \neq P[k]$。</strong></p>
<p>因此，在按照上面的步骤计算出特征向量之后，再遍历一次特征向量，不断比较$P[i]$和$P[next[i]]$，如果$P[i]=P[next[i]]$，则令$next[i]=next[next[i]]$，直到$P[i] \neq P[next[i]]$或者$next[i]=-1$。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和优化后的特征向量为</p>
<img src="/2020/12/19/KMP/image-20201220105721483.png" alt="image-20201220105721483" style="zoom:80%;">]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
