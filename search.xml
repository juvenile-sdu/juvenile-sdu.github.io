<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDA调试方法与常见技巧</title>
    <url>/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li>使用IDA Remote Windows Debugger进行调试；</li>
<li>断点。</li>
</ul>
<a id="more"></a>

<h1 id="如何使用IDA进行调试"><a href="#如何使用IDA进行调试" class="headerlink" title="如何使用IDA进行调试"></a>如何使用IDA进行调试</h1><p>在Windows系统上使用IDA调试，需要用到两个文件<code>win32_remote.exe</code>和<code>win64_remote.exe</code>（在文件夹<code>\IDA 7.0\dbgsrv</code>中）:</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213183001919.png" alt="image-20201213183001919" style="zoom: 80%;">

<p>这两个文件分别对应32位的IDA和64位的IDA，<strong>在调试过程中，IDA和remote文件需要对应</strong>。</p>
<p>（以64位为例）首先打开remote文件（之后将其最小化即可）：</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213185817136.png" alt="image-20201213185817136" style="zoom: 67%;">

<p>在IDA界面选择<code>Remote Windows debugger</code>，</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190129549.png" alt="image-20201213190129549" style="zoom:80%;">

<p>点击左侧绿色的箭头开始调试。在第一次调试时可能会出现下面的错误：</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190615181.png" alt="image-20201213190615181" style="zoom:80%;">

<p>不断点确定，会出现一个setup窗口。其中<code>Application</code>和<code>Input File</code>均填写待调试文件的<strong>绝对路径</strong>，<code>Directory</code>填写待调试文件所在的文件夹，<code>Hostname</code>填写<code>127.0.0.1</code>表示当前主机。</p>
<p><strong>为了防止之后每次调试都设置一遍，可以将<code>Save network settings as default</code>选中，保存网络设置。</strong>完整的填写示例如下：</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190544390.png" alt="image-20201213190544390"></p>
<p>之后即可正常出现调试界面。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190816616.png" alt="image-20201213190816616"></p>
<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>在反编译模式（F5）下，可以点击代码左侧的蓝色按钮设置（多个）断点，如下：</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191034981.png" alt="image-20201213191034981"></p>
<p>之后，进入调试，可以看到，程序在执行到断点的位置后会停止。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191147562.png" alt="image-20201213191147562"></p>
<p>此时，可以将鼠标悬停到某个变量实时预览变量的值，也可以进行其他工作。</p>
<p>在菜单<code>debuger</code>处可以执行各种和调试有关的操作（例如继续执行、结束调试等等）。<strong>通常在界面上方的工具栏也有这些选项</strong>。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191329335.png" alt="image-20201213191329335"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数参数的提供和接收方式</title>
    <url>/2020/12/21/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%8F%90%E4%BE%9B%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>本文包括Python函数参数的提供和接收方式。</strong></p>
<p>包括位置参数、关键字参数和默认值、参数收集等。</p>
<a id="more"></a>

<h1 id="各种参数提供和接收方式的介绍"><a href="#各种参数提供和接收方式的介绍" class="headerlink" title="各种参数提供和接收方式的介绍"></a>各种参数提供和接收方式的介绍</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>最常见的Python参数的提供和接收方式是使用<strong>位置参数</strong>，使用方法和绝大多数其他编程语言（如C++）相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c, d</span>):</span></span><br><span class="line">    print(a, b, c, d)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>随着程序规模的扩大，记住各个函数的参数的位置会更加困难。因此Python引入了<strong>关键字参数</strong>，将<strong>参数名称</strong>作为判断依据（而不是位置参数中的参数的位置）。</p>
<p>和位置参数相比，定义使用关键字参数的函数并不需要对原函数进行任何修改，向函数传递形参时，需要使用类似于赋值语句的形式将值显式地交给某个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c, d</span>):</span></span><br><span class="line">    print(a, b, c, d)</span><br><span class="line"></span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">func(a=<span class="number">1</span>, c=<span class="number">2</span>, b=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="number">3</span>, c=<span class="number">4</span>)</span><br><span class="line">func(d=<span class="number">1</span>, c=<span class="number">2</span>, b=<span class="number">3</span>, a=<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在使用关键字参数的情况下，参数的顺序就无关轻重了。Python将根据参数名称进行匹配赋值（即使顺序和定义函数时的顺序不一致）。</strong></p>
<h2 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h2><p>在C++语言中，有默认值参数。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">int</span>* beg, <span class="keyword">int</span>* ed, <span class="keyword">unsigned</span> <span class="keyword">int</span> gap = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* i = beg; i != ed; i += gap)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Python中，也有同样的用法，即<strong>默认值参数</strong>。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabin_miller</span>(<span class="params">num, s=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Choose s random numbers ranging from 1 to (num - 1) to test WITNESS.&quot;&quot;&quot;</span></span><br><span class="line">    t, u = <span class="number">0</span>, num - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> u % <span class="number">2</span> == <span class="number">0</span>:  t, u = t + <span class="number">1</span>, u // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">        a = random.randrange(<span class="number">1</span>, num)</span><br><span class="line">        au1, au2 = <span class="number">0</span>, <span class="built_in">pow</span>(a, u, num)</span><br><span class="line">        <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">            au1, au2 = au2, <span class="built_in">pow</span>(au2, <span class="number">2</span>, num)</span><br><span class="line">            <span class="keyword">if</span> au2 == <span class="number">1</span> <span class="keyword">and</span> au1 != <span class="number">1</span> <span class="keyword">and</span> au1 != num - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> au2 != <span class="number">1</span>:    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_encode</span>(<span class="params">text, lookup=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(text, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> text])</span><br><span class="line">    remainder = <span class="built_in">len</span>(bin_str) % <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        bin_str += <span class="string">&quot;0&quot;</span> * (<span class="number">6</span> - remainder)</span><br><span class="line">    bin_str += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    code = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_str) // <span class="number">6</span>):</span><br><span class="line">        code += lookup[<span class="built_in">int</span>(bin_str[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        code += <span class="string">&quot;=&quot;</span> * ((<span class="number">6</span> - remainder) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在定义了默认值参数后，<strong>如果调用该函数而跳过默认值参数（不论是位置参数还是关键字参数），则程序将使用该默认值。如果现实地传递了参数，将按照传入的参数为准</strong>。</p>
<p>实际上，Python很多内置函数就是使用了默认值参数，例如<code>range(start, stop[, step=1])</code>等。</p>
<p>在使用默认值参数时，有一个需要注意的地方，即<strong>默认值应该设置为不可变的量（例如字符串、整型、元组等），而不应该设置为可变的量（如列表、字典等）</strong>。</p>
<blockquote>
<p>在每个程序里，Python函数的默认值仅被声明一次。因此如果多次调用使用默认值参数的函数，并且函数内的操作会修改该（可变的）默认值，那么在下一次调用该函数时，该默认值将是修改后的值。</p>
<p>例如下面的python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">val, arr=[]</span>):</span></span><br><span class="line">    arr.append(val)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">2</span>)</span><br><span class="line">func(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>的运行结果是</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="分配和收集参数（-和-的使用）"><a href="#分配和收集参数（-和-的使用）" class="headerlink" title="分配和收集参数（*和**的使用）"></a>分配和收集参数（<code>*</code>和<code>**</code>的使用）</h2><h3 id="收集参数（对应函数形参）"><a href="#收集参数（对应函数形参）" class="headerlink" title="收集参数（对应函数形参）"></a>收集参数（对应函数形参）</h3><p>有时候，允许用户提供任意数量的参数很有用。（对于C++和其他编程语言来说，想实现这样的功能很困难，并且条件非常苛刻，但是）使用Python实现这样的功能并不困难。</p>
<p>函数<strong>形参上的（在这里需要严格区分形参和实参）</strong><code>*</code>和<code>**</code>用于<strong>将任意多个传入的形参进行封装</strong>。</p>
<p><strong>对于一个星号<code>*</code>来说，其用于收集位置参数，将所有值都放在一个元组中，也就是说将这些值收集起来。如果没有可供收集的参数，该参数将会是一个空元组（也就是说无论如何该位置都是一个储存着所有传递给它的参数的元组）。</strong></p>
<p><strong>对于两个星号<code>**</code>来说，其用于收集关键字参数，将所有的关键字实参<code>name=val</code>按照<code>&#123;str(name): val&#125;</code>的形式放入一个字典中。同样的，如果没有可供收集的参数，该参数将是一个空字典。</strong></p>
<p><code>*</code>和<code>**</code>是有区别并且严格区分的。也就是说，**<code>**</code>不能用来收集位置参数，而<code>*</code>不能用来收集关键字参数**。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params</span>(<span class="params">*argv, **argd</span>):</span></span><br><span class="line">    print(argv)</span><br><span class="line">    print(argd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">4</span>, b=<span class="number">5</span>, e=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1, 2, 3)</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分配参数（对应函数实参）"><a href="#分配参数（对应函数实参）" class="headerlink" title="分配参数（对应函数实参）"></a>分配参数（对应函数实参）</h3><p>前面介绍的是如何将参数收集到元组和字典中。同样的两个运算符也可以执行相反的操作。</p>
<p><strong>一个星号<code>*</code>用于将可迭代序列解包，并形成位置参数。两个星号<code>**</code>用于将字典解包，并形成关键字参数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%d + %d + %d = %d.&quot;</span> % (a, b, c, a + b + c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(*(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">add(*[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">add(**&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">9</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>+ <span class="number">3</span> + <span class="number">5</span> = <span class="number">9</span>.</span><br><span class="line"><span class="symbol">3 </span>+ <span class="number">4</span> + <span class="number">5</span> = <span class="number">12</span>.</span><br><span class="line"><span class="symbol">3 </span>+ <span class="number">2</span> + <span class="number">9</span> = <span class="number">14</span>.</span><br></pre></td></tr></table></figure>



<h1 id="同时使用多种参数"><a href="#同时使用多种参数" class="headerlink" title="同时使用多种参数"></a>同时使用多种参数</h1><h2 id="混用原则"><a href="#混用原则" class="headerlink" title="混用原则"></a>混用原则</h2><p><strong>不论同时使用哪几种参数，首先要满足的一点是，函数的每个（非默认值）实参都需要被赋值，并且实参最多能被显式赋值一次。</strong></p>
<blockquote>
<p>下面的函数调用都是错误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c=<span class="number">2</span></span>):</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">1</span>)        	<span class="comment">#b没有被赋值</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">3</span>)     	<span class="comment">#a被重复赋值</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, c=<span class="number">3</span>)		<span class="comment">#c被重复赋值（形参中c=2不属于显式赋值）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>如果一个函数中仅有位置参数和关键字参数，则关键字参数必须在位置参数之后</strong>。</p>
<blockquote>
<p>如果关键字参数在位置参数之前，Python在遇到关键字参数后的位置参数时无法解释是跳过关键字参数还是对关键字参数进行了多次重复赋值。</p>
</blockquote>
<p><strong>如果在函数形参中有<code>*</code>，并且星号之后有其他的参数，则后面的参数只能使用关键字参数</strong>。</p>
<blockquote>
<p>由于<code>*</code>具有贪心的性质（即吸收直到无法继续吸收），因此只能使用关键字参数防止被星号吸收。</p>
</blockquote>
<p><strong>如果在一个函数形参中同时使用<code>**</code>，则<code>**</code>必须放在所有参数的最后一个，即<code>**</code>之后不能再有任何位置参数或关键字参数</strong>。</p>
<blockquote>
<p><code>**</code>之后不能有位置参数，否则将会与“关键字参数必须在位置参数之后”这一原则相矛盾。</p>
<p>由于<code>**</code>有贪心的性质（即吸收直到无法继续吸收）。因此即使其后面又有关键字参数，也无法被赋值。因此Python规定了这样的操作是非法的。</p>
</blockquote>
<p>如果将所有类型的参数都混合在一起，他们的形式一定为</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">(位置参数, 带默认值的关键字参数, *元组参数收集, （带默认值的）关键字参数, **字典参数收集)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c=<span class="number">3</span>, *argv, e=<span class="number">3</span>, f=<span class="number">3</span>, g, **argd</span>):</span></span><br><span class="line">    print(a, b, c, argv, e, f, g, argd, sep= <span class="string">&#x27; # &#x27;</span>)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, g=<span class="number">3</span>)  <span class="comment">#g的关键字赋值必不可少，然而e和f可以使用默认值</span></span><br><span class="line">func(<span class="number">19</span>, <span class="number">54</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, g=<span class="number">10</span>, h=<span class="number">2</span>, i=<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span># <span class="number">2</span> # <span class="number">3</span> # (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) # <span class="number">3</span> # <span class="number">3</span> # <span class="number">3</span> # &#123;&#125;</span><br><span class="line"><span class="symbol">19 </span># <span class="number">54</span> # [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>] # (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) # <span class="number">3</span> # <span class="number">3</span> # <span class="number">10</span> # &#123;<span class="comment">&#x27;h&#x27;: 2, &#x27;i&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>PYTHON</category>
        <category>OTHERS</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
        <tag>OTHERS</tag>
      </tags>
  </entry>
  <entry>
    <title>【WP】逆向-CrackMe</title>
    <url>/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/</url>
    <content><![CDATA[<p><strong>CrackMe.exe  2020年12月15日</strong></p>
<ul>
<li>通过引导字符串确定关键函数；</li>
<li>常见的比较字符串相同的函数；</li>
<li>使用断点调试确定函数功能；</li>
<li>Base 64加密。</li>
</ul>
<a id="more"></a>

<h1 id="确定关键函数"><a href="#确定关键函数" class="headerlink" title="确定关键函数"></a>确定关键函数</h1><p>在IDA中打开CrackMe.exe文件，进入反编译窗口，可以看到主函数：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215192616383.png" alt="image-20201215192616383"></p>
<p>主函数中有</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">puts(<span class="string">&quot;input your flag:&quot;</span>)<span class="comment">;</span></span><br><span class="line">scanf(<span class="string">&quot;%s&quot;</span>, <span class="symbol">&amp;v5</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>非常明显的标志，因此可以看出<code>sub_4020A0()</code>函数没有实际用途，并且<code>v5</code>是输入的字符串。</p>
<p>此外，进入函数<code>sub_401540(&amp;v6, &quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;)</code>，可以看到：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215192952032.png" alt="image-20201215192952032"></p>
<p>下面的语句是<strong>常见的比较两个字符串是相同的</strong>函数。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">if</span> ( *<span class="built_in">a1</span> == *<span class="built_in">a2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">v3</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span> ( len != ++<span class="built_in">v3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">if</span> ( <span class="built_in">a1</span>[<span class="built_in">v3</span>] != <span class="built_in">a2</span>[<span class="built_in">v3</span>] )</span><br><span class="line">        return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return puts(<span class="string">&quot;you win!!&quot;</span>)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>因此， 我们可以初步得出程序的结构，即</p>
<p><strong>程序输入一个字符串<code>v5</code>后，通过函数<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>得到一个字符串<code>v6</code>，如果该字符串为<code>&quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;</code>,则说明该字符串为最后的flag。</strong></p>
<p>因此，我们需要重点关注<code>sub_401500(aAbcdefghijklmn)</code>和<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>函数。</p>
<h1 id="函数逆向"><a href="#函数逆向" class="headerlink" title="函数逆向"></a>函数逆向</h1><h2 id="sub-401500-aAbcdefghijklmn"><a href="#sub-401500-aAbcdefghijklmn" class="headerlink" title="sub_401500(aAbcdefghijklmn)"></a><code>sub_401500(aAbcdefghijklmn)</code></h2><p>通过IDA可以看到：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">.data:<span class="number">00403040</span> aAbcdefghijklmn db &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz<span class="number">0123456789</span>+/&#x27;,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>变量<code>aAbcdefghijklmn</code>是一个字符串。该函数如下：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215194438600.png" alt="image-20201215194438600"></p>
<p>该函数对传入的数组进行了一些修改。<strong>由于我们传入的是一个已知的字符串变量，因此我们可以利用调试查出执行该函数后的变量值</strong>。</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215194802943.png" alt="image-20201215194802943"></p>
<p>从这里可以看出，修改后的变量为</p>
<p><code>ghijklmnopqrstuvxxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef</code></p>
<h2 id="sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4"><a href="#sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4" class="headerlink" title="sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)"></a><code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code></h2><p><strong>如果对Base 64编码比较熟悉的话， 从上一个函数得到的字符串来看，包括A-Z、a-z、0-9以及+和/，很容易想到这可能是一个Base 64的换表加密。再加上一些比较明显的标记，例如</strong></p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215195712853.png" alt="image-20201215195712853"></p>
<p><strong>和</strong></p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215195755086.png" alt="image-20201215195755086"></p>
<p><strong>应该可以确定该函数就是一个换表Base 64加密</strong>。</p>
<p>我们可以利用将最后一个函数的比较字符串通过换表Base 64函数还原到原字符串来确定我们猜测的正确性。</p>
<p>经过换表Base 64的反编码，我们得到了字符串</p>
<p><code>flag&#123;th1s_1s_base64_exc1ange!&#125;</code></p>
<p>我们能够断定我们的猜测是正确的。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的周游</title>
    <url>/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/</url>
    <content><![CDATA[<p><strong>二叉树的周游包括深度优先遍历（包括前序遍历、中序遍历和后序遍历）以及广度优先遍历。</strong></p>
<a id="more"></a>

<p>本文假定二叉树的数据类型如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br></pre></td></tr></table></figure>

<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p><strong>深度优先遍历包括前序遍历、中序遍历和后续遍历。</strong></p>
<h2 id="前序遍历（pre-order-traversal）"><a href="#前序遍历（pre-order-traversal）" class="headerlink" title="前序遍历（pre-order traversal）"></a>前序遍历（pre-order traversal）</h2><p><strong>前序遍历的递归定义为：</strong></p>
<ul>
<li><strong>访问根节点</strong></li>
<li><strong>按照前序遍历左子树</strong></li>
<li><strong>按照前序遍历右子树</strong></li>
</ul>
<h3 id="根据二叉树实例写出前序遍历序列"><a href="#根据二叉树实例写出前序遍历序列" class="headerlink" title="根据二叉树实例写出前序遍历序列"></a>根据二叉树实例写出前序遍历序列</h3><p>根据二叉树写前序遍历序列时，最方便稳妥的方法时按照递归定义进行遍历。</p>
<p>例如，对于如下的二叉树</p>
<img src="/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/1.jpg" alt="1" style="zoom:50%;">

<p>按照根节点、左子树、右子树的方式遍历，可以得到：</p>
<p><code>8 [tree of node 3] [tree of node 10]</code></p>
<p>对两个子树进行递归遍历，有：</p>
<p><code>8 3 [tree of node 1] [tree of node 6] 10 [tree of node 14]</code></p>
<p>有：</p>
<p><code>8 3 1 6 [tree of node 4] [tree of node 7] 10 14 [tree of node 13]</code></p>
<p>最后有前序遍历序列：</p>
<p><code>8 3 1 6 4 7 10 14 13</code></p>
<h3 id="递归实现前序遍历"><a href="#递归实现前序遍历" class="headerlink" title="递归实现前序遍历"></a>递归实现前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		pre_traversal(tree-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		pre_traversal(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现前序遍历"><a href="#非递归实现前序遍历" class="headerlink" title="非递归实现前序遍历"></a>非递归实现前序遍历</h3><p>前序遍历可以使用栈<strong>完全模拟函数递归的过程</strong>。其方法为<strong>首先将根节点放入栈中完成初始化，之后当栈不为空时进入循环，从栈中弹出一个结点，将其输出，再将其右子结点、左子结点（如果有）按顺序放入栈中，完成本轮循环。</strong></p>
<p>如果将递归实现前序遍历的过程完全模拟一遍，会发现其过程和上述过程完全相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;Tree&gt; sta;</span><br><span class="line">	sta.push(tree);</span><br><span class="line">	<span class="keyword">while</span> (!sta.empty()) &#123;</span><br><span class="line">		Tree root = sta.top();</span><br><span class="line">		sta.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;right)		sta.push(root-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;left)		sta.push(root-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用前序遍历构建二叉树"><a href="#使用前序遍历构建二叉树" class="headerlink" title="使用前序遍历构建二叉树"></a>使用前序遍历构建二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(Tree father = <span class="literal">nullptr</span>, <span class="keyword">bool</span> isLeft = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!father)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of root node, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isLeft)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of the left node of node &quot;</span> &lt;&lt; father-&gt;data &lt;&lt; <span class="string">&quot;, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of the right node of node &quot;</span> &lt;&lt; father-&gt;data &lt;&lt; <span class="string">&quot;, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> ind;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ind;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ind == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	Tree root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">	root-&gt;data = ind;</span><br><span class="line">	root-&gt;left = createTree(root);</span><br><span class="line">	root-&gt;right = createTree(root, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中序遍历（in-order-traversal）"><a href="#中序遍历（in-order-traversal）" class="headerlink" title="中序遍历（in-order traversal）"></a>中序遍历（in-order traversal）</h2><p><strong>中序遍历的递归定义为：</strong></p>
<ul>
<li><strong>按照中序遍历左子树</strong></li>
<li><strong>访问根节点</strong></li>
<li><strong>按照中序遍历右子树</strong></li>
</ul>
<h3 id="根据二叉树实例写出中序遍历序列"><a href="#根据二叉树实例写出中序遍历序列" class="headerlink" title="根据二叉树实例写出中序遍历序列"></a>根据二叉树实例写出中序遍历序列</h3><p>方法和前序遍历序列的方法是一样的，最严谨的方法是按照递归定义进行遍历。</p>
<p>同样对于上面的二叉树，可以依次得到：</p>
<p><code>[tree of node 3] 8 [tree of node 10]</code></p>
<p><code>[tree of node 1] 3 [tree of node 6] 8 10 [tree of node 14]</code></p>
<p><code>1 3 [tree of node 4] 6 [tree of node 7] 8 10 [tree of node 13] 14</code></p>
<p>最后得到中序遍历序列为</p>
<p><code>1 3 4 6 7 8 10 13 14</code></p>
<h3 id="递归实现中序遍历"><a href="#递归实现中序遍历" class="headerlink" title="递归实现中序遍历"></a>递归实现中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		in_traversal(tree-&gt;left);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		in_traversal(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现中序遍历"><a href="#非递归实现中序遍历" class="headerlink" title="非递归实现中序遍历"></a>非递归实现中序遍历</h3><p>中序遍历无法完全利用栈模拟递归操作。为了非递归实现中序遍历，我们将递归实现中序遍历的操作分为两大部分。</p>
<ol>
<li><p><strong>第一部分</strong>包括<code>if (tree-&gt;left) in_traversal(tree-&gt;left);</code>，即访问其左子树。</p>
</li>
<li><p><strong>第二部分</strong>包括<code>cout &lt;&lt; tree-&gt;data &lt;&lt; &quot; &quot;;</code>和<code>if (tree-&gt;right) in_traversal(tree-&gt;right);</code>，即输出当前根节点并访问其右子树。</p>
</li>
</ol>
<p>将两部分区分开来之后，我们用得到当前结点的方法作为执行哪一种操作的依据。具体方法如下。</p>
<ul>
<li>如果当前结点（不为<code>nullptr</code>）是从其父节点访问得到的（则该该结点是第一次被访问），则执行第一部分的操作。并将当前（根）结点压入栈中。</li>
<li>如果当前结点为<code>nullptr</code>，则从栈中取出一个结点（此时该结点一定已经访问完其左子树），因此执行第二部分操作，即输出当前根节点，并将当前结点指向其右子结点。</li>
</ul>
<p>总结起来，<strong>我们使用获取结点的方式来判断其是首次访问还是已经访问结束其左子树后回溯到该结点的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;Tree&gt; sta;</span><br><span class="line">	Tree root = tree;</span><br><span class="line">	<span class="keyword">while</span> (root || !sta.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root) &#123;</span><br><span class="line">			sta.push(root);</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root = sta.top();</span><br><span class="line">			sta.pop();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="后序遍历（post-order-traversal）"><a href="#后序遍历（post-order-traversal）" class="headerlink" title="后序遍历（post-order traversal）"></a>后序遍历（post-order traversal）</h2><p><strong>后序遍历的递归定义为：</strong></p>
<ul>
<li><strong>按照后序遍历左子树</strong></li>
<li><strong>按照后序遍历右子树</strong></li>
<li><strong>访问根节点</strong></li>
</ul>
<h3 id="根据二叉树实例写出中序遍历序列-1"><a href="#根据二叉树实例写出中序遍历序列-1" class="headerlink" title="根据二叉树实例写出中序遍历序列"></a>根据二叉树实例写出中序遍历序列</h3><p>对于上面的二叉树，可以依次得到：</p>
<p><code>[tree of node 3] [tree of node 10] 8</code></p>
<p><code>[tree of node 1] [tree of node 6] 3 [tree of node 14] 10 8</code></p>
<p><code>1 [tree of node 4] [tree of node 7] 6 3 [tree of node 13] 14 10 8</code></p>
<p>最后得到后序遍历序列为</p>
<p><code>1 4 7 6 3 13 14 10 8</code></p>
<h3 id="递归实现后序遍历"><a href="#递归实现后序遍历" class="headerlink" title="递归实现后序遍历"></a>递归实现后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		post_traversal(tree-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		post_traversal(tree-&gt;right);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现后序遍历"><a href="#非递归实现后序遍历" class="headerlink" title="非递归实现后序遍历"></a>非递归实现后序遍历</h3><p>和中序遍历相似地，我们将递归后序遍历的过程分为三大部分。</p>
<ol>
<li><strong>第一部分</strong>包括<code>if (tree-&gt;left)        post_traversal(tree-&gt;left);</code>，即访问其左子结点。</li>
<li><strong>第二部分</strong>包括<code>if (tree-&gt;right)        post_traversal(tree-&gt;right);</code>，即访问其右子结点。</li>
<li><strong>第三部分</strong>包括<code>cout &lt;&lt; tree-&gt;data &lt;&lt; &quot; &quot;;</code>，即输出根节点。</li>
</ol>
<p>由于我们将整个过程分为三个部分，因此就无法仅利用获取结点的方式进行判断（执行哪一部分）。<strong>我们对每个结点引入一个布尔类型变量<code>isRight</code>，以判断该结点是否是访问完右子结点后入栈的</strong>。具体方法如下。</p>
<ul>
<li>如果当前结点（不为<code>nullptr</code> ）是从其父节点访问得到的，则为其引入一个<code>isRight</code>变量并置为<code>false</code>，将该结点和辅助变量一并放入栈中，并将当前结点设置为该结点的左子结点。</li>
<li>如果当前结点为<code>nullptr</code>，则从栈中取出一个结点。<ul>
<li>如果该结点的<code>isRight</code>变量为<code>false</code>，则将<code>isRight</code>置为<code>true</code>，并将该结点和辅助变量一并放入栈中，并将当前结点设置为该结点的右子结点。</li>
<li>如果该结点的<code>isRight</code>变量为<code>true</code>，则输出该结点，以该结点为根节点的子树访问结束，<strong>因此要将当前结点更新为<code>nullptr</code>，以代表该结点没有其他任何子结点可以访问了</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;&gt; sta;</span><br><span class="line">	Tree root = tree;</span><br><span class="line">	<span class="keyword">while</span> (root || !sta.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root) &#123;</span><br><span class="line">			sta.push(<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;(root, <span class="literal">false</span>));</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root = sta.top().first;</span><br><span class="line">			<span class="keyword">bool</span> isRight = sta.top().second;</span><br><span class="line">			sta.pop();</span><br><span class="line">			<span class="keyword">if</span> (!isRight) &#123;</span><br><span class="line">				sta.push(<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;(root, <span class="literal">true</span>));</span><br><span class="line">				root = root-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				root = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="根据遍历序列恢复二叉树"><a href="#根据遍历序列恢复二叉树" class="headerlink" title="根据遍历序列恢复二叉树"></a>根据遍历序列恢复二叉树</h2><p>还是以该树为例。</p>
<img src="/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/1.jpg" alt="1" style="zoom:50%;">

<p>其前序、中序和后序遍历序列分别为：</p>
<p><strong>前序遍历序列：<code>8 3 1 6 4 7 10 14 13</code></strong></p>
<p><strong>中序遍历序列：<code>1 3 4 6 7 8 10 13 14</code></strong></p>
<p><strong>后序遍历序列：<code>1 4 7 6 3 13 14 10 8</code></strong></p>
<h3 id="前序遍历和中序遍历"><a href="#前序遍历和中序遍历" class="headerlink" title="前序遍历和中序遍历"></a>前序遍历和中序遍历</h3><p><strong>前序遍历可以方便地确定根节点，中序遍历可以方便地根据根节点确定左子树和右子树包括哪些结点。</strong></p>
<p>根据前序遍历第一个结点为<code>8</code>，可以得到：</p>
<p><code>root:8 [left-tree of 8: 1 3 4 6 7] [right-tree of 8: 10 13 14]</code></p>
<p>因为<code>[1 3 4 6 7 ] 8 [10 13 14]</code></p>
<p>对左右子树进行递归操作，可以依次得到：</p>
<p><code>8 root:3 [left-tree of 3: 1] [right-tree of 3: 4 6 7] root:10 [right-tree of 10: 13 14]</code></p>
<p>因为<code>[1] 3 [4 6 7] 8 10 [13 14]</code></p>
<p><code>8 3 1 root:6 [left-tree of 6: 4] [right-tree of 6: 7] 10 root:14 [left-tree of 14: 13]</code></p>
<p>因为<code>1 3 [4] 6 [7] 8 10 [13] 14</code></p>
<h3 id="前序遍历和后序遍历"><a href="#前序遍历和后序遍历" class="headerlink" title="前序遍历和后序遍历"></a>前序遍历和后序遍历</h3><p><strong>仅仅直到前序遍历和后序遍历有时候无法唯一确定树的确定形态（例如对于上面的二叉树来说，将13作为右子结点得到的前序遍历、后序遍历和原来完全相同）。</strong></p>
<p><strong>如果可以的话，前序遍历和后序遍历进行结合可以方便地确定某一个根节点的左右子结点分别是什么。</strong>对于某个序列（可能是子序列），如果将前序遍历的第一个结点作为根节点，则考虑其后面的第一个结点，并在后序遍历中找到该结点。则再后序遍历中该结点左侧的结点属于该子树，将这些结点再前序遍历序列中划分开来，则剩下的结点属于根节点的右子树。</p>
<p><strong>一次迭代</strong></p>
<p>前序遍历序列：<code>[root:8] [3 1 6 4 7] [10 14 13]</code></p>
<p>后序遍历序列：<code>[1 4 7 6 3] [13 14 10] [root:8]</code></p>
<p><strong>二次迭代</strong></p>
<p>前序遍历序列：<code>3 [1] [6 4 7]</code> <code>10 [14 13]</code></p>
<p>后序遍历序列：<code>[1] [4 7 6] 3</code> <code>[13 14] 10</code></p>
<p><strong>三次迭代</strong></p>
<p>前序遍历序列：<code>3</code> <code>1</code> <code>6 [4] [7]</code> <code>10</code> <code>14 13</code></p>
<p>后序遍历序列：<code>1</code>  <code>[4] [7] 6</code> <code>3</code> <code>13 14</code> <code>10</code></p>
<p>这里<code>14 13</code>无法继续判断，<strong>但我们已经从前序序列和后序序列得到了足够多的信息了。</strong></p>
<p><strong>进一步地，如果子结点的左右顺序无关，或者二叉树中要不是叶结点，要不是出度为2的结点的话，我们就可以根据前序遍历和后序遍历完全恢复出树的状态。</strong></p>
<h3 id="中序遍历和后序遍历"><a href="#中序遍历和后序遍历" class="headerlink" title="中序遍历和后序遍历"></a>中序遍历和后序遍历</h3><p>后序遍历和前序遍历有很多相似性。因此和利用前序遍历、中序遍历恢复二叉树的方法非常类似。</p>
<p>例如：</p>
<p>中序遍历序列：<code>[1 3 4 6 7] root:8 [10 13 14]</code></p>
<p>后序遍历序列：[]<code>1 4 7 6 3] [13 14 10] root:8</code></p>
<p>对剩余的序列进行递归即可。</p>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索一般使用队列进行模拟。其思路非常简单，不断从队列中取出结点，输出该结点信息，并将该结点的左右子节点放入队列中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Tree&gt; que;</span><br><span class="line">	que.push(tree);</span><br><span class="line">	<span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">		Tree root = que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;left)		que.push(root-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;right)		que.push(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>DATA STRUCTURE</category>
        <category>TREE &amp; GRAPH</category>
      </categories>
      <tags>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDA的技巧汇总</title>
    <url>/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>本文汇总了一些使用IDA调试的技巧。掌握这些技巧可以极大方便日常使用。</strong></p>
<a id="more"></a>

<h1 id="自定义类型和变量"><a href="#自定义类型和变量" class="headerlink" title="自定义类型和变量"></a>自定义类型和变量</h1><h2 id="修改变量标识符"><a href="#修改变量标识符" class="headerlink" title="修改变量标识符"></a>修改变量标识符</h2><p>例如在反汇编状态下有如下的一个函数：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213192949341.png" alt="image-20201213192949341"></p>
<p>可以看出以下的一些信息：</p>
<blockquote>
<p><code>a1</code>是函数形参，并且是一个<code>char</code>类型的数组；</p>
<p><code>v4</code>表示了数组<code>a1</code>的长度；</p>
</blockquote>
<p>因此，为了便于我们阅读，我们可以修改这些变量的标识符。<strong>其方法为将光标放在需要修改的变量上，右键，可以看到<code>Rename Ival</code>选项，单击该选项，（也可以直接使用快捷键<code>N</code>）即可以进行修改。</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213193630775.png" alt="image-20201213193630775"></p>
<p>下面是修改后的代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213193802256.png" alt="image-20201213193802256"></p>
<h2 id="修改变量类型"><a href="#修改变量类型" class="headerlink" title="修改变量类型"></a>修改变量类型</h2><p>再看下面的函数：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213194334019.png" alt="image-20201213194334019"></p>
<p>我们可以发现：<strong>虽然<code>v9</code>在这里是一个<code>long long </code>类型的变量，但是后续的使用全部将其看作<code>char</code>类型数组进行访问。</strong>因此我们有必要，也完全可以将其进行类型转换。**转换方法和前述相同，在右键菜单中选择<code>Set Ival type</code>，或者使用快捷键<code>y</code>**。下面是转换过后的函数代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213194911482.png" alt="image-20201213194911482"></p>
<p>可以看到，转换后的代码更加清晰明了。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>例如如下代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213195145545.png" alt="image-20201213195145545"></p>
<p>我们可以看到如下的信息：</p>
<blockquote>
<p><code>Dst</code>是一个16字节的变量，初始状态下为0。<code>v5</code>（一个指向内存大小为16个字节的指针）指向<code>Dst</code>的地址。在循环中，<code>v1</code>同样是一个16字节的变量，其前八个字节被定义为一个变量，值为<code>Str[i]</code>，后八个字节被设置为全0.而<code>v5</code>的后八个字节存储着<code>v1</code>的地址。之后<code>v5</code>更新为<code>v1</code>，在后续的循环中<code>v1</code>又重新声明内存。</p>
</blockquote>
<p>因此我们猜测这是一个添加链表元素的过程。因此我们可以在IDA中新建一个结构体，显式地定义List结构体。</p>
<p><strong>打开<code>View-Open subviews-Local types</code>窗口</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201115105.png" alt="image-20201213201115105"></p>
<p><strong>点<code>insert</code>，在新出现的窗口输入希望创建的结构体对应的C代码</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201441268.png" alt="image-20201213201441268"></p>
<p>之后，就可以将其看作正常的结构，使用上面的方法进行修改。</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201630912.png" alt="image-20201213201630912"></p>
<p>可以看到，在使用自定义结构体之后，整个函数就变得非常简洁明了。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配——KMP算法</title>
    <url>/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>KMP算法是由Knuth、Morris和Pratt三人设计的线性时间字符串匹配算法。该算法通过预先计算辅助函数$\pi$使匹配时间减少一个因子$n$，总的复杂度为$O(N)$。</strong></p>
<p>参考《算法导论》。</p>
<a id="more"></a>

<h1 id="模式的前缀函数-pi"><a href="#模式的前缀函数-pi" class="headerlink" title="模式的前缀函数 $\pi$"></a>模式的前缀函数 $\pi$</h1><h2 id="什么是前缀函数-pi"><a href="#什么是前缀函数-pi" class="headerlink" title="什么是前缀函数 $\pi$"></a>什么是前缀函数 $\pi$</h2><p>首先考虑朴素的字符串匹配算法的操作过程。</p>
<p>假设文本$T$和模式$P=ababaca$.在下面这个情况下，模式$P$的前5个字符已经匹配成功，但是在匹配第6个字符时失败了。对于朴素的字符串匹配算法来说，下一次匹配将尝试匹配$P[1]$和$T[4]$。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219201107723.png" alt="image-20201219201229846" style="zoom:80%;">

<p>但是，在该实例里面，利用我们已知的信息（即模式串$P$和文本串$T[1…7]$），我们可以知道，将$P[1]$和$T[4]$进行匹配一定是失败的，因为在这个偏移量下，<strong>在重新匹配到$T[8]$位置前就会发生失败</strong>。此外，我们还可以看出来，下一个可能的匹配过程出现在将$P$右移两个单位处，因为<strong>如果将模式串向右移动两个距离，直到匹配到$T[7]$，该位置之前的模式字串依然是匹配的</strong>。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219201605890.png" alt="image-20201219201605890" style="zoom:80%;">

<p>从上面的例子抽象出我们的目的，<strong>在朴素字符串匹配过程中，当我们检测到偏移量$s$是无效的时，我们忽略了检测无效$s$时所获得的信息（即当前匹配位置前的字串）。因此，如果我们能够有效地利用我们已知的信息，计算出可能匹配成功的偏移量，我们就能提高匹配的效率。</strong>这种情况下，我们无需让文本$T$上的指针向前移动，而是可以继续匹配当前位置上的字符（因为我们可以确定之前的位置都是匹配的）。</p>
<p>因此，我们的目的是，对于模式的每一个位置，我们都可以知道<strong>在该位置如果出现不匹配之后，需要将$P$向右移动多少各单位，保证该位置前的模式字串依然是匹配的</strong>，这就是前缀函数$\pi$的目的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设文本是一个长度为$n$的数组$T[1…n]$，而模式是一个长度为$m$的数组$P[1…m]$。则一般地来说，我们希望知道</p>
<p><strong>如果$P[q]$和$T[s+q]$是最后一个匹配的位置（即$P[1…q]=T[s+1…s+q]，P[q+1]\neq T[s+q+1]$），那么满足</strong><br>$$<br>P[1…q-k]=T[s+1+k…s+q]<br>$$<br><strong>的最小的偏移量$k$是多少。</strong></p>
<p>换句话说，**我们希望知道 $P[1…q]$的是$P[1…q]$的真后缀的最长真前缀 **。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219203554704.png" alt="image-20201219203554704" style="zoom:80%;">

<p>而<strong>前缀函数$\pi$并不直接定义为上面的$k$ 。</strong>其形式化定义为<br>$$<br>\pi [q]=max(k:0\leq k&lt;q且P[1…k]是P[1…q]的后缀)<br>$$<br>也就是说，如果可以找到前述的最小偏移量$k$，那么<br>$$<br>\pi [q]=q-k<br>$$<br>否则<br>$$<br>\pi [q]=0<br>$$</p>
<p>即<strong>在$P[q+1]$的位置匹配失败了（即$P[1…q]$和$T[s+1…s+q]$是最后一个匹配的位置）后，如果位置$q$的前缀函数不为0，那么可以在不移动文本$T$的指针的情况下将模式$P$的指针移动到$P[\pi[q]]=P[q-k]$继续尝试匹配</strong>。</p>
<p>例如对于模式串$P=ababaca$，其前缀函数为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219204344861.png" alt="image-20201219204344861" style="zoom: 80%;">

<p>即</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219210301510.png" alt="image-20201219210301510" style="zoom:80%;">

<h1 id="如何利用前缀函数-pi-进行字符串匹配"><a href="#如何利用前缀函数-pi-进行字符串匹配" class="headerlink" title="如何利用前缀函数 $\pi$ 进行字符串匹配"></a>如何利用前缀函数 $\pi$ 进行字符串匹配</h1><p>利用前缀函数$\pi$进行字符串匹配的KMP算法的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KMP-MATCHER(T, P):</span><br><span class="line">	n = T.length()</span><br><span class="line">	m = P.length()</span><br><span class="line">	PI[<span class="number">1.</span>..m] <span class="keyword">is</span> prefix function.</span><br><span class="line">	</span><br><span class="line">	matched_num = <span class="number">0</span>	<span class="comment">#number of characters matched.</span></span><br><span class="line">	<span class="keyword">for</span> (t_ptr=<span class="number">1</span> to n):</span><br><span class="line">		<span class="keyword">while</span> (P[matched_num + <span class="number">1</span>] != T[t_ptr] <span class="keyword">and</span> matched_num &gt; <span class="number">0</span>):</span><br><span class="line">            matched_num = PI[matched_num]</span><br><span class="line">        <span class="keyword">if</span> (P[matched_num + <span class="number">1</span>] == T[t_ptr]):</span><br><span class="line">           	matched_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (matched_num == m):</span><br><span class="line">            <span class="string">&#x27;MATCH_SUCCESSFULLY&#x27;</span></span><br><span class="line">        	matched_num = PI[matched_num]	<span class="comment">#Next mathch.      </span></span><br></pre></td></tr></table></figure>

<p>该算法中，<code>t_ptr</code>是文本$T$的指针，<code>matched_num</code>是当前已经匹配的字串长度。在每层循环中，如果该位置匹配失败，则利用前缀函数寻找下一个可能的匹配位置，不断重复直到已匹配字串为空或者该位置匹配成功。</p>
<p>以$T=ababababaca，P=ababaca$为例的KMP匹配过程如下。 </p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220000604237.png" alt="image-20201220000911132" style="zoom: 67%;">

<h1 id="如何计算前缀函数-pi"><a href="#如何计算前缀函数-pi" class="headerlink" title="如何计算前缀函数 $\pi$"></a>如何计算前缀函数 $\pi$</h1><p>实际上计算前缀函数的过程类似于模式串和自身进行匹配的过程，因此他和KMP算法的形式非常类似。计算前缀函数的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION(P):</span><br><span class="line">    let PI[<span class="number">1.</span>..m] be a new array.</span><br><span class="line">    PI[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span> to m):</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> <span class="keyword">and</span> P[k+<span class="number">1</span>] != P[q]):</span><br><span class="line">            k = PI[k]	<span class="comment">#如果当前位置不匹配，利用已经计算出的PI函数进行偏移，以寻找下一个可能的匹配。</span></span><br><span class="line">        <span class="keyword">if</span> (P[k+<span class="number">1</span>] == P[i])</span><br><span class="line">        	k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时，如果P[k+1] == P[q]，则k为模式与自身在该位置之前的最大匹配串长度 + 1</span></span><br><span class="line">        <span class="comment"># 否则，k=0，表示该位置前没有可以匹配的字串</span></span><br><span class="line">      	PI[i] = k</span><br></pre></td></tr></table></figure>

<p>以$P=ababaca$为例的前缀函数计算过程如下。 </p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220002442115.png" alt="image-20201220002442115" style="zoom:80%;">

<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220002709819.png" alt="image-20201220002709819" style="zoom:80%;">

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><code>Kmp.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> pat;</span><br><span class="line">	<span class="keyword">int</span>* prefix_func;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !KMP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Kmp.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KMP.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kmp::Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat)</span><br><span class="line">&#123;</span><br><span class="line">	pat = <span class="string">&quot; &quot;</span> + _Pat;	<span class="comment">// Start at pat[1]</span></span><br><span class="line">	<span class="keyword">int</span> m = _Pat.size();</span><br><span class="line">	prefix_func = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];	<span class="comment">//Start at prefix_func[1]</span></span><br><span class="line">	prefix_func[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; pat[matched + <span class="number">1</span>] != pat[i])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (pat[matched + <span class="number">1</span>] == pat[i])</span><br><span class="line">			matched++;</span><br><span class="line">		prefix_func[i] = matched;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kmp::search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = _Text.size();</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = _Start; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; _Text[i] != pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (_Text[i] == pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched++;</span><br><span class="line">		<span class="keyword">if</span> (matched == pat.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - (pat.size() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span>(<span class="params">text, pat, start = <span class="number">0</span>, end = -<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">isinstance</span>(text, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(pat, <span class="built_in">str</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError</span><br><span class="line">    n, m = <span class="built_in">len</span>(text), <span class="built_in">len</span>(pat)</span><br><span class="line">    pat = <span class="string">&quot; &quot;</span> + pat     <span class="comment">#Start at 1</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    prefix_func = [<span class="number">0</span>] * (m + <span class="number">1</span>)     <span class="comment">#Start at 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">and</span> pat[k + <span class="number">1</span>] != pat[i]):</span><br><span class="line">            k = prefix_func[k]</span><br><span class="line">        <span class="keyword">if</span> pat[k + <span class="number">1</span>] == pat[i]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        prefix_func[i] = k</span><br><span class="line"></span><br><span class="line">    matched, ind = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text[start:end]:</span><br><span class="line">        <span class="keyword">if</span> (matched <span class="keyword">and</span> pat[matched + <span class="number">1</span>] != i):</span><br><span class="line">            matched = prefix_func[matched]</span><br><span class="line">        <span class="keyword">if</span> pat[matched + <span class="number">1</span>] ==i:</span><br><span class="line">            matched += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matched == m:</span><br><span class="line">            <span class="keyword">return</span> start + ind - m + <span class="number">1</span></span><br><span class="line">        ind += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串的特征向量-next-i"><a href="#字符串的特征向量-next-i" class="headerlink" title="字符串的特征向量 $next[i]$"></a>字符串的特征向量 $next[i]$</h1><p>《数据结构与算法》在讲到KMP算法时没有使用前缀函数$\pi$，而是字符串的特征向量 $next[i]$。使用特征向量在理解上要困难与前缀函数，但<strong>使用字符串的特征向量遵守了在绝大多数编程语言中，数组（包括字符串）下标从0开始的约定，并且减少了不匹配情况出现时的循环次数</strong>，使得在实际实现时更方便一些。</p>
<h2 id="优化前的特征向量"><a href="#优化前的特征向量" class="headerlink" title="优化前的特征向量"></a>优化前的特征向量</h2><p>字符串的特征向量定义为<br>$$<br>next[i]=<br>\begin{cases}<br>-1,如果i=0,\<br>max(k:0&lt;k&lt;i并且P[0…k-1]=P[i-k…i-1]),如果k存在,\<br>0,otherwise.<br>\end{cases}<br>$$</p>
<p>和前缀函数进行比较，<strong>在含义上，除了$next[0]$之外，$next[i]$表示如果在位置$i$处匹配失败，则应该将模式$P$上的指针移动到哪一个位置（的下标）</strong>。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和前缀函数为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220103510586.png" alt="image-20201220103510586" style="zoom:80%;">

<h2 id="特征向量的优化"><a href="#特征向量的优化" class="headerlink" title="特征向量的优化"></a>特征向量的优化</h2><p>假设求出的$next[i]=k$，当匹配时发现$P[i] \neq T[j]$，按照特征向量的定义，需要把模式向右移动$i-k$位，即用$P[k]$与$T[j]$进行比较。<strong>如果$P[i]=P[k]$，则$T[j] \neq P[k]$。</strong></p>
<p>因此，在按照上面的步骤计算出特征向量之后，再遍历一次特征向量，不断比较$P[i]$和$P[next[i]]$，如果$P[i]=P[next[i]]$，则令$next[i]=next[next[i]]$，直到$P[i] \neq P[next[i]]$或者$next[i]=-1$。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和优化后的特征向量为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220105721483.png" alt="image-20201220105721483" style="zoom:80%;">]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>OTHERS</category>
      </categories>
      <tags>
        <tag>OTHERS</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>编码算法——Base 64</title>
    <url>/2020/12/13/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Base%2064/</url>
    <content><![CDATA[<p><strong>Base 64编码算法详解</strong></p>
<a id="more"></a>

<h1 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h1><p>在计算机中。字符一般使用8位（即1个字节）大小的内存进行存储，该1个字节大小的内存可以表示从0到255之间的整数。而ASCII编码表在这里就定义了数字到字符的一一对应关系。因此，给定一个二进制串，计算机可以按照每八位为一个单位，查表得到整个字符串；反过来，给定一个字符串，也可以查表得到该字符串对应的二进制串。</p>
<p><strong>而对于Base 64来说，其使用六位来表示一个字符</strong>。因此，编码后的字符串仅包括64个不同的字符（还有一个字符<code>=</code>用于补位，因此准确地说是65个不同的字符）。下面通过实例来说明Base 64的编码原理。</p>
<p>标准的Base 64也有一个<strong>编码表</strong>，通常表示为</p>
<p><code>lookup = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</code></p>
<p>具体如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><strong>A</strong></td>
<td align="center">17</td>
<td align="center"><strong>R</strong></td>
<td align="center">34</td>
<td align="center"><strong>i</strong></td>
<td align="center">51</td>
<td align="center"><strong>z</strong></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><strong>B</strong></td>
<td align="center">18</td>
<td align="center"><strong>S</strong></td>
<td align="center">35</td>
<td align="center"><strong>j</strong></td>
<td align="center">52</td>
<td align="center"><strong>0</strong></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>C</strong></td>
<td align="center">19</td>
<td align="center"><strong>T</strong></td>
<td align="center">36</td>
<td align="center"><strong>k</strong></td>
<td align="center">53</td>
<td align="center"><strong>1</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><strong>D</strong></td>
<td align="center">20</td>
<td align="center"><strong>U</strong></td>
<td align="center">37</td>
<td align="center"><strong>l</strong></td>
<td align="center">54</td>
<td align="center"><strong>2</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>E</strong></td>
<td align="center">21</td>
<td align="center"><strong>V</strong></td>
<td align="center">38</td>
<td align="center"><strong>m</strong></td>
<td align="center">55</td>
<td align="center"><strong>3</strong></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><strong>F</strong></td>
<td align="center">22</td>
<td align="center"><strong>W</strong></td>
<td align="center">39</td>
<td align="center"><strong>n</strong></td>
<td align="center">56</td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><strong>G</strong></td>
<td align="center">23</td>
<td align="center"><strong>X</strong></td>
<td align="center">40</td>
<td align="center"><strong>o</strong></td>
<td align="center">57</td>
<td align="center"><strong>5</strong></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><strong>H</strong></td>
<td align="center">24</td>
<td align="center"><strong>Y</strong></td>
<td align="center">41</td>
<td align="center"><strong>p</strong></td>
<td align="center">58</td>
<td align="center"><strong>6</strong></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><strong>I</strong></td>
<td align="center">25</td>
<td align="center"><strong>Z</strong></td>
<td align="center">42</td>
<td align="center"><strong>q</strong></td>
<td align="center">59</td>
<td align="center"><strong>7</strong></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><strong>J</strong></td>
<td align="center">26</td>
<td align="center"><strong>a</strong></td>
<td align="center">43</td>
<td align="center"><strong>r</strong></td>
<td align="center">60</td>
<td align="center"><strong>8</strong></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><strong>K</strong></td>
<td align="center">27</td>
<td align="center"><strong>b</strong></td>
<td align="center">44</td>
<td align="center"><strong>s</strong></td>
<td align="center">61</td>
<td align="center"><strong>9</strong></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><strong>L</strong></td>
<td align="center">28</td>
<td align="center"><strong>c</strong></td>
<td align="center">45</td>
<td align="center"><strong>t</strong></td>
<td align="center">62</td>
<td align="center"><strong>+</strong></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><strong>M</strong></td>
<td align="center">29</td>
<td align="center"><strong>d</strong></td>
<td align="center">46</td>
<td align="center"><strong>u</strong></td>
<td align="center">63</td>
<td align="center"><strong>/</strong></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><strong>N</strong></td>
<td align="center">30</td>
<td align="center"><strong>e</strong></td>
<td align="center">47</td>
<td align="center"><strong>v</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><strong>O</strong></td>
<td align="center">31</td>
<td align="center"><strong>f</strong></td>
<td align="center">48</td>
<td align="center"><strong>w</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><strong>P</strong></td>
<td align="center">32</td>
<td align="center"><strong>g</strong></td>
<td align="center">49</td>
<td align="center"><strong>x</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><strong>Q</strong></td>
<td align="center">33</td>
<td align="center"><strong>h</strong></td>
<td align="center">50</td>
<td align="center"><strong>y</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101</code></p>
<p>如果我们将其按照三个一组进行分组，就可以得到<code>001 110 101 110 101 011 101 011 101 010 000 101</code></p>
<p>现在，我们每两组作为一个单位，可以得到<code>\14\46\43\43\42\5</code></p>
<p>通过查表，既可以得到编码后的字符串为**<code>OurrqF</code>**</p>
</blockquote>
<p>上面说的是理想的情况，通常情况下，<strong>字符串对应的二进制串的长度是8的倍数，但很有可不是6的倍数</strong>。为了解决这个办法，Base 64要求在原二进制串后填0，将该字符串扩充为长度是6的倍数，并使用字符<code>=</code>进行补位（等号的个数取决于补位的0的数量）。补位有两种可能出现的情况，接下来将分别说明。</p>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111 1110</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 111 10</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 111111 10[0000]</code></strong></p>
<p>另一种情况，假设我们有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 1</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 1111[00]</code></strong></p>
</blockquote>
<p>实际上我们可以证明，补位仅有两种情况。因此Base 64编码规定，如果在二进制串末尾补0的个数为2，则在编码后字符串末尾添加一个等号<code>=</code>。如果补0的个数为4，则添加两个等号<code>==</code>。</p>
<blockquote>
<p>因此，上面两个二进制串经过编码得到的字符串为：</p>
<p><strong><code>OurrqF/g==</code>**和</strong><code>OurrqF8=</code>**</p>
</blockquote>
<p>在知道编码原理之后，解码的过程就容易理解了。</p>
<h1 id="换表Base-64"><a href="#换表Base-64" class="headerlink" title="换表Base 64"></a>换表Base 64</h1><p>由上面的讨论可以看出，如果知道了Base 64的检索表，就可以完全将编码反编码。因此，为了保证更高的安全性（或者提高问题的难度），通常会使用新的检索表（而不是标准检索表）。</p>
<p>对于换表Base 64，一种方法是在函数中定义新的检索表，直接进行编码和文本之间的转换，另一种方法是做两次变换，将换表Base 64看作<strong>Text &lt;-&gt; 旧表下的Code &lt;-&gt;新表下的Code</strong>这样的函数的复合。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong><a href="https://base64.us/">在线编码网站</a></strong></p>
<p>Python中内置了Base 64编码库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;加密&quot;&quot;&quot;</span></span><br><span class="line">byte_text = text.encode()   </span><br><span class="line">		<span class="comment">#base64模块使用byte而不是str类型</span></span><br><span class="line">code = base64.b64encode(byte_text).decode()</span><br><span class="line">		<span class="comment">#b64encode()函数用于将字符串进行转换，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(code)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;解密&quot;&quot;&quot;</span></span><br><span class="line">de_text = base64.b64decode(code.encode()).decode()   </span><br><span class="line">		<span class="comment">#b64decode()函数是b64encode()的逆过程，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(de_text)</span><br></pre></td></tr></table></figure>

<p>Python函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_encode</span>(<span class="params">text, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(text, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> text])</span><br><span class="line">    remainder = <span class="built_in">len</span>(bin_str) % <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        bin_str += <span class="string">&quot;0&quot;</span> * (<span class="number">6</span> - remainder)</span><br><span class="line">    bin_str += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    code = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_str) // <span class="number">6</span>):</span><br><span class="line">        code += lookup[<span class="built_in">int</span>(bin_str[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        code += <span class="string">&quot;=&quot;</span> * ((<span class="number">6</span> - remainder) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_decode</span>(<span class="params">code, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(code, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> code[-<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>:    code = code[<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> code[-<span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>:  code = code[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line">    bin_code = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> code])</span><br><span class="line">    text = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_code) // <span class="number">8</span>):</span><br><span class="line">        text += <span class="built_in">chr</span>(<span class="built_in">int</span>(bin_code[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>NUMBER THEORY &amp; CRYPTO &amp; CODING</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CRYPTO</tag>
        <tag>NUMBER THEORY &amp; CRYPTO &amp; CODING</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Reference Chapter 1 变量和基本类型</title>
    <url>/2020/12/11/C++%20Reference%20Chapter%201%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<ul>
<li>C++中常用的算术类型介绍</li>
<li>类型转换（包括隐式类型转换和强制转换）</li>
<li>字面值常量</li>
<li>变量的声明、定义、初始化</li>
<li>标识符与命名</li>
</ul>
<a id="more"></a>

<h1 id="Chapter-1-变量和基本类型"><a href="#Chapter-1-变量和基本类型" class="headerlink" title="Chapter 1  变量和基本类型"></a>Chapter 1  变量和基本类型</h1><h2 id="1-1-基本内置类型"><a href="#1-1-基本内置类型" class="headerlink" title="1.1 基本内置类型"></a><strong>1.1 基本内置类型</strong></h2><p>C++的基本数据类型包括<strong>算数类型</strong>和**空类型<code>void</code>**。其中：</p>
<ul>
<li>算数类型包括<strong>字符</strong>，<strong>整型数</strong>，<strong>布尔值</strong>和<strong>浮点数</strong>。</li>
<li>空类型不对应具体的值，仅用作一些特殊的场合（例如函数的返回值）。</li>
</ul>
<p>数据类型可以告诉我们<strong>数据的意义以及我们能在数据上执行的操作</strong>。</p>
<h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><h4 id="常见的算数类型"><a href="#常见的算数类型" class="headerlink" title="常见的算数类型"></a>常见的算数类型</h4><p>算数类型分为<strong>整型</strong>（包括字符、布尔类型）和<strong>浮点型</strong>。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bool</code></td>
<td align="center">布尔类型</td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">短整型</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">整型</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center"><code>long long</code></td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">单精度浮点数</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td align="center"><code>long double</code></td>
<td align="center">扩展精度浮点数</td>
</tr>
</tbody></table>
<blockquote>
<p>对于他们的大小，C++语言有这样的规范：</p>
<p>一个<code>char</code>的空间应该确保可以存放机器基本字符集中的任意字符对应的数字值。也就是说，一个<code>char</code>的大小和一个机器字节一样。</p>
<p>一个<code>int</code>至少和一个<code>short</code>一样大，一个<code>long</code>至少和一个<code>int</code>一样大，一个<code>long long</code>至少和一个<code>long</code>一样大。</p>
</blockquote>
<h5 id="符号类型和无符号类型"><a href="#符号类型和无符号类型" class="headerlink" title="符号类型和无符号类型"></a>符号类型和无符号类型</h5><p>在上述提到的基本算珠类型中，除去布尔型，其他整型都可以划分为<strong>带符号</strong>和<strong>无符号</strong>两种类型。带符号类型使用<code>signed</code>表示，无符号类型使用<code>unsigned</code>表示。</p>
<table>
<thead>
<tr>
<th>有符号类型</th>
<th>无符号类型</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>(signed) int</code></td>
<td><code>unsigned int</code>/<strong><code>unsigned</code></strong></td>
<td><code>(signed)short</code></td>
<td><code>unsigned short</code></td>
</tr>
<tr>
<td><code>(signed)long</code></td>
<td><code>unsigned long</code></td>
<td><code>(signed)long long</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody></table>
<blockquote>
<p>字符整型被分为<code>signed char</code>和<code>unsigned char</code>三种类型。与其他类型不同，类型<code>char</code>和<code>signed char</code>并不相同。<code>char</code>类型是否带符号取决于不同的编译器。</p>
</blockquote>
<h4 id="扩展的字符型"><a href="#扩展的字符型" class="headerlink" title="扩展的字符型"></a>扩展的字符型</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>wchar_t</code></td>
<td align="center">宽字符</td>
<td align="center">用于确保可以存放机器最大扩展字符集中的任意一个字符。</td>
</tr>
<tr>
<td align="center"><code>char16_t</code></td>
<td align="center">Unicode字符</td>
<td align="center">用于Unicode字符集。</td>
</tr>
<tr>
<td align="center"><code>char32_t</code></td>
<td align="center">Unicode字符</td>
<td align="center">用于Unicode字符集。</td>
</tr>
</tbody></table>
<h4 id="如何选用类型"><a href="#如何选用类型" class="headerlink" title="如何选用类型"></a>如何选用类型</h4><blockquote>
<p><strong>如何选用类型:</strong></p>
<ul>
<li>如果数值不可能为负时，选用无符号类型。</li>
<li>使用<code>int</code>执行整型运算，如果数值超出<code>int</code>表示范围，使用<code>long long</code>。</li>
<li>只有表示字符时使用<code>char</code>，只有表示布尔值时使用<code>bool</code>。</li>
<li>在使用字符型表示小整数时，注明<code>signed char</code>还是<code>unsigned char</code>。</li>
<li>执行浮点数使用<code>double</code>。</li>
</ul>
</blockquote>
<h3 id="如何使用代码查看各个基本类型的范围和大小"><a href="#如何使用代码查看各个基本类型的范围和大小" class="headerlink" title="如何使用代码查看各个基本类型的范围和大小"></a>如何使用代码查看各个基本类型的范围和大小</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;	//&lt;climits&gt;库中储存了各个类型的范围</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如何查看某个变量类型的大小</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long long: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">&quot; bits.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用&lt;climits&gt;查看变量范围</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int from &quot;</span> &lt;&lt; INT_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; INT_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;long from &quot;</span> &lt;&lt; LONG_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; LONG_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char from &quot;</span> &lt;&lt; CHAR_MIN &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; CHAR_MAX &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-类型转换"><a href="#1-2-类型转换" class="headerlink" title="1.2 类型转换"></a><strong>1.2 类型转换</strong></h2><h3 id="将一种算术类型的值赋给另一种类型"><a href="#将一种算术类型的值赋给另一种类型" class="headerlink" title="将一种算术类型的值赋给另一种类型"></a>将一种算术类型的值赋给另一种类型</h3><ul>
<li>将非布尔值赋给布尔类型，初始值为0，则结果为<code>false</code>，初始值不为0，则结果为<code>true</code>。</li>
<li>将布尔值赋给非布尔类型，初始值为<code>true</code>，则结果为1，初始值为<code>false</code>，则结果为0。</li>
<li>将浮点数赋给整数类型，进行了近似处理，结果值仅保留浮点数中小数点之前的部分。</li>
<li>将整数赋给浮点类型，小数部分记为0 。如果整数所占空间超过浮点类型容量，精度可能损失。</li>
</ul>
<p>在赋值过程中，如果<strong>将超出某一类型范围的值</strong>赋给该类型变量时：</p>
<ul>
<li>赋给无符号类型的结果是<strong>对无符号类型表示的最大数值取模的余数</strong>。</li>
<li>赋给有符号类型的结果是<font color="red"><strong>未定义</strong></font>的。</li>
</ul>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><h4 id="何时会发生隐式类型转换"><a href="#何时会发生隐式类型转换" class="headerlink" title="何时会发生隐式类型转换"></a>何时会发生隐式类型转换</h4><p>当两个运算对象类型不同时，C++语言不会直接将两个不同类型的值做运算，而是先根据类型转换规则设法将运算对象的类型统一之后再求值。上述的类型转换是自动执行的，因此，它们被称为<strong>隐式类型转换</strong>。</p>
<p>隐式转换的设计原则是<strong>尽可能避免损失精度</strong>。</p>
<blockquote>
<p>具体来说，出现下面这些情况时会发生隐式类型转换：</p>
<ul>
<li>在表达式中，比<code>int</code>类型小的整型值会首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值会转换为布尔值。</li>
<li>初始化过程中，初始值转换为变量的类型。</li>
<li>赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换为一种类型。</li>
<li>函数调用时发生的类型转换。</li>
</ul>
</blockquote>
<h4 id="最主要的隐式转换：算数转换"><a href="#最主要的隐式转换：算数转换" class="headerlink" title="最主要的隐式转换：算数转换"></a>最主要的隐式转换：算数转换</h4><p>算数转换是把一种算术类型转换为另一种算术类型。</p>
<h5 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h5><p>整型提升负责<strong>将小整数类型转换为较大的整数类型</strong>。</p>
<p>对于<code>bool</code>,<code>char</code>,<code>singed char</code>,<code>unsigned char</code>,<code>short</code>,<code>unsigned short</code>等类型来说，只要它们所有可能的值都能存在<code>int</code>类型中，它们就会提升为<code>int</code>类型，否则，提升为<code>unsigned int</code>类型（在一般的编译器下，一个<code>int</code>占用32bits的空间，因此他们都会被转换为<code>int</code>类型）。</p>
<p>较大的字符型，比如<code>wchar_t</code>,<code>char16_t</code>,<code>char32_t</code>，会按照<code>int</code>,<code>unsigned int</code>,<code>long</code>,<code>unsigned long</code>,<code>long long </code>,<code>unsigned long long </code>的顺序依次检查，在能容纳所有可能的值的前提下选择最小的一种类型转换。</p>
<h5 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h5><p>如果运算对象一个是有符号的，一个是无符号的，则根据两个整数类型的相对大小进行转换（小类型向大类型转换）。</p>
<p><strong>如果两个类型占用的字节数不同，则小字节类型转换为大字节类型；如果相同，有符号类型转换为无符号类型。</strong></p>
<h5 id="算数转换的步骤"><a href="#算数转换的步骤" class="headerlink" title="算数转换的步骤"></a>算数转换的步骤</h5><ol>
<li><p>首先对<code>char</code>,<code>bool</code>等小整型进行<strong>整型提升</strong>。</p>
</li>
<li><p>如果整型提升之后类型不匹配：</p>
<ol>
<li><p>如果运算对象中有浮点类型，则<strong>所有运算对象转换为相应的浮点类型</strong>。</p>
</li>
<li><p>如果没有浮点类型：</p>
<p><strong>根据类型大小规则，将所有类型全部转换为最大的一个类型。具体地说：</strong></p>
<ol>
<li>如果提升后的运算对象都是带符号的，或者都是不带符号的，则<strong>小类型运算对象转换成较大的类型</strong>。</li>
<li>如果提升后的运算对象既有有符号的，也有无符号的，则根据<strong>无符号类型的运算对象</strong>中的规则进行转换。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h4><ul>
<li><p>数组转换为指针<font color="blue">【参考数组部分】</font></p>
</li>
<li><p>指针的转换<font color="blue">【参考指针部分】</font></p>
<p>例如：常量整数值<code>0</code>和字面值<code>nullptr</code>可以转换成任意指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如我们经常这样初始化指针：</span></span><br><span class="line">	<span class="keyword">int</span>* ptr_i = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* ptr_llong = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>指向非常量的指针能转换为<code>void*</code>，指向任意对象的指针能转换为<code>const void*</code>。</p>
</li>
</ul>
<h3 id="显式类型转换（强制类型转换）"><a href="#显式类型转换（强制类型转换）" class="headerlink" title="显式类型转换（强制类型转换）"></a>显式类型转换（强制类型转换）</h3><p><strong>字符和字符串字面值</strong></p>
<p>一个命名的强制类型转换具有如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cast-name &lt;type&gt; (expression)</span><br></pre></td></tr></table></figure>

<p>其中:<code>type</code>是转换的目标类型。<code>expression</code>是要转换的值。<br><code>cast-name</code>是<code>static_cast</code>,<code>dynamic_cast</code>,<code>const_cast</code>,<code>reinterpret_cast</code>中的一种，下面将对这三种转换分别说明。<font color="blue">【该部分涉及<code>const</code>的有关内容，参考常量部分】</font></p>
<p><strong><code>static_cast</code></strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用static_cast执行强制执行浮点运算</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">3</span>, j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i) / j;</span><br><span class="line"><span class="comment">//将一个较大的算术类型赋值给较小的类型</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.2</span>);</span><br><span class="line"><span class="comment">//执行编译器无法自动执行的类型转换</span></span><br><span class="line"><span class="keyword">double</span> fval = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">void</span>* p = &amp;fval;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p));</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>static_cast</code>并不支持指针类型的转换。</p>
<p><strong><code>const_cast</code></strong></p>
<p><code>const_cast</code>只能改变运算对象的底层<code>const</code>。因此**<code>const_cast</code>中的类型必须是指针、引用或指向对象类型成员的指针**。</p>
<p>将常量对象转换成非常量对象的行为一般称为<strong>“去掉<code>const</code>性质”</strong>。</p>
<p><strong>需要注意的是尽管<code>const_cast</code>可以去掉指针的<code>const</code>属性，但是所指位置的值仍然不会被修改。</strong></p>
<p>只有<code>const_cast</code>能改变表达式的常量属性。其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同时，<code>const_cast</code>不能改变表达式的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>, cch = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pch = &amp;ch, * pcch = &amp;cch;</span><br><span class="line"><span class="keyword">char</span>* p1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pch);    <span class="comment">//正确。</span></span><br><span class="line"><span class="keyword">char</span>* p2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pcch);   <span class="comment">//正确，但由于cch本身是一个常量，所以通过p2写值是未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; crval = val;</span><br><span class="line"><span class="keyword">int</span>&amp; rval = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(crval); <span class="comment">//错误：static_cast无法丢掉常量或其他类型限定符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> fval = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">double</span>* pfval = &amp;fval;</span><br><span class="line"><span class="keyword">int</span>* pint = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(fval);  <span class="comment">//错误：const_cast 只能调节类型限定符；不能更改基础类型</span></span><br></pre></td></tr></table></figure>

<p><strong><code>reinterpret_cast</code></strong></p>
<p><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释。<font color="red">使用<code>reinterpret_cast</code>是十分危险的行为</font>。</p>
<h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>旧式的强制类型转换包含两种形式：</p>
<p><code>type (expr)</code>和<code>(type) expr</code></p>
<p>根据所涉及的类型不同，旧式的强制类型转换分别具有与<code>static_cast</code>,<code>const_cast</code>,<code>reinterpret_cast</code>相似的行为。</p>
<p>如果替换为<code>static_cast</code>或<code>const_cast</code>合法，则其行为与对应的命名转换一致。如果不合法，则执行与<code>reinterpret_cast</code>类似的功能。</p>
<p><strong>使用新式的方式执行强制类型转换有助于代码阅读以及编译器查找错误。</strong></p>
<h2 id="1-3-字面值常量"><a href="#1-3-字面值常量" class="headerlink" title="1.3 字面值常量"></a><strong>1.3 字面值常量</strong></h2><h3 id="整型字面值及类型"><a href="#整型字面值及类型" class="headerlink" title="整型字面值及类型"></a>整型字面值及类型</h3><p><strong>整型字面值分为十进制数，八进制数或十六进制数</strong>。</p>
<p><strong>以<code>0</code>开头的整数代表8进制数，以<code>0x</code>或<code>0X</code>开头的整数代表16进制数。</strong>因此，为了表示十进制中的20，可以采用如下方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span><span class="comment">/*dec*/</span>    <span class="number">024</span><span class="comment">/*oct*/</span>    <span class="number">0x14</span><span class="comment">/*hec*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>-</code>不是字面值（例如<code>int x = -23;</code>），它的作用仅是对字面值取负。</strong></p>
<p><strong>字面值类型是能容纳其数值的<code>int</code>,<code>unsigned int</code>,<code>long</code>,<code>unsigned long</code>,<code>long long</code>,<code>unsigned long long</code>中的最小的一个</strong>。</p>
<blockquote>
<p>如果有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-4294967290</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这样类似的写法，编译器会报错: 一元负运算符应用于无符号类型，结果仍为无符号类型。</p>
<p>原因：当字面值为4294967290时，编译器发现<code>int</code>类型无法容纳，则决定使用<code>unsigned int</code>容纳。因此出现了一元负运算符应用于无符号类型的错误，这也应证了<code>-</code>不包括在字面值中，他的作用仅仅是对字面值取负号。</p>
</blockquote>
<h3 id="浮点型字面值及类型"><a href="#浮点型字面值及类型" class="headerlink" title="浮点型字面值及类型"></a><span id="浮点型字面值及类型">浮点型字面值及类型</span></h3><p><strong>所有浮点型字面值的默认类型为<code>double</code>。</strong></p>
<p><strong>小数型字面值</strong></p>
<p>下面均是可行的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>   <span class="number">.1234</span><span class="comment">/*0.1234*/</span>    <span class="number">34.</span><span class="comment">/*34.0*/</span></span><br></pre></td></tr></table></figure>

<p><strong>科学计数法</strong>使用<code>E</code>或<code>e</code>表示指数部分。</p>
<p>下面均是可行的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0.314159E1</span>    <span class="number">3e1</span>    <span class="number">0E0</span></span><br></pre></td></tr></table></figure>

<h3 id="字符、字符串字面值及类型"><a href="#字符、字符串字面值及类型" class="headerlink" title="字符、字符串字面值及类型"></a><span id="字符、字符串字面值及类型">字符、字符串字面值及类型</span></h3><p><strong>由单引号括起来的一个字符称为<code>char</code>型字面型。</strong></p>
<p><strong>由双引号括起来的零个或多个字符构成字符串型字面值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>    <span class="string">&#x27;b&#x27;</span>    <span class="string">&#x27; &#x27;</span> <span class="comment">//char</span></span><br><span class="line"><span class="string">&quot;Hello World.&quot;</span>      <span class="string">&quot;&quot;</span> <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串字面值实际上是由常量字符构成的数组</strong>，编译器在每个字符串的结尾处添加一个空字符<code>&#39;\0&#39;</code>,因此，<strong>字符串字面值的实际长度比它的内容多1</strong><font size="2" color="blue">【参考字符串部分】</font>。</p>
<h3 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h3><p><code>true</code>和<code>false</code>是<code>bool</code>类型的字面值。</p>
<p><code>nullptr</code>是指针字面值<font size="2" color="blue">【参考指针部分】</font>。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a><span id="转义序列">转义序列</span></h3><p>有些在C++语言中有特殊含义的字符（比如单引号、双引号）不能直接在字符（串）字面值中使用。在这些情况下需要使用<strong>转义序列</strong>。</p>
<p>常见的转义序列：</p>
<table>
<thead>
<tr>
<th align="center">字符字面值不可使用</th>
<th align="center">字符串字面值不可使用</th>
<th align="center">有特殊含义</th>
<th align="center">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\\</code> 反斜线</td>
<td align="center"><code>\\</code> 反斜线</td>
<td align="center"><code>\n</code> 换行符</td>
<td align="center"><code>\?</code> 问号</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code> 单引号</td>
<td align="center"><code>\&quot;</code>双引号</td>
<td align="center"><code>\r</code> 回车符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\t</code> 横向制表符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\b</code> 退格符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>\a</code> 报警（响铃）符</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>泛化的转义序列</p>
<p>泛化的转义字符的形式是<code>\x</code>后面跟着一位或多位十六进制字符，或者<code>\</code>后面跟着1位、2位或3位八进制数，转义序列不可以识别十进制数。</p>
<blockquote>
<p>十六进制数最多识别四位，八进制数最多识别三位。如果十六进制数或八进制数太大，编译器会报错。</p>
</blockquote>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加一些前缀和后缀，可以改变字面值的类型。</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>Unicode 16 字符</td>
<td><code>char16_t</code>    (VS中的<code>cout &lt;&lt; </code>转换为<code>int</code>)</td>
</tr>
<tr>
<td><code>U</code></td>
<td>Unicode 32 字符</td>
<td><code>char32_t</code>    (VS中的<code>cout &lt;&lt; </code>转换为``unisgned int`)</td>
</tr>
<tr>
<td><code>L</code></td>
<td>宽字符</td>
<td><code>wchar_t</code>       (VS中的<code>cout &lt;&lt; </code>转换为<code>int</code>)`</td>
</tr>
<tr>
<td><code>u8</code></td>
<td>UTF-8</td>
<td><code>char</code></td>
</tr>
</tbody></table>
<p><strong>浮点型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>f</code>或<code>F</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>l</code>或<code>L</code></td>
<td><code>long double</code></td>
</tr>
</tbody></table>
<p><strong>整型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code>或<code>U</code></td>
<td><code>unsigned</code></td>
</tr>
<tr>
<td><code>l</code>或<code>L</code></td>
<td><code>long</code></td>
</tr>
<tr>
<td><code>ll</code>或<code>LL</code></td>
<td><code>long long</code></td>
</tr>
</tbody></table>
<blockquote>
<p>整型字面值后缀<code>u</code>可以和另外两个合在一起使用。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">12U</span>LL, y = <span class="number">12L</span>Lu;</span><br></pre></td></tr></table></figure>

<p>如果字面值大于后缀最小匹配类型，C++会自动寻找更大的可以容纳的类型。</p>
</blockquote>
<h2 id="1-4-变量"><a href="#1-4-变量" class="headerlink" title="1.4 变量"></a><strong>1.4 变量</strong></h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式是：<strong>基本数据类型 + 声明符列表</strong>，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p>对于基本类型，其声明符即为其标识符（名字）。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><font color="blue">【初始化部分涉及到的字符串、数组、向量、自定义数据类型等交叉内容，参考各相关部分】</font></p>
<p><font color="blue">【某种类型特殊的初始化方式，参考各部分】</font></p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化</strong>了。</p>
<blockquote>
<p>在同一条定义语句中，可以用先定义的变量值初始化后定义的其他变量。</p>
</blockquote>
<p><font color="red">初始化和赋值是两个完全不同的操作</font>。<strong>初始化的含义是创建变量时赋予其一个初始值</strong>，而<strong>赋值的含义是把对象当前的值擦除，而以一个新的值来代替</strong>。</p>
<h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>C++语言定义了多种初始化方式。如果使用等号<code>=</code>初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化</strong>。</p>
<p>以初始化<code>string</code>对象为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> str0 = <span class="string">&quot;Value0&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str1 = str0;</span><br><span class="line"><span class="built_in">string</span> str2 = (<span class="string">&quot;Value2&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str3 = &#123; <span class="string">&quot;Value3&quot;</span> &#125;; <span class="comment">//这种初始化方式也被称为列表初始化</span></span><br><span class="line"><span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">&quot;Value4&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，在拷贝初始化中，是否添加括号并没有影响。</p>
<p>当初始值只有一个时，拷贝初始化和直接初始化的效果是相同的。如果初始值有多个，一般只能使用直接初始化。</p>
<blockquote>
<p>对于<code>string</code>对象和<code>vector</code>来说，可以以如下方式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//等价于 string str = &quot;cccccccccc&quot;;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>; <span class="comment">//等价于 vector&lt;int&gt; vec = &#123;1, 1, 1&#125;;</span></span><br></pre></td></tr></table></figure>

<p>该类初始化使用了两个初始值，因此只能使用直接初始化。</p>
</blockquote>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>用花括号<code>&#123;&#125;</code>来初始化变量的形式被称为<strong>列表初始化</strong>，<strong>列表初始化分为直接列表初始化和拷贝列表初始化</strong>。一般来说，使用直接初始化或间接初始化都只能对一个数据类型做初始化，对于数组、向量等数据类型，可以使用列表初始化对各个变量做初始化，<strong>该类初始化不能使用圆括号</strong>。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//拷贝列表初始化。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; LlongVec &#123;<span class="number">12L</span>L, <span class="number">23L</span>L&#125;; <span class="comment">//直接列表初始化。</span></span><br></pre></td></tr></table></figure>

<p>对于单个元素和内置类型来说，也可以使用列表初始化，此时可以看作是对只有一个元素的数组做初始化。<strong>需要注意的是，使用内置类型的变量时，列表初始化有一个重要的特点：如果初始值存在丢失信息的风险，则编译器将报错</strong>。</p>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量时没有进行初始化操作，则变量被<strong>默认初始化</strong>。</p>
<p><strong>内置类型</strong></p>
<p>如果内置类型没有显式初始化，它的值由定义域决定。<strong>定义域任何函数体之外的变量被初始化为0</strong>.<strong>定义在函数体内部的内置类型变量将不被初始化</strong>。试图访问此类值将会引发错误。</p>
<p><strong>内置类型的数组类型</strong></p>
<p>如果数组类型被定义在函数体之内，则每个元素都没有做初始化，如果定义在函数体之外，则每个元素都被初始化为0.</p>
<p>和内置类型不同的是，**访问未被初始化的数组元素不会引发编译错误，<font color="red">但该行为是未定义的</font>**。</p>
<p><strong>自定义数据类型（类）</strong></p>
<p>每个类各自决定初始化对象的方式（即构造函数）。</p>
<p>如果构造函数没有覆盖所有对象的初始化，则未被覆盖的对象按照对应类型的默认初始化规则进行初始化。</p>
<p><strong><code>string</code>类规定如果没有指定初值则生成一个空串</strong></p>
<h4 id="值初始化、zero初始化和聚合类型初始化"><a href="#值初始化、zero初始化和聚合类型初始化" class="headerlink" title="值初始化、zero初始化和聚合类型初始化"></a>值初始化、<code>zero</code>初始化和聚合类型初始化</h4><p><strong>在一般情况下，可以将这三种初始化类型都看作值初始化。其一般规则为，基本内置类型为0，<code>string</code>类型为空串，其他类型遵循各自的规则。</strong></p>
<p>值初始化用于有初始化器但初始化器为空时的情形。<code>zero</code>初始化没有显式调用的语法，在某些值初始化的情况下会调用<code>zero</code>初始化。</p>
<blockquote>
<p>Zero initialization is performed in the following situations:</p>
<ul>
<li>For every named variable with static or thread-local storage duration that is not subject to constant initialization, before any other initialization.</li>
<li>As part of value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided.</li>
<li>When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">&#125;; <span class="comment">// implicit default constructor</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">    T2(<span class="keyword">const</span> T2&amp;) &#123; &#125; <span class="comment">// user-provided copy constructor</span></span><br><span class="line">&#125;;                    <span class="comment">// no default constructor</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mem2;</span><br><span class="line">    T3() &#123; &#125; <span class="comment">// user-provided default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s&#123;&#125;; <span class="comment">// class =&gt; default-initialization, the value is &quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n&#123;&#125;;                <span class="comment">// scalar =&gt; zero-initialization, the value is 0</span></span><br><span class="line">    <span class="keyword">double</span> f = <span class="keyword">double</span>();    <span class="comment">// scalar =&gt; zero-initialization, the value is 0.0</span></span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// array =&gt; value-initialization of each element</span></span><br><span class="line">                            <span class="comment">//          the value of each element is 0</span></span><br><span class="line">    T1 t1&#123;&#125;;                <span class="comment">// class with implicit default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t1.mem1 is zero-initialized, the value is 0</span></span><br><span class="line">                            <span class="comment">//     t1.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line"><span class="comment">//  T2 t2&#123;&#125;;                // error: class with no default constructor</span></span><br><span class="line">    T3 t3&#123;&#125;;                <span class="comment">// class with user-provided default constructor =&gt;</span></span><br><span class="line">                            <span class="comment">//     t3.mem1 is default-initialized to indeterminate value</span></span><br><span class="line">                            <span class="comment">//     t3.mem2 is default-initialized, the value is &quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// value-initialization of each element</span></span><br><span class="line">                            <span class="comment">// the value of each element is 0</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于聚合类型和<code>array</code>类型来说，在有初始化器但初始化器为空时的情形下，执行聚合类型初始化而不是值初始化。</p>
<blockquote>
<p>聚合类型：</p>
<p>class type (typically, struct or union), that has</p>
<ul>
<li>no private or protected direct non-static data members</li>
<li>no user-provided constructors (explicitly defaulted or deleted constructors are allowed)</li>
<li>no virtual or private base classes</li>
<li>no virtual member functions</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s1 = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;;</span><br><span class="line">    S s2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// same, but with brace elision</span></span><br><span class="line">    S s3&#123;<span class="number">1</span>, &#123;<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; &#125; &#125;; <span class="comment">// same, using direct-list-initialization syntax</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// ar is int[3]</span></span><br><span class="line">    <span class="keyword">char</span> cr[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// array initialized as &#123;&#x27;a&#x27;, &#x27;\0&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ar2d1[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;; <span class="comment">// fully-braced 2D array: &#123;1, 2&#125;</span></span><br><span class="line">                                        <span class="comment">//                        &#123;3, 4&#125;</span></span><br><span class="line">    <span class="keyword">int</span> ar2d2[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// brace elision: &#123;1, 2&#125;</span></span><br><span class="line">                                    <span class="comment">//                &#123;3, 4&#125;</span></span><br><span class="line">    <span class="keyword">int</span> ar2d3[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;;   <span class="comment">// only first column: &#123;1, 0&#125;</span></span><br><span class="line">                                    <span class="comment">//                    &#123;2, 0&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; std_ar2&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;    <span class="comment">// std::array is an aggregate</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; std_ar1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// brace-elision okay</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ars[] = &#123;<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;one&quot;</span>), <span class="comment">// copy-initialization</span></span><br><span class="line">                         <span class="string">&quot;two&quot;</span>,              <span class="comment">// conversion, then copy-initialization</span></span><br><span class="line">                         &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125; &#125;; <span class="comment">// list-initialization</span></span><br><span class="line"> </span><br><span class="line">    U u1 = &#123;<span class="number">1</span>&#125;; <span class="comment">// OK, first member of the union</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// aggregate</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base1</span> &#123;</span> <span class="keyword">int</span> b1, b2 = <span class="number">42</span>; &#125;;</span><br><span class="line"><span class="comment">// non-aggregate</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base2</span> &#123;</span></span><br><span class="line">  base2() : b3(<span class="number">42</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> b3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="声明值初始化的变量"><a href="#声明值初始化的变量" class="headerlink" title="声明值初始化的变量"></a>声明值初始化的变量</h5><p>需要注意的是，如下的表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">x</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>并不会声明一个被值初始化的<code>long long</code>型变量。编译器会将其视作一个函数。正确的表达形式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = <span class="keyword">long</span> <span class="keyword">long</span>();</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化还是元素数量？"><a href="#列表初始化还是元素数量？" class="headerlink" title="列表初始化还是元素数量？"></a>列表初始化还是元素数量？</h4><p>通常来说，直接初始化使用圆括号<code>()</code>，列表初始化使用花括号<code>&#123;&#125;</code>。然而，有时单纯依靠括号的类型难以区分。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">3</span>, <span class="number">4</span> &#125;;	<span class="comment">//vec = &#123;3, 4&#125;;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;		<span class="comment">//vec2 = &#123;4, 4, 4&#125;;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果使用的是圆括号，我们可以认为括号内提供的值是用来构造（construct）对象的。</strong>编译器会寻找最合适的构造函数执行初始化操作，否则报错。</p>
<p><strong>如果使用的是花括号，编译器会首先认为我们希望列表初始化（list-initialize）对象。</strong>初始化过程会尽可能把花括号内的值当成是元素的初始值来处理，只有当无法执行列表初始化时才考虑吧其他的初始化方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec0(<span class="number">3</span>, <span class="string">&quot;Value&quot;</span>);	<span class="comment">//construct the vector;</span></span><br><span class="line"><span class="comment">//	vector &lt;string&gt; vec1(3, 4);			//error: construct the vector</span></span><br><span class="line">										<span class="comment">//but can&#x27;t find proper constructor;</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec2&#123; <span class="string">&quot;Value1&quot;</span>, <span class="string">&quot;Value2&quot;</span> &#125;;<span class="comment">//list-initialize;</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; vec3&#123; <span class="number">2</span>, <span class="string">&quot;Value&quot;</span> &#125;;	<span class="comment">//can&#x27;t list-initialize</span></span><br><span class="line">										<span class="comment">//change to fit constructor;</span></span><br><span class="line"><span class="comment">//	vector &lt;string&gt; vec4&#123; 3, 4 &#125;;		//error: change to constructor</span></span><br><span class="line">										<span class="comment">//can&#x27;t find proper constructor;</span></span><br></pre></td></tr></table></figure>

<h3 id="标识符与命名"><a href="#标识符与命名" class="headerlink" title="标识符与命名"></a>标识符与命名</h3><p>C++的标识符（identifier）由<strong>字母、数字和下划线</strong>组成，并且<strong>必须以字母或下划线开头</strong>。标识符<strong>对长度没有限制，但是对大小写字母敏感</strong>。</p>
<p>C++保留了一些名字供该语言本身使用（即关键字），这些名字不能被使用。</p>
<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h4><ul>
<li>C++为标准库保留了一些名字，因此用户自定义的标识符中不应该连续出现两个下划线，也不应该以下划线紧连大写字母开头。并且定义在函数体外的标识符不应该以下划线开头。</li>
<li>标识符要能体现实际含义。</li>
<li>变量名一般都使用小写字母，如<code>index</code>，不要使用<code>Index</code>或<code>INDEX</code>。</li>
<li>用户自定义的类名一般以大写字母开头，如<code>Sales_Items</code>。</li>
<li>如果标识符由多个单词组成，则单词之间应该有明显区分。常见的方法有<code>studentLoan</code>、<code>student_loan</code>。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++ REFERENCE</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++ REFERENCE</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Reference Chapter 2 复合类型</title>
    <url>/2020/12/11/C++%20Reference%20Chapter%202%20%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<ul>
<li>计算机存储与对象地址</li>
<li>复合类型[包括(左值)引用和指针]</li>
<li>常量（包括<code>const</code>和<code>constexpr</code>）</li>
<li>如何利用类型别名（如<code>typedef</code>）和<code>auto</code>类型说明符处理复杂类型</li>
</ul>
<a id="more"></a>

<h1 id="Chapter-2-复合类型"><a href="#Chapter-2-复合类型" class="headerlink" title="Chapter 2 复合类型"></a>Chapter 2 复合类型</h1><p><strong>复合类型</strong>是指基于其他类型定义的类型。C++语言有多种复合类型，其中最基础的时引用和指针。</p>
<p>在变量声明部分，我们指出，变量定义的基本形式是：<strong>基本数据类型 + 声明符列表</strong>，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p>对于基本类型，其声明符即为其标识符（名字）。然而，<strong>对于复合类型，其声明符不仅包含标识符，也包含类型修饰符</strong>。</p>
<h2 id="2-1-对象的地址"><a href="#2-1-对象的地址" class="headerlink" title="2.1 对象的地址"></a><strong>2.1 对象的地址</strong></h2><p>计算机以比特序列存储数据。可寻址的最小内存块称为<strong>字节<code>byte</code>**，存储的基本单元称为</strong>字<code>word</code>**，它通常由几个字节组成。</p>
<p>大多数计算机将内存中的每个字节与一个（通常为16进制的）数字关联起来。<strong>与内存中每个字节相关联的数字被称为地址（address）</strong>。我们能够使用某个地址来表示从这个地址开始的大小不同的比特串（比如<code>int</code>类型是4个字节，<code>long long</code>是8个字节）。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。<strong>类型决定了数据所占的比特数以及该如何解释这些比特的内容</strong>。</p>
<h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3><p>为了获得某个对象在计算机中所在的地址，需要使用**取地址符<code>&amp;</code>**。结合<code>sizeof</code>运算符可以得到某个对象在计算机中存储的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> lval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* ladr = &amp;lval;</span><br><span class="line">	<span class="keyword">int</span>* adr = &amp;val;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lval : from &quot;</span> &lt;&lt; ladr &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (ladr + <span class="keyword">int</span>(<span class="keyword">sizeof</span>(lval))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val : from &quot;</span> &lt;&lt; adr &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; (adr + <span class="keyword">int</span>(<span class="keyword">sizeof</span>(val))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a><strong>2.2 引用</strong></h2><p><font color="blue">【引用与const的结合，参考常量部分】</font></p>
<p><strong>引用</strong>(reference)为对象起了另外一个名字，引用类型引用另外一种类型。</p>
<p><strong>通过将声明符写成<code>&amp;val</code>的形式来定义引用类型。其中<code>val</code>是变量的标识符。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refIval = ival;</span><br></pre></td></tr></table></figure>

<h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3><p><strong>引用并非对象</strong>，相反，他只是为一个已经存在的对象另外起一个名字。</p>
<p>在定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p>从地址的角度来说，对对象本身和它的引用取地址，得到的地址是相同的。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。</p>
<p>由于引用本身不是一个对象，因此<strong>不能定义引用的引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line"><span class="comment">//	int&amp; refIval2;	//Error: 引用必须初始化</span></span><br><span class="line">	ival = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;, refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	refIval += <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;, refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Address of ival: &quot;</span> &lt;&lt; &amp;ival</span><br><span class="line">		&lt;&lt; <span class="string">&quot;, address of refIval: &quot;</span> &lt;&lt; &amp;refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定还是赋值？"><a href="#绑定还是赋值？" class="headerlink" title="绑定还是赋值？"></a>绑定还是赋值？</h3><p>如果写出如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>, ival1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line">refIval = ival1;</span><br></pre></td></tr></table></figure>

<p>看起来我们更改了<code>refIval</code>的绑定对象，将其绑定到了<code>ival1</code>对象上。但是，如果执行如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>, ival1 = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; refIval = ival;</span><br><span class="line">	refIval = ival1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;refIval = &quot;</span> &lt;&lt; refIval &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;address of ival is &quot;</span> &lt;&lt; &amp;ival &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;address of refIval is &quot;</span> &lt;&lt; &amp;refIval &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;address of ival1 is &quot;</span> &lt;&lt; &amp;ival1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现<code>ival</code>的值变为2，并且<code>refIval</code>的地址与<code>ival</code>相同而不是<code>ival1</code>。</p>
<p>在这里，编译器将<code>refIval = ival1;</code>看作是赋值语句而不是绑定语句。因此，其和<code>ival = ival1</code>是等价的。因此，执行该条代码的效果是将<code>ival1</code>的值赋给了<code>ival</code>。</p>
<h2 id="2-3-指针"><a href="#2-3-指针" class="headerlink" title="2.3 指针"></a><strong>2.3 指针</strong></h2><p><font color="blue">【指针与const的结合，参考常量部分】</font></p>
<p>定义指针的方法是将声明符写成<code>*d</code>的形式。<strong>指针存放某个对象的地址</strong>，其实现了对某个对象的间接访问。</p>
<p>除了某些特殊情况，<strong>指针的类型需要和他所指的对象严格匹配</strong>。</p>
<p>如果指针指向了一个对象，则可以使用**解引用符<code>*</code>**来访问该对象。</p>
<p>和引用不同的是，指针属于对象，因此可以定义指针的指针，也可以定义指针的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* pVal = &amp;val;</span><br><span class="line"><span class="comment">//	double* pDVal = &amp;val; //Error.</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *pVal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	*pVal += <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p><strong>空指针不指向任何一个对象</strong>。以下是几个生成空指针的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">int</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span>* ptr3 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><code>void*</code>指针</h3><p><strong><code>void*</code>指针是一种特殊的指针类型，可用于存放任意对象的地址。</strong>我们仅能够将此类指针和其他指针比较，作为函数的输入和输出，或者赋给另一个<code>void*</code>指针（而不能赋给其他类型的指针），而不能直接操作指针所指向的对象。</p>
<blockquote>
<p>简单来说，<code>void*</code>指针仅保存了某一个地址。由于我们不知道该地址存储着什么类型的值，所以我们无法访问内存空间中所存的对象。</p>
</blockquote>
<p><strong>由于<code>void*</code>指针可以存放任意对象的地址，因此任意对象的地址都可以使用<code>static_cast</code>转换为<code>void*</code>指针。此外，由于<code>void*</code>可以存放任意对象的地址，因此使用<code>static_cast</code>可以将<code>void*</code>转换为任意类型对象的指针</strong>。</p>
<h3 id="基于指针的操作"><a href="#基于指针的操作" class="headerlink" title="基于指针的操作"></a>基于指针的操作</h3><h4 id="条件值"><a href="#条件值" class="headerlink" title="条件值"></a>条件值</h4><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算数值作为条件遵循的规则类似，如果指针的值为0，条件取<code>false</code>，任何非0指针对应的条件值都是<code>true</code>。</p>
<h4 id="相等与比较"><a href="#相等与比较" class="headerlink" title="相等与比较"></a>相等与比较</h4><p>对于<strong>两个类型相同且均合法</strong>的指针，可以用相等操作符<code>==</code>和不等操作符<code>!=</code>来比较他们。如果两个指针的地址相同，则它们相等，反之不相等。</p>
<p><strong>对于两个指针，如果某个指针指向的位置在另一个指针所指向的位置之后，则说第一个指针大于<code>&gt;</code>后一个指针。反之则小于。</strong></p>
<h4 id="递增、与整数的运算"><a href="#递增、与整数的运算" class="headerlink" title="递增、与整数的运算"></a>递增、与整数的运算</h4><p>C++支持指针加上或减去一个整数，其效果是将指针指向的位置相前或向后移动指定的偏移量。</p>
<p><strong>对于指针来说，指针移动的最小偏移量是其所指的类型的大小</strong>。由于<code>void*</code>不指向某种特定的类型，因此<code>void*</code>指针不支持算术运算。</p>
<p>此外，指针还可以使用递增运算符<code>++</code>和递减运算符<code>--</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* ptr = &amp;(arr[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(++ptr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr += <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(ptr - <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="两指针的运算"><a href="#两指针的运算" class="headerlink" title="两指针的运算"></a>两指针的运算</h4><p>可以令两个指针相减，其结果是两者的距离。也就是说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">	<span class="keyword">int</span> delta = ptr1 - ptr2</span><br><span class="line">then</span><br><span class="line">	ptr1 = ptr2 + delta</span><br></pre></td></tr></table></figure>

<p>**两指针相减的结果类型为<code>ptrdiff_t</code>**，通常也写为<code>int</code>。</p>
<h3 id="使用指针的危险性"><a href="#使用指针的危险性" class="headerlink" title="使用指针的危险性"></a>使用指针的危险性</h3><p><strong><font color="red">错误地使用指针会导致无法预计的后果</font></strong></p>
<p>指针的值应该属于下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置（一般用于迭代器）</li>
<li>空指针</li>
<li>无效指针</li>
</ul>
<p>其中，<font color="red">试图访问无效指针的值将引发无法预计的后果</font>，因此，程序员必须清楚任意给定的指针是否是有效的。除此之外，第二种和第三种形式的指针尽管是有效的，但是他们的使用受到很大的限制。<font color="red">对该类指针使用解引用符也会引发无法预计的后果</font>。</p>
<p><strong><font color="red">使用未经初始化的指针是引发运行时错误的一大原因</font></strong></p>
<p>和其他变量一样，未经初始化的指针的值时未定义的，但是和基本类型不同的是，<font color="red">编译器不负责检查未初始化指针造成的错误</font>。因此，在使用过程中，应在定义了对象之后再定义指向它的指针，并且保证<strong>初始化所有指针</strong>，包括还不清楚应该指向何处的（初始化为空指针）。</p>
<p><strong>在可能的情况下， 避免使用指针</strong></p>
<h2 id="2-4-复杂复合类型的声明"><a href="#2-4-复杂复合类型的声明" class="headerlink" title="2.4 复杂复合类型的声明"></a><strong>2.4 复杂复合类型的声明</strong></h2><p>如前所述，变量的定义包含一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只能有一个，但是声明符的形式却可以不同。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>, * ptr = &amp;val, &amp; ref = val;</span><br><span class="line"><span class="comment">//ptr是指向val的指针，ref是val的引用。</span></span><br></pre></td></tr></table></figure>

<p>并且，<strong>在定义语句中，类型修饰符仅作用于紧随它的一个变量</strong>，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;val, val2 = <span class="number">3</span>;<span class="comment">//ptr是指针，而val2是int型变量。</span></span><br></pre></td></tr></table></figure>

<p>由于指针可以嵌套使用，因此复合类型的声明可能会非常复杂。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* pVal = &amp;val;		<span class="comment">//pVal是指向val的指针</span></span><br><span class="line">	<span class="keyword">int</span>** ppVal = &amp;pVal;		<span class="comment">//ppVal是指向pVal的指针</span></span><br><span class="line">	<span class="keyword">int</span>**&amp; rppVal = ppVal;		<span class="comment">//rppVal是ppVal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左阅读有利于理解其真实含义</strong>。除此之外，也可以使用<code>auto</code>和<code>typedef</code>简化理解复杂声明语句。</p>
<h2 id="2-5-常量"><a href="#2-5-常量" class="headerlink" title="2.5 常量"></a><strong>2.5 常量</strong></h2><h3 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a><code>const</code>对象</h3><p>常量是其值不能被改变的变量。我们可以<strong>使用关键字<code>const</code>对变量的类型加以限定，定义常量</strong>。</p>
<p>由于<code>const</code>对象一旦定义后其值不可以再改变，<strong>因此<code>const</code>常量必须初始化</strong>，并且任何试图改变常量值的操作都会引发错误。</p>
<h4 id="const对象仅在文件内有效"><a href="#const对象仅在文件内有效" class="headerlink" title="const对象仅在文件内有效"></a><code>const</code>对象仅在文件内有效</h4><p>当编译<code>const</code>对象时，编译器将在编译过程中把用到该变量的地方都替换为对应的值。为了执行上述替换，编译器必须知道常量的初始值。如果程序包含多个文件，则在每一个用到变量的文件中都有它的定义。为了支持这一做法，并且避免对同一变量的重复定义，默认情况下， <strong><code>const</code>对象被设置为仅在当前文件有效</strong>，也就是说，当多个文件中出现了同名的<code>const</code>变量时，等同于在不同文件中分别定义了独立的变量。</p>
<p><strong>如果想在多个文件之间共享<code>const</code>对象，必须在变量的定义之前添加<code>extern</code>关键字</strong>。</p>
<h3 id="const与复合类型"><a href="#const与复合类型" class="headerlink" title="const与复合类型"></a><code>const</code>与复合类型</h3><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>可以把引用绑定到<code>const</code>对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span>&amp; ref = PI;</span><br><span class="line"><span class="comment">//	ref = 3.15; //Error 不能修改常量值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指向常量的指针-amp-指针常量"><a href="#指向常量的指针-amp-指针常量" class="headerlink" title="指向常量的指针&amp;指针常量"></a>指向常量的指针&amp;指针常量</h4><p>和引用不同，指针和指针指向的位置都是对象。<strong>指向常量的指针</strong>是指指针中储存的地址可以改变，但是指针指向的那片内存对应的是常量类型。而<strong>指针常量</strong>是指指针本身是一个常量，即存储地址的那片内存不可修改，然而该地址所指向的对象不一定是常量。</p>
<p>和复杂声明类似，区分两者的方法是从右向左阅读。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> cVal = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> CptrToVal = &amp;val;	<span class="comment">//指向int的常量指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* ptrToCval = &amp;cVal;	<span class="comment">//指向const int的指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> CptrToCval = &amp;cVal;	<span class="comment">//指向const int的常量指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对<code>const</code>的引用可能引用一个并非<code>const</code>的对象</h4><p>对于常量引用呵指向常量的指针来说，其<code>const</code>属性仅仅是对引用和指针的操作做出了限定，<strong>对于引用对象本身是不是一个常量未作限定</strong>。换句话说，指向常量的指针或引用，仅仅是引用和指针把其对象看作一个常量所以不去修改它，但是这个对象到底可以不可以修改则不确定。<strong>更简单地来说，可以将变量看作常量，但不可以把常量看作变量</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> fval = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; cref = val;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* cptr = &amp;val;	<span class="comment">//可以对变量做常量引用</span></span><br><span class="line"><span class="comment">//	cref = 3;	//但是不能通过cref修改val的值</span></span><br><span class="line"><span class="comment">//	double* ptr = &amp;fval;	//常量只能做常量引用或指向常量的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层<code>const</code>与底层<code>const</code></h3><p>对于指针来说，指针本身是一个对象，但是它又可以指向另外一个对象，因此，指针本身是不是常量（即是不是<strong>指针常量</strong>）以及指针所指的对象是不是一个常量（即是不是<strong>指向常量的指针</strong>）就是两个相互独立的问题。</p>
<p>我们用名词<strong>顶层<code>const</code>**表示指针本身是一个常量，用名词</strong>底层<code>const</code>**表示指针所指的对象是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cval = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr1 = &amp;cval;	<span class="comment">//底层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;val;		<span class="comment">//顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr3 = &amp;cval;	<span class="comment">//顶层const &amp; 底层const</span></span><br></pre></td></tr></table></figure>

<p>更一般地来说， 顶层<code>const</code>可以表示任意对象是常量，这一点对任何数据类型都适用，如算术类型、指针、类等；而底层<code>const</code>则与指针和引用等复合类型的基本类型部分有关。</p>
<h4 id="const与拷贝"><a href="#const与拷贝" class="headerlink" title="const与拷贝"></a><code>const</code>与拷贝</h4><p>当执行对象的拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显。</p>
<p>一方面，由于执行拷贝操作并不会改变被拷贝对象的值，因此<strong>顶层<code>const</code>对拷贝过程无影响</strong>。而另一方面，<strong>底层<code>const</code>的限制却不能忽略</strong>。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层<code>const</code>资格（或者两个对象的数据类型必须能够转换，一般来说，<strong>非常量可以转换为常量，反之则不行</strong>）。</p>
<h4 id="使用const简化参数传递"><a href="#使用const简化参数传递" class="headerlink" title="使用const简化参数传递"></a>使用<code>const</code>简化参数传递</h4><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。然而，对于较大的类类型对象，拷贝过程将非常低效，甚至有的类类型不支持拷贝操作。因此，<strong>在某些情况，我们需要通过引用形参访问该类型的对象</strong>。<font color="blue">【参考函数部分】</font></p>
<p>然而，如果将形参定义为引用，我们将不能向其中传递（字面值）常量（即使我们并无意修改形参的值）。例如下面的程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	function(3); 	//error:3不是一个可修改的左值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种常用的方法是定义重载函数，另一方面,利用<strong>非常量可以转换为常量</strong>的性质，<strong>当我们不需要修改形参的值（即不将其作为左值）时，我们也可以使用<code>const</code>简化参数传递</strong>。该方法常见于运算符重载中。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="built_in">string</span> str) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;The String is : &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	function(<span class="number">3</span>); 	<span class="comment">//Valid.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-constexpr和常量表达式"><a href="#2-6-constexpr和常量表达式" class="headerlink" title="2.6 constexpr和常量表达式"></a><strong>2.6 <code>constexpr</code>和常量表达式</strong></h2><p><strong>常量表达式</strong>是指值不会改变，并且在<strong>编译过程中</strong>就可以得到计算结果的表达式。显然，<strong>字面值属于常量表达式</strong>。</p>
<p>一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_FILES = getsize();</span><br><span class="line"><span class="keyword">int</span> LIMIT = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>

<p><code>MAX_FILES</code>和<code>LIMIT</code>均不是常量表达式。对于第一个，虽然该对象有<code>const</code>前缀，但是<code>getsize()</code>的返回值只有等到运行时才能获取到，所以不是常量表达式。对于第二个，虽然该对象的初始值是一个字面值常量，但由于它的数据类型只是一个普通<code>int</code>而非<code>const int</code>，所以也不属于常量表达式。</p>
<p>由于常量表达式的逻辑非常复杂，因此在一个复杂系统中，几乎不可能分辨出一个初始值到底是不是常量表达式。因此，C++11允许<strong>将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否为一个常量表达式</strong>。</p>
<p><strong>声明为<code>constexpr</code>的变量一定是一个常量，并且必须用常量表达式初始化</strong>。对于不符合要求的初始化的常量表达式（即编译器在编译过程中无法确定被定义为<code>constexpr</code>对象的值），编译器将在编译过程中报错。</p>
<p>同样，我们以可以将函数类型定义为<code>constexpr</code>。被定义为该类型的函数可以被用作初始化<code>constexpr</code>变量。但该函数的定义有很大的限制。<font color="blue">【参考函数部分】</font>例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">21</span>;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_FILES = getsize();</span><br></pre></td></tr></table></figure>

<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>常量表达式的值需要在编译时就得到计算，因此对声明<code>constexpr</code>时用到的类型必须有所限制。因为这些类型比较简单，值也显而易见，因此将其成为字面值类型。</p>
<p>**算术类型、引用、指针都属于字面值类型，（大部分）自定义类类型、IO库、<code>string</code>类型不属于字面值类型，也就不能被定义为<code>constexpr</code>**。</p>
<p><font color="blue">【还有一些其他特殊的类型属于字面值类型，参考字面值类类型和枚举类型部分】</font></p>
<h3 id="字面值类型与复合类型"><a href="#字面值类型与复合类型" class="headerlink" title="字面值类型与复合类型"></a>字面值类型与复合类型</h3><p>尽管指针和引用都可以被定义为<code>constexpr</code>，但是他们的初始值受到严格的限制。</p>
<p><code>constexpr</code>指针的初始值必须是**<code>nullptr</code>或者<code>0</code><strong>，或者是某个</strong>存储于固定地址中的对象**。</p>
<blockquote>
<p>函数体内部定义的变量一般来说存放于非固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反的，定义于所有函数体之外的对象的地址不变，因此可以指向这样的对象。此外，C++允许函数定义有效范围超出函数本身的变量，这些变量也有固定的地址。</p>
<p><font color="blue">【参考函数部分】</font></p>
</blockquote>
<h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和<code>constexpr</code></h4><p>在<code>constexpr</code>中如果声明了一个指针，限定符<code>constexpr</code>仅对指针有效，与指针所指对象无关。换句话说，**<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>**。与其他常量指针类似，<code>constexpr</code>指针既可以指向常量也可以指向一个非常量。如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">23</span>;	<span class="comment">//static参见函数部分</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> bVal = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span>* ptr = &amp;val;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">bool</span>* bPtr = &amp;bVal;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-处理类型"><a href="#2-7-处理类型" class="headerlink" title="2.7 处理类型"></a><strong>2.7 处理类型</strong></h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名是一个名字，它是某种类型的同义词，使用类型别名可以让复杂的类型名字变得简单明了、易于理解和使用。并且有助于程序员清楚地知道使用该类型的真实目的。有两种方法可以定义类型别名：</p>
<p><strong>使用关键字<code>typedef</code>定义类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* ptrToInt;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">23</span>;</span><br><span class="line">ptrToInt ptr = &amp;val;</span><br></pre></td></tr></table></figure>

<p><strong>使用别名声明定义类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Flag = <span class="keyword">bool</span>;</span><br><span class="line">Flag flg = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><p>类型别名区别于宏，简单地把类型别名替换成其本来的样子以理解该语句会导致错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的代码里面，<code>cptr</code>和<code>ptr</code>的类型并不相同。看起来将<code>pstring</code>直接替换为<code>char *</code>非常合适，但是在替换之后，<code>*</code>从原来的类型名的一部分变成了变量说明符。换句话说，<code>cptr</code>前的<code>const</code>修饰的是<code>pstring</code>，即修饰的时<code>char*</code>，而<code>ptr</code>前的<code>const</code>修饰的是<code>char</code>。因此，<code>cptr</code>是常量指针，而<code>ptr</code>是指向常量的指针变量。如果要借助类型别名定义指向常量的指针，应该参考下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span>* pstring;</span><br><span class="line">pstring cptr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a><code>auto</code>类型说明符</h3><p><font color="blue">【<code>auto</code>类型说明符作用于数组类型见数组部分】</font></p>
<p>一些变量的类型非常复杂，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator x = vec.begin();</span><br><span class="line"><span class="keyword">ptrdiff_t</span> dif = vec.end() - vec.begin();</span><br></pre></td></tr></table></figure>

<p>并且在复杂程序中，判断一个变量的类型并不是一件轻松的事情。为了解决这个问题，C++11引入了<code>auto</code>类型说明符，它能够让编译器替我们去分析表达式所属的类型。<code>auto</code>让编译器<strong>通过初始值来推算变量的类型</strong>，因此，**<code>auto</code>定义的变量必须有初始值，并且一条声明语句中所有变量的初始值的基本数据类型应该都相同**。</p>
<h4 id="推断规则"><a href="#推断规则" class="headerlink" title="推断规则"></a>推断规则</h4><p>编译器推断出来的<code>auto</code>类型和初始值往往不完全相同。编译器会适当地改变结果类型使其更符合初始化规则。</p>
<ol>
<li><p>使用引用其实是使用引用的对象，因此，<strong>当引用被作为初始值时，<code>auto</code>将依照被引用对象的类型推断</strong>。为了声明引用类型，可以利用说明符。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>, &amp; ref = val;</span><br><span class="line"><span class="keyword">auto</span> i = ref;	<span class="comment">//i的类型为int</span></span><br><span class="line"><span class="keyword">auto</span>&amp; k = ref;	<span class="comment">//k的类型为int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto</code>一般<strong>会忽略顶层<code>const</code>**，但是</strong>会保留底层<code>const</code>**。如果希望推断出的是一个顶层<code>const</code>，则需要明确指出。例如下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> cptr = &amp;val;</span><br><span class="line"><span class="keyword">auto</span> i = cptr;	<span class="comment">//i的类型为int*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> k = cptr;	<span class="comment">//k的类型为int* const</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a><code>decltype</code>类型指示符</h3><p><font color="blue">【<code>decltype</code>类型指示符作用于数组类型见数组部分】</font></p>
<p>如果我们希望从表达式的类型推断出要定义的新的变量的类型，但是不想用该表达式的值初始化变量，我们可以使用类型说明符<code>decltype</code>。它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式的值并得到他的类型，但是不实际计算表达式的值。其用法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">decltype</span>(isValid()) flag = <span class="literal">false</span>;	<span class="comment">//flag的类型为bool</span></span><br></pre></td></tr></table></figure>

<h4 id="推断规则-1"><a href="#推断规则-1" class="headerlink" title="推断规则"></a>推断规则</h4><p><code>decltype</code>类型说明符的推断规则比较复杂。</p>
<ul>
<li>如果<code>decltype</code>使用的表达式是一个变量，则<strong>其返回类型和该变量完全相同（包括引用和顶层<code>const</code>，这一点和<code>auto</code>不同）</strong>。</li>
<li>如果<code>decltype</code>使用的表达式是一个变量，<strong>但是给变量加上了一层或多层括号，则其返回类型会得到引用</strong>。</li>
</ul>
<p>见下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cval = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr1 = &amp;cval;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ptr3 = ptr1;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; cref = cval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(val) x1;	<span class="comment">/*int */</span>					<span class="keyword">decltype</span>((val)) k1 = val;	<span class="comment">/*int&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(cval) x2 = <span class="number">1</span>;	<span class="comment">/*const int */</span>			<span class="keyword">decltype</span>((cval)) k2 = cval;	<span class="comment">/*const int&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr1) x3;	<span class="comment">/*const int* */</span>				<span class="keyword">decltype</span>((ptr1)) k3;	<span class="comment">/*const int*&amp; */</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr2) x4 = <span class="literal">nullptr</span>;	<span class="comment">/*int* const */</span>	<span class="keyword">decltype</span>((ptr2)) k4 = x4;	<span class="comment">/*int* const */</span></span><br><span class="line"><span class="keyword">decltype</span>(ref) x5 = val; <span class="comment">/*int&amp; */</span>				<span class="keyword">decltype</span>((ref)) k5 = val; <span class="comment">/*int&amp; 引用的引用还是引用*/</span></span><br><span class="line"><span class="keyword">decltype</span>(cref) x6 = cval;	<span class="comment">/*const int&amp; */</span>		<span class="keyword">decltype</span>((cref)) k6 = cval;	<span class="comment">/*const int&amp; 引用的引用还是引用*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>decltype</code>使用的表达式不是一个变量，则其返回对象的类型与表达式返回的类型是相同的，而<strong>是否添加引用取决于该表达式返回的值能否作为一条赋值语句的左值</strong><font color="blue">【参考函数部分和表达式部分】</font>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, * p = &amp;i, &amp; r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;	<span class="comment">//int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i;	<span class="comment">//int&amp;</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>r</code>是一个引用，但是由于<code>r+0</code>返回的值是 <code>int</code>，并且该值不可做为左值，因此<code>b</code>的类型为<code>int</code>。</p>
<p>相反，虽然<code>*p</code>的类型为<code>int</code>，但是由于<code>*p</code>可以作为左值，因此<code>c</code>的类型为<code>int&amp;</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++ REFERENCE</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++ REFERENCE</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的应用——二叉搜索树</title>
    <url>/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p><strong>在数据存储过程中，为了满足高效的插入、删除以及检索功能，需要用到二叉搜索树这一数据结构。</strong></p>
<p>二叉搜索树是一种满足以下属性的特殊的二叉树：<strong>二叉搜索树中每个非空结点表示一个记录，若某节点左子树不为空，则左子树上所有结点的值均小于该结点的关键码值；若其右子树不为空，则右子树上所有结点的值均大于该结点的关键码值。</strong></p>
<p>简单地说，二叉搜索树在理想情况下递归地将数据分为左右两部分，在搜索过程中，每次比较可以将所搜范围减少一半。</p>
<a id="more"></a>

<h1 id="二叉搜索树相关操作"><a href="#二叉搜索树相关操作" class="headerlink" title="二叉搜索树相关操作"></a>二叉搜索树相关操作</h1><p>本文假定二叉搜索树的结点数据定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br></pre></td></tr></table></figure>



<h2 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h2><p>通常在考虑元素的插入时要额外判断是否插入的是根节点。<strong>如果是根节点，则直接创建根节点即可</strong>。</p>
<p>如果不是根节点，设待插入结点的关键码为<code>val</code>。引入一个辅助变量<code>cur</code>，从根结点开始，进入循环，判断：</p>
<ul>
<li>如果<code>cur-&gt;value == val</code>，则说明插入元素已经存在，则抛出异常。</li>
<li>如果<code>cur-&gt;value &gt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明插入元素应该在当前结点的左子树中。因此<code>cur = cur-&gt;left</code>。</li>
<li>如果<code>cur-&gt;value &lt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明插入元素应该在当前结点的右子树中。因此<code>cur = cur-&gt;right</code>。</li>
</ul>
<p>如果在上面的后两个判断条件中，出现了<code>cur-&gt;left</code>或者<code>cur-&gt;right</code>为<code>nullptr</code>，则退出循环。此时，<code>cur-&gt;left</code>（或者<code>cur-&gt;right</code>）即为待插入的位置。</p>
<p>插入元素的代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search_tree::insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">		root-&gt;value = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Repeating Element Error.&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val &amp;&amp; cur-&gt;left) &#123;</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &lt; val &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur-&gt;left = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">else</span>		cur-&gt;right = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的检索"><a href="#元素的检索" class="headerlink" title="元素的检索"></a>元素的检索</h2><p>检索元素引入辅助变量<code>cur</code>，从根节点开始循环，判断：</p>
<ul>
<li>如果<code>cur-&gt;value == val</code>，则查找结束，返回结果。</li>
<li>如果<code>cur-&gt;value &gt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明待查找元素应该在当前结点的左子树中。因此<code>cur = cur-&gt;left</code>。</li>
<li>如果<code>cur-&gt;value &lt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明待查找元素应该在当前结点的右子树中。因此<code>cur = cur-&gt;right</code>。</li>
</ul>
<p>如果在上面的后两个判断条件中，出现了<code>cur-&gt;left</code>或者<code>cur-&gt;right</code>为<code>nullptr</code>，则说明待查找元素不在搜索树中。因此退出循环。</p>
<p><strong>实际上元素插入和元素删除实质是等价的，如果查找一个元素失败，则失败的位置就可以插入这个元素。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur = cur-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; val)	cur = cur-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><p>二叉搜索树的结点删除算法思想为：<strong>如果待删除结点<code>pos</code>没有左子树，则用其右子树的根节点代替该结点。若有左子树，则在左子树中找到最大的一个结点（设为<code>rep</code>），将<code>rep</code>和<code>pos</code>结点交换，并删除<code>rep</code>。</strong></p>
<p>删除元素的逻辑比较复杂，有很多情况需要考虑。下面进行详细的说明。</p>
<p>在删除函数中，我们<strong>一共引入了四个辅助变量，分别为<code>toDel</code>、<code>father_toDel</code>、<code>replace</code>、<code>father_replace</code>，分别表示待删除结点指针、待删除结点的父节点指针（如果待删除结点为<code>root</code>，则<code>father_toDel == nullptr</code>）、待替换结点指针（如果需要）和待替换结点的父节点指针（如果需要）</strong>。    </p>
<ul>
<li><strong>首先函数根据关键码在二叉搜索树中查找待删除的结点<code>toDel</code>，并在向下搜索的过程中保存<code>father_toDel</code>（初始化<code>father_toDel == nullptr</code>）。如果没有找到，则返回<code>false</code>。</strong></li>
</ul>
<p>删除结点需要分为两种情况考虑。</p>
<p><strong>Situation 1</strong></p>
<ul>
<li><strong>如果该结点的左子树不为空，则需要在左子树中找到一个最大的替换结点<code>replace</code>。</strong>寻找方法是首先进入左子树**(即<code>replace = toDel-&gt;left, father_replace = toDel</code>)<strong>，之后不断向当前结点的右子树深入，直到当前节点的右子树为空。</strong>在搜索过程中，更新<code>father_replace</code>使其始终为<code>toDel</code>的父节点**。<ul>
<li>之后，分析一下我们的思路。我们需要做的是将<code>replace</code>和<code>toDel</code>互换。之后将替换后的<code>toDel</code>删除。</li>
</ul>
</li>
<li>我们按照顺序做如下的操作：<ol>
<li>将<code>father_replace</code>和<code>replace</code>的连接断开，并将<code>father_replace</code>和<code>replace-&gt;left</code>连接上（**即<code>father_replace-&gt;left/right = replace-&gt;left</code>**）。（我们可以断定<code>replace</code>右子树一定为空。否则在查找替换结点的过程中一定会进入该右子树）。【到这一步，我们将<code>replace</code>从二叉搜索树中抽出来（并保持其他的结构不变）】</li>
<li>之后，我们将抽出的<code>replace</code>结点插到<code>father_toDel</code>的子树上。<strong>这里需要考虑<code>father_toDel</code>为空的情况。此时，需要删除的结点即为<code>root</code>，这种情况我们只需要将<code>root = replace</code>即可。</strong>如果<code>father_toDel</code>不为空，则令<code>father_toDel-&gt;left/right = replace</code>。</li>
<li>之后，**<code>replace</code>将继承<code>toDel</code>的左右子树**。即<code>replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right</code>。</li>
<li>最后，删除<code>toDel</code>即可。</li>
</ol>
</li>
</ul>
<p><strong>总结一下，我们的思路是将<code>replace</code>从原位置抽出来（保持其他结构不变），插入到<code>toDel</code>的位置，并继承<code>toDel</code>的左右子树，完成替换。</strong></p>
<p><strong>Situation 2</strong></p>
<p>如果该子树的左结点为空，则我们仅需要<strong>用右子树的根节点代替当前结点即可</strong>。在这里，我们同样需要考虑<code>father_toDel</code>为空的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::erase</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree toDel = root, father_toDel = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (toDel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value == val)	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &gt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;left;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &lt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!toDel)		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDel-&gt;left) &#123;</span><br><span class="line">		Tree replace = toDel-&gt;left, father_replace = toDel;</span><br><span class="line">		<span class="keyword">while</span> (replace-&gt;right)</span><br><span class="line">			father_replace = replace, replace = replace-&gt;right;</span><br><span class="line">	</span><br><span class="line">		(father_replace-&gt;left == replace ? father_replace-&gt;left : father_replace-&gt;right) = replace-&gt;left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)</span><br><span class="line">			root = replace;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = replace;</span><br><span class="line"></span><br><span class="line">		replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;		<span class="comment">//if toDel-&gt;left == nullptr</span></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)	</span><br><span class="line">			root = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">else</span>	 </span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = toDel-&gt;right;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>最后给出完整的C++代码实现。</p>
<p><code>binary_search_tree.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARY_SEARCH_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SEARCH_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_search_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Tree root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	binary_search_tree();</span><br><span class="line">	binary_search_tree(<span class="keyword">int</span>* _Arr, <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	~binary_search_tree();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !BINARY_SEARCH_TREE_H</span></span></span><br></pre></td></tr></table></figure>

<p><code>binary_search_tree.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binary_search_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">binary_search_tree::binary_search_tree()</span><br><span class="line">&#123;</span><br><span class="line">	root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binary_search_tree::binary_search_tree(<span class="keyword">int</span>* _Arr, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		insert(_Arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search_tree::insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">		root-&gt;value = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Repeating Element Error.&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val &amp;&amp; cur-&gt;left) &#123;</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &lt; val &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur-&gt;left = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">else</span>		cur-&gt;right = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur = cur-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; val)	cur = cur-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::erase</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree toDel = root, father_toDel = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (toDel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value == val)	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &gt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;left;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &lt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!toDel)		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDel-&gt;left) &#123;</span><br><span class="line">		Tree replace = toDel-&gt;left, father_replace = toDel;</span><br><span class="line">		<span class="keyword">while</span> (replace-&gt;right)</span><br><span class="line">			father_replace = replace, replace = replace-&gt;right;</span><br><span class="line">	</span><br><span class="line">		(father_replace-&gt;left == replace ? father_replace-&gt;left : father_replace-&gt;right) = replace-&gt;left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)</span><br><span class="line">			root = replace;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = replace;</span><br><span class="line"></span><br><span class="line">		replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;		<span class="comment">//if toDel-&gt;left == nullptr</span></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)	</span><br><span class="line">			root = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">else</span>	 </span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = toDel-&gt;right;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binary_search_tree::~binary_search_tree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Tree&gt; que;</span><br><span class="line">	<span class="keyword">if</span> (root)		que.push(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">		Tree cur = que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;left)	que.push(cur-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;right)	que.push(cur-&gt;right);</span><br><span class="line">		<span class="keyword">delete</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>DATA STRUCTURE</category>
        <category>TREE &amp; GRAPH</category>
      </categories>
      <tags>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的应用——堆与优先队列</title>
    <url>/2020/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>在现实应用中，经常会遇到频繁地在一组对象中查找最大值和最小值的情况。</strong>堆可以为这样的操作提供更加高效的算法。</p>
<p>最小堆（min-heap，最大堆类似）是关键码序列${K_0,K_1,…,K_{n-1}}$，它具有如下的性质：<br>$$<br>K_i\leq K_{2i+1}， \<br>K_i \leq K_{2i+2} \space \space(i=0,1,…,\lfloor n/2 \rfloor-1)<br>$$<br>通俗地说，最小堆是一棵二叉树，其根节点为整个序列中关键码最小的元素。并且对于任意一个结点来说，其父节点一定小于该结点，其左右子结点一定大于该结点。换言之，从根节点到所有叶结点的路径都是一个单调不减序列。</p>
<p>从形式上来说，<strong>堆属于完全二叉树</strong>，因此虽然是一种树形结构，我们仍然可以使用使用（顺序表）存储。</p>
<a id="more"></a>

<p>在引入堆之前，首先引入一些和完全二叉树有关的性质。</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>如果按照层次顺序将一棵有$n$个结点的完全二叉树中的所有节点<strong>从$0$到$n-1$进行编号</strong>，并将其存储在一个顺序表（如数组）中。则有如下性质。</p>
<ul>
<li>对于任意一个二叉树结点，<strong>如果它存储在数组下标为$i$的位置，那么它的父节点下标为$\lfloor (i-1)/2 \rfloor$，它的左子结点下标为$2i+1$，它的右子结点下标为$2i+2$。</strong></li>
<li>二叉树中非叶子结点（即有左子树或者左右子树的结点）的个数为$\lfloor n/2 \rfloor$。换言之，<strong>如果$i \geq \lfloor n/2 \rfloor$，则说明该结点为叶子结点</strong>。</li>
</ul>
<blockquote>
<p>对于第二条性质的证明，需要如下引理：</p>
<ul>
<li>对于一棵满二叉树来说（即结点的度要不为0，要不为2），其叶结点数目$n_0$等于其分分支结点树$n_2$加1.</li>
</ul>
<p>对于完全二叉树来说，只有两种情况：</p>
<ol>
<li>如果$n=2k$，则在其最后补充一个结点，使得$n+1=2k+1$，则该完全二叉树被扩充为一个满二叉树。此时，有$2k+1=n_0+n_2=2n_2+1$，即得到$n_2=k$。</li>
<li>如果$n=2k+1$，则该二叉树本身就构成一个满二叉树。同样地，可以得到$n_2=k$。</li>
</ol>
<p>综上，$n_2=\lfloor n/2 \rfloor$.</p>
</blockquote>
<h1 id="（最小）堆"><a href="#（最小）堆" class="headerlink" title="（最小）堆"></a>（最小）堆</h1><h2 id="adjust-函数"><a href="#adjust-函数" class="headerlink" title="adjust()函数"></a><code>adjust()</code>函数</h2><p>构建堆最关键的一个函数为<code>adjust</code>。该函数的参数为<code>adjust(size_t node_index)</code>。其目的是<strong>在假定除结点<code>node_index</code>外的其他部分都符合堆的性质的情况下，单独调整下标为<code>node_index</code>的结点使该结点也符合堆的性质</strong>。</p>
<p>该函数其分为向上调整函数<code>adjust_up</code>和向下调整函数<code>adjust_down</code>。</p>
<ul>
<li>对于向上调整函数来说，其仅考虑以该结点为叶子结点的子树。<strong>并且该结点是该堆中唯一一个不满足堆的性质的结点（即该节点的关键码值小于其父节点的关键码值</strong>。此时，需要将该结点在该子树上向上移动。最后，<strong>该函数达到的效果是其保证了以该结点为叶结点的子树满足堆的性质</strong>。</li>
<li>对于向上调整函数来说，其仅考虑以该结点为叶根节点的子树。<strong>并且该结点是该堆中唯一一个不满足堆的性质的结点（即该节点的关键码值大于其左右节点的关键码值</strong>。此时，需要将该结点在该子树上向下移动。最后，<strong>该函数达到的效果是其保证了以该结点为根结点的子树满足堆的性质</strong>。</li>
</ul>
<p>调整函数<strong>使用迭代的方式</strong>依次将结点向上（或下）移动，即<strong>在循环中不断判断当前结点是否符合堆的性质，如果符合，则退出循环，否则，继续调整。</strong>实现代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::adjust(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= vec.size())		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">		<span class="keyword">while</span> (index &amp;&amp; vec[FATHER(index)] &gt; vec[index] ) &#123;</span><br><span class="line">			swap(vec[FATHER(index)], vec[index]);</span><br><span class="line">			index = FATHER(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (LEFTC(index) &lt; vec.size()) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> left_child = LEFTC(index), rihgt_child = RIGHTC(index);</span><br><span class="line">			<span class="keyword">size_t</span> prob;</span><br><span class="line">			<span class="keyword">if</span> (rihgt_child &gt;= vec.size())		</span><br><span class="line">				prob = left_child;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				prob = vec[left_child] &lt;= vec[rihgt_child] ? left_child : rihgt_child;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vec[index] &gt; vec[prob]) &#123;</span><br><span class="line">				swap(vec[index], vec[prob]);</span><br><span class="line">				index = prob;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆的构建"><a href="#堆的构建" class="headerlink" title="堆的构建"></a>堆的构建</h2><p>在有<code>adjust()</code>函数的条件下，我们思考如何根据给定的序列构建一个堆。</p>
<p>首先，将所有序列放到一个一维数组中，此时形成的完全二叉树并不符合最小堆的特性。但是，<strong>所有的叶子结点所构成的子树（由于之后一个结点）满足堆的性质</strong>。因此，如果我们最底层向最高层按下标顺序遍历非叶子结点，则会发现，当访问到任意一个结点时，其左右子树均满足堆的性质，因此该结点（如果不符合堆的性质）符合向下调整函数的条件，即<strong>通过向下调整函数可以将以该结点为根节点的子树调整为一个堆</strong>。</p>
<p>就这样逆序遍历所有的非叶结点直到根节点，并对每一个结点执行向下调整函数，就可以将整个完全二叉树构建为一个堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len)</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;(_Arr, _Arr + _Len);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (vec.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		adjust(i, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h2><p>首先将新的元素插入到数组的末尾。此时，以该新添加的结点为叶结点的子树满足向上调整的性质。因此，对该结点执行向上调整函数，即可保持整个堆的性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::insert(<span class="keyword">const</span> Tid&amp; _Value)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push_back(_Value);</span><br><span class="line">	adjust(vec.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><p>为了删除某一个元素，首先将该元素与数组末尾的元素进行交换。并将最后一个元素删除。此时，该结点（由于其关键码增加）可能会不满足堆的性质。如果不满足，以该结点为根节点的子树满足向下调整的性质。因此，对该结点执行向下调整函数即可保持整个堆的性质。</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>优先队列（priority-queue）是一种有用的数据结构。它是0个或者多个元素的集合，每个元素都有一个关键码值，执行的操作有查找、插入、删除等等。优先队列主要特点是可以快速查找并移出具有最小值（或者最大值）的元素。</p>
<p>堆是实现优先队列非常合适的数据结构。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>最后，给出最小值堆（优先队列）的完整C++实现代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_HEAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FATHER(ind) ((int(ind) - 1) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFTC(ind) ((ind &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHTC(ind)	 ((ind &lt;&lt; 1) + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myheap</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt; vec;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myheap();</span><br><span class="line">	myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> Tid&amp; _Value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Tid <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::adjust(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= vec.size())		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">		<span class="keyword">while</span> (index &amp;&amp; vec[FATHER(index)] &gt; vec[index] ) &#123;</span><br><span class="line">			swap(vec[FATHER(index)], vec[index]);</span><br><span class="line">			index = FATHER(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (LEFTC(index) &lt; vec.size()) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> left_child = LEFTC(index), rihgt_child = RIGHTC(index);</span><br><span class="line">			<span class="keyword">size_t</span> prob;</span><br><span class="line">			<span class="keyword">if</span> (rihgt_child &gt;= vec.size())		</span><br><span class="line">				prob = left_child;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				prob = vec[left_child] &lt;= vec[rihgt_child] ? left_child : rihgt_child;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vec[index] &gt; vec[prob]) &#123;</span><br><span class="line">				swap(vec[index], vec[prob]);</span><br><span class="line">				index = prob;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap()</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len)</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;(_Arr, _Arr + _Len);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (vec.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		adjust(i, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : vec)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::insert(<span class="keyword">const</span> Tid&amp; _Value)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push_back(_Value);</span><br><span class="line">	adjust(vec.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> myheap&lt;Tid&gt;::is_empty()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec.size() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> myheap&lt;Tid&gt;::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">Tid myheap&lt;Tid&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	erase(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MY_HEAP_H</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>DATA STRUCTURE</category>
        <category>TREE &amp; GRAPH</category>
      </categories>
      <tags>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF密码学中RSA问题总结</title>
    <url>/2020/12/26/CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%ADRSA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>本文汇总CTF密码学中和RSA问题相关的问题。</strong></p>
<a id="more"></a>



<h1 id="RSA简介"><a href="#RSA简介" class="headerlink" title="RSA简介"></a>RSA简介</h1><p>RSA算法的具体描述如下：</p>
<ul>
<li>任意选择两个不同的大素数$p$和$q$，计算$n=pq$和$\phi(n)=(p-1)(q-1)$。</li>
<li>任意选择一个整数$e$，满足$gcd(e,\phi(n))=1$。</li>
<li>计算$d=e^{-1}(mod \space \phi(n))$。</li>
<li>公布公钥$(e,n)$，保存私钥$(d,n)$。</li>
</ul>
<p>（使用公钥）将明文$m(m&lt;n)$加密成密文$c$的加密算法为：<br>$$<br>c=E(m)=m^e(mod \space n)<br>$$</p>
<p>（使用私钥）将密文$c$解密的解密算法为：<br>$$<br>m=D(c)=c^d(mod \space n)<br>$$</p>
<h1 id="和RSA算法有关的Python-Libraries和Tools"><a href="#和RSA算法有关的Python-Libraries和Tools" class="headerlink" title="和RSA算法有关的Python Libraries和Tools"></a>和RSA算法有关的Python Libraries和Tools</h1><p><strong>利用Python中的库<a href="https://www.pycryptodome.org/en/latest/index.html">Crypto.Util.number</a>中的<code>long_to_bytes</code>、<code>bytes_to_long</code>函数可以进行<code>bytes</code>类型和<code>int</code>类型的互换</strong>。</p>
<p>使用方法：</p>
<p> <a href="https://www.programcreek.com/python/index/1372/Crypto.Util.number">https://www.programcreek.com/python/index/1372/Crypto.Util.number</a></p>
<p><strong>Python中的库<a href="https://gmpy2.readthedocs.io/en/latest/index.html">gmpy2</a>可以进行包括扩展欧几里得、求逆、求<code>x</code>次方根等常见的操作。</strong></p>
<p>使用方法：</p>
<p><a href="https://blog.csdn.net/qq_42250840/article/details/105153227">https://blog.csdn.net/qq_42250840/article/details/105153227</a></p>
<p><a href="https://vimsky.com/examples/detail/python-module-gmpy2.html">https://vimsky.com/examples/detail/python-module-gmpy2.html</a></p>
<p><strong>Python中的库<a href="https://github.com/hellman/libnum">libnum</a>集成了模运算、椭圆曲线运算等常见的操作。</strong></p>
<p><strong>常见的整数分解工具包括</strong></p>
<ul>
<li><p><strong><a href="https://sourceforge.net/projects/yafu/">Windows kafu</a>，使用命令<code>factor(N)</code>即可。</strong></p>
</li>
<li><p><strong>Python Library <a href="https://github.com/hellman/libnum">libnum</a>，使用命令<code>factorize(n)</code>即可（使用rho-Pollard method）。</strong></p>
</li>
</ul>
<h1 id="常见的攻击方法"><a href="#常见的攻击方法" class="headerlink" title="常见的攻击方法"></a>常见的攻击方法</h1><h2 id="暴力破解-N-pq"><a href="#暴力破解-N-pq" class="headerlink" title="暴力破解 $N=pq$"></a>暴力破解 $N=pq$</h2><p>如果题目中$n$较小，我们可以利用数学工具对$N$进行整数分解。</p>
<p><strong>有时候，将$N$进行整数分解后会得到三个或多个整数。</strong>可以根据如下定理</p>
<blockquote>
<p>设$m=p_1^{\alpha _1}p_2^{\alpha _2},…,p_r^{\alpha _r}$，其中$p_1,p_2,…,p_r$为不同的素因 子，则<br>$$<br>\phi(m)=\phi(p_1^{\alpha _1})\phi(p_2^{\alpha _2})…\phi(p_r^{\alpha _r})=p_1^{\alpha _1-1}(p_1-1)p_2^{\alpha _2-1}(p_2 -1)…p_r^{\alpha _r-1}(p_r -1)<br>$$</p>
</blockquote>
<p>计算出$\phi(N)$。</p>
<p>例如（CTF新生赛Crypto 2）：</p>
<blockquote>
<p>c=67692316911846383515666937548215377516026242122014572162117994514425606283681<br>N=103461035900816914121390101299049044413950405173712170434161686539878160984549<br>e=65537</p>
</blockquote>
<p>首先使用kafu计算出N的整数分解。</p>
<img src="/2020/12/26/CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%ADRSA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20201228090323794.png" alt="image-20201228090323794" style="zoom: 67%;">

<p>得到<br>$$<br>p=366669102002966856876605669837014229419, q=282164587459512124844245113950593348271<br>$$<br>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">c = <span class="number">67692316911846383515666937548215377516026242122014572162117994514425606283681</span></span><br><span class="line">N = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">q = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line"></span><br><span class="line">d = libnum.invmod(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, N)</span><br><span class="line">print(long_to_bytes(m).decode())</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;hello_hash_team&#125;</code>。</p>
<h2 id="RSA共模攻击"><a href="#RSA共模攻击" class="headerlink" title="RSA共模攻击"></a>RSA共模攻击</h2><p>在大多数情况下，$N$无法被有效地分解。此时，<strong>如果题目中出现了两对$(e_1,c_1),(e_2,c_2)$，并且有$gcd(e_1,e_2)=1$，则可以考虑使用RSA共模攻击</strong>。</p>
<p><strong>共模攻击原理</strong></p>
<p>由于$gcd(e_1,e_2)=1$，因此根据拓展欧几里得原理，可以得到唯一的$s_1,s_2$，使得<br>$$<br>e_1s_1+e_2s_2=1<br>$$<br>又由于<br>$$<br>c_1=m^{e_1}(mod \space n),\space c_2=m^{e_2}(mod\space n)<br>$$<br>可以得到<br>$$<br>c_1^{s_1}c_2^{s_2}=[m^{e_1}(mod \space n)]^{s_1}[m^{e_2}(mod \space n)]^{s_2}(mod \space n)<br>$$<br>根据同余性质和幂运算性质，可以得到<br>$$<br>c_1^{s_1}c_2^{s_2}=(m^{e_1})^{s_1}(m^{e_2})^{s_2}(mod \space n)=m^{e_1s_1+e_2s_2}(mod \space n)<br>$$<br>因此<br>$$<br>c_1^{s_1}c_2^{s_2}=m^1(mod \space n)=m(mod n)<br>$$</p>
<p><strong>利用共模攻击，可以在不求出$d$的情况下（即不需要分解大整数$N$）将$m$计算出来</strong>。</p>
<p>例如（CTF新生赛Crypto 3）：</p>
<blockquote>
<p>n = 0xa1d4d377001f1b8d5b2740514ce699b49dc8a02f12df9a960e80e2a6ee13b7a97d9f508721e3dd7a6842c24ab25ab87d1132358de7c6c4cee3fb3ec9b7fd873626bd0251d16912de1f0f1a2bba52b082339113ad1a262121db31db9ee1bf9f26023182acce8f84612bfeb075803cf610f27b7b16147f7d29cc3fd463df7ea31ca860d59aae5506479c76206603de54044e7b778e21082c4c4da795d39dc2b9c0589e577a773133c89fa8e3a4bd047b8e7d6da0d9a0d8a3c1a3607ce983deb350e1c649725cccb0e9d756fc3107dd4352aa18c45a65bab7772a4c5aef7020a1e67e6085cc125d9fc042d96489a08d885f448ece8f7f254067dfff0c4e72a63557L<br>e1 = 0xf4c1158fL<br>c1 = 12051796366524088489284445109295502686341498426965277230069915294159131976231473789977279364263965099422235647723775278060569378071469131866368399394772898224166518089593340803913798327451963589996734323497943301819051718709807518655868569656941242449109980876397661605271517459716669684900920279597477446629607627693769738733623143693170696779851882404994923673483971528314806130892416509854017091137325195201225617407959645788145876202882024723106204183257094755002924708009138560347432552090905489132135154932987521239299578509008290614398700799670928805692609756924823628055245227290288940649158862576448537833423L<br>e2 = 0xf493f7d1L<br>c2 = 16648382384980770705624348910895797622774711113202207693584907182552301186239613809347201161450012615995859738410661452438496756353485538305614949211776668793864984429696790944750894691957799234264508530084026894611228513698963347402329109838109621609770406925700520983387811451074838470370044678634099202003480925903267508744006195455234025325060817223813858985074720872124168142943926467694676717713503559007112874381750005406371400109962943508349497151148446064846096531445037416174913915923050332242843403926133165817310272633884358263778516770288515592959832151762499526363131801945163501999337808208074381212795L</p>
</blockquote>
<p>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0xa1d4d377001f1b8d5b2740514ce699b49dc8a02f12df9a960e80e2a6ee13b7a97d9f508721e3dd7a6842c24ab25ab87d1132358de7c6c4cee3fb3ec9b7fd873626bd0251d16912de1f0f1a2bba52b082339113ad1a262121db31db9ee1bf9f26023182acce8f84612bfeb075803cf610f27b7b16147f7d29cc3fd463df7ea31ca860d59aae5506479c76206603de54044e7b778e21082c4c4da795d39dc2b9c0589e577a773133c89fa8e3a4bd047b8e7d6da0d9a0d8a3c1a3607ce983deb350e1c649725cccb0e9d756fc3107dd4352aa18c45a65bab7772a4c5aef7020a1e67e6085cc125d9fc042d96489a08d885f448ece8f7f254067dfff0c4e72a63557</span></span><br><span class="line">e1 = <span class="number">0xf4c1158f</span></span><br><span class="line">c1 = <span class="number">12051796366524088489284445109295502686341498426965277230069915294159131976231473789977279364263965099422235647723775278060569378071469131866368399394772898224166518089593340803913798327451963589996734323497943301819051718709807518655868569656941242449109980876397661605271517459716669684900920279597477446629607627693769738733623143693170696779851882404994923673483971528314806130892416509854017091137325195201225617407959645788145876202882024723106204183257094755002924708009138560347432552090905489132135154932987521239299578509008290614398700799670928805692609756924823628055245227290288940649158862576448537833423</span></span><br><span class="line">e2 = <span class="number">0xf493f7d1</span></span><br><span class="line">c2 = <span class="number">16648382384980770705624348910895797622774711113202207693584907182552301186239613809347201161450012615995859738410661452438496756353485538305614949211776668793864984429696790944750894691957799234264508530084026894611228513698963347402329109838109621609770406925700520983387811451074838470370044678634099202003480925903267508744006195455234025325060817223813858985074720872124168142943926467694676717713503559007112874381750005406371400109962943508349497151148446064846096531445037416174913915923050332242843403926133165817310272633884358263778516770288515592959832151762499526363131801945163501999337808208074381212795</span></span><br><span class="line"></span><br><span class="line">s1, s2, g = libnum.xgcd(e1, e2)</span><br><span class="line"><span class="keyword">assert</span> g == <span class="number">1</span>, <span class="string">&quot;gcd(e1, e2) is not 1&quot;</span></span><br><span class="line"></span><br><span class="line">ans = (<span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n)) % n</span><br><span class="line">print(long_to_bytes(ans).decode())</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;8c16c91be3f3287ff5a10167e922b33b&#125;</code>。</p>
<h2 id="低加密指数分解攻击"><a href="#低加密指数分解攻击" class="headerlink" title="低加密指数分解攻击"></a>低加密指数分解攻击</h2><p><strong>在 RSA 中$ e $也称为加密指数。由于$ e $是可以随意选取的，选取小一点的$ e $可以缩短加密时间，但是选取不当的话，就会造成安全问题。</strong></p>
<p>由于（使用公钥）将明文$m(m&lt;n)$加密成密文$c$的加密算法为：<br>$$<br>c=E(m)=m^e(mod \space n)<br>$$<br>因此，当$e$过小时，例如$e=2,e=3$，就会有<br>$$<br>m^e=c+kn(k=0,1,…)<br>$$<br>即，<strong>RSA问题转换为了求$c+kn(k=…,-1,0,1,…)$的二次方根或者三次方根问题。和大整数分解问题相比，该算法的时间复杂度非常低，因此可以利用这种方法获得$m$。</strong></p>
<p>例如（CTF训练赛Crypto 2）：</p>
<blockquote>
<p>n =     0x504422886880999134164106129232979493447288711838128518343366212225318903644618300817499198750840212643148846352592538512783005736164297583799147064883313355294028416687642306709706943887551457028035973777229371815062651312421640647068096189113496379135101287943752591797440940734536167859259186040466011910888475712958297303535087426800506564240900638884432216737231731773972981109497611446103590015141017384041792747752222369077462487716099140258216028669719577413647641486036733175734648934918607792606929986333056819301666536526344527151782292255144358594370104124433857693900000227671975512733846188265519758430055649020007978758166309930265697614982513218273073454928983660048528331097010828958096468299776488744993182315936148627876851809422331280471073551417956563668197068676126722734534188127471611402864677938887115908916553544845110143563736559450970252229445667691496767868123951081712872604935508183737147849971835008184807472987711316180320099624812832405397468923025162496735247263616654895797084799784974584932678025655358910480843010221725985491740823985360121695310692419773463141212113933823487148306326402421665145808422963033346161969635009951581265915013730077344870284008003690168143322781170105437085918993663<br>c = 0x10652CDFAA8D984F5B582D65A9357ADA464CA4E9BF0C3914A5AD2DC291D9EC8310E9BFF83E4B0545B61806A4FC0DAC3FCA5A0917D98052320317208292B6F4B472AA032D4E48CFFEAFF387A44F7FCDD91DC103BB2B9C66FFA987C4A3E038F65C46CC66A00965<br>e = 3</p>
</blockquote>
<p>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0x504422886880999134164106129232979493447288711838128518343366212225318903644618300817499198750840212643148846352592538512783005736164297583799147064883313355294028416687642306709706943887551457028035973777229371815062651312421640647068096189113496379135101287943752591797440940734536167859259186040466011910888475712958297303535087426800506564240900638884432216737231731773972981109497611446103590015141017384041792747752222369077462487716099140258216028669719577413647641486036733175734648934918607792606929986333056819301666536526344527151782292255144358594370104124433857693900000227671975512733846188265519758430055649020007978758166309930265697614982513218273073454928983660048528331097010828958096468299776488744993182315936148627876851809422331280471073551417956563668197068676126722734534188127471611402864677938887115908916553544845110143563736559450970252229445667691496767868123951081712872604935508183737147849971835008184807472987711316180320099624812832405397468923025162496735247263616654895797084799784974584932678025655358910480843010221725985491740823985360121695310692419773463141212113933823487148306326402421665145808422963033346161969635009951581265915013730077344870284008003690168143322781170105437085918993663</span></span><br><span class="line">c = <span class="number">0x10652CDFAA8D984F5B582D65A9357ADA464CA4E9BF0C3914A5AD2DC291D9EC8310E9BFF83E4B0545B61806A4FC0DAC3FCA5A0917D98052320317208292B6F4B472AA032D4E48CFFEAFF387A44F7FCDD91DC103BB2B9C66FFA987C4A3E038F65C46CC66A00965</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">x = c</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg, istrue = gmpy2.iroot(gmpy2.mpz(x), (gmpy2.mpz(e)))</span><br><span class="line">    <span class="keyword">if</span>(istrue):</span><br><span class="line">        print(long_to_bytes(<span class="built_in">int</span>(msg)).decode())</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:   x += n</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;you_are_clever_than_i_thount&#125;</code>。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
        <category>MATHEMATICS &amp; ALGORITHM</category>
        <category>NUMBER THEORY &amp; CRYPTO &amp; CODING</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CRYPTO</tag>
        <tag>NUMBER THEORY &amp; CRYPTO &amp; CODING</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>树、森林的存储与访问</title>
    <url>/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>树的<strong>递归定义</strong>如下：</p>
<p>树是包括$n$个结点的有限集合，使得</p>
<ol>
<li>有且仅有一个特定的称为<strong>根（root）</strong>的结点。</li>
<li>除根以外的其他节点被分为$m(m\geq 0)$不相交的有限集合$T_1,T_2,…,T_m$，而每一个集合都是树。其中树$T_1,T_2,…,T_m$称作这个根的子树。</li>
</ol>
<p><strong>树的存储包括链式存储结构和顺序存储结构。</strong>由于计算机的存储是有序的，为方便处理，往往把子结点按照从左到右的次序顺序编号，即把树作为有序树（ordered tree）来看待。</p>
<p><strong>森林（forest）是零棵或者多颗不相交的树的集合。</strong></p>
<a id="more"></a>



<h1 id="一、树的逻辑表示方法"><a href="#一、树的逻辑表示方法" class="headerlink" title="一、树的逻辑表示方法"></a>一、树的逻辑表示方法</h1><p><strong>树的逻辑表示方法包括树形表示法、凹入表示法、文氏图表示法、嵌套括号表示法</strong>。</p>
<p><strong>树形表示法是最直观，也最常用的树的逻辑表示方法</strong>。</p>
<img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/tree.jpg" alt="tree" style="zoom:50%;">

<p><strong>凹入表示法主要用于树的屏幕和打印机形式</strong>。例如，Windows上的文件夹管理即为一个凹入表示法。</p>
<img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201228202803676.png" alt="image-20201228202803676" style="zoom: 80%;">

<p><strong>文氏图表示法</strong></p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/960a304e251f95ca2e491195ca177f3e67095251.png" alt="960a304e251f95ca2e491195ca177f3e67095251"></p>
<p><strong>嵌套括号表示法</strong></p>
<p>例如对文氏图表示法表示的树来说，其嵌套括号表示法为<code>(A(B(E)D(H)C(F(I)G)))</code></p>
<h1 id="二、森林与二叉树的等价转换"><a href="#二、森林与二叉树的等价转换" class="headerlink" title="二、森林与二叉树的等价转换"></a>二、森林与二叉树的等价转换</h1><p>森林（或者树）与二叉树之间的转化是一一对应的（如果考虑每个结点的顺序的话）。<strong>首先给出森林（或树）与二叉树转换的步骤</strong>。</p>
<ul>
<li>如何从森林（或者树）转换到二叉树？</li>
</ul>
<blockquote>
<p>连线：将兄弟结点用线连起来。</p>
<p>切线：保留父结点与其第一个子结点的连线，将父结点到其他子结点的连线切掉。</p>
<p>旋转：以根为轴，平面向下顺时针方向旋转一定的角度。（旋转只是为了调整画面，使得转化后的二叉树看起来比较规整。）</p>
</blockquote>
<ul>
<li>如何从二叉树转化到森林？</li>
</ul>
<blockquote>
<p>旋转：以根为轴，平面逆时针方向旋转。</p>
<p>补线：如果结点A是父节点F的左子节点，则把A的所有右子结点（即不断向右子树深入直到叶节点）与F连接起来。</p>
<p>删线：去掉所有父节点到右子结点的连线。</p>
</blockquote>
<p><strong>实际上，森林到二叉树的转换是常见的左孩子右兄弟表示法，即对于任意一个节点来说，其所有右节点（即不断向右子树深入直到叶结点）在森林表示法中都是它的兄弟，而其左子结点是它的第一个子结点。</strong>关于这种表示法的详细讲解，可以参考 <a href="https://www.manongdao.com/article-1127144.html">https://www.manongdao.com/article-1127144.html</a> </p>
<img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/u=4047292885,2751585858&fm=26&gp=0.jpg" alt="u=4047292885,2751585858&fm=26&gp=0" style="zoom:67%;">

<h1 id="三、树的周游"><a href="#三、树的周游" class="headerlink" title="三、树的周游"></a>三、树的周游</h1><p><strong>树的周游分为深度优先周游和广度优先周游。</strong></p>
<h2 id="深度优先周游"><a href="#深度优先周游" class="headerlink" title="深度优先周游"></a>深度优先周游</h2><p><strong>类似于二叉树的周游，树的深度优先周游分为先根次序周游和后跟次序周游</strong>。</p>
<p>先根次序的递归化定义为，<strong>首先访问森林中第一棵树的根节点</strong>，<strong>再在先根次序下周游根节点的子结点构成的子树森林</strong>。<strong>最后在先根次序下周游其他的树构成的森林</strong>。</p>
<p>后根次序的递归化定义为，<strong>首先在后根次序下周游根节点的子结点构成的子树森林，再访问森林中第一棵树的根节点。最后在先根次序下周游其他的树构成的森林</strong>。</p>
<p><strong>先根次序周游森林的序列正好等同于其对应的二叉树的前序序列，而后跟次序周游森林的序列正好等同于其对应的二叉树的中序遍历。</strong></p>
<blockquote>
<p><strong>比较森林先根次序周游（后）和二叉树前序遍历（前）的递归定义</strong>：</p>
<ul>
<li>访问根节点【访问森林中第一棵树的根节点】</li>
<li>按照前序遍历左子树【先根次序下周游根节点的子结点构成的子树森林】</li>
<li>按照前序遍历右子树【在先根次序下周游其他的树构成的森林】</li>
</ul>
<p><strong>比较森林后根次序周游（后）和二叉树中序遍历（前）的递归定义：</strong></p>
<ul>
<li>按照中序遍历左子树【在后根次序下周游根节点的子结点构成的子树森林】</li>
<li>访问根节点【访问森林中第一棵树的根节点】</li>
<li>按照中序遍历右子树【在先根次序下周游其他的树构成的森林】</li>
</ul>
</blockquote>
<h2 id="广度优先周游"><a href="#广度优先周游" class="headerlink" title="广度优先周游"></a>广度优先周游</h2><p>广度优先周游也称层次周游。广度优先周游从树的第0层开始，自上而下逐层周游；在同一层中，按照从左到右的顺序逐一访问。</p>
<h1 id="四、树的存储结构"><a href="#四、树的存储结构" class="headerlink" title="四、树的存储结构"></a>四、树的存储结构</h1><p><strong>树的存储包括链式存储和顺序存储。</strong></p>
<h2 id="Ⅰ-链式存储结构"><a href="#Ⅰ-链式存储结构" class="headerlink" title="Ⅰ - 链式存储结构"></a>Ⅰ - 链式存储结构</h2><h3 id="（动态）“子结点表”表示法"><a href="#（动态）“子结点表”表示法" class="headerlink" title="（动态）“子结点表”表示法"></a>（动态）“子结点表”表示法</h3><p>“子结点表”表示法的<strong>主体是一个存储了树中各结点信息的数组，数组中的每个元素包括3个域，分别用来存放该结点的值、其父节点指针（或数组下标）以及指向其子结点表的指针</strong>。子结点表是指每个分支结点的子结点按照从左到右的顺序形成一个链表存储在该分支结点中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子结点表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> index;</span><br><span class="line">	ListNode* next_node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> cList = ListNode*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素（包含三个域）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	DataType data_value;</span><br><span class="line">	<span class="keyword">size_t</span>* father_index;</span><br><span class="line">	cList children_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储了树中各个结点信息的数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode&gt; node_arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="静态“左子右兄”表示法"><a href="#静态“左子右兄”表示法" class="headerlink" title="静态“左子右兄”表示法"></a>静态“左子右兄”表示法</h3><p>静态“左子右兄”表示法是对“子结点表”表示法的一个改进，使得访问结点的右侧兄弟结点更加方便，并且空间效率更高。</p>
<p>静态“左子右兄”表示法的主题仍然是一个存储各结点的的数组。数组的各个结点包含四个域，分别用于存储结点的值、指向其父节点的指针（或者下标）、指向其最左子结点和右侧（第一个）兄弟结点的指针（或者下标）。</p>
<p>例如对于森林</p>
<img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229110835648.png" alt="image-20201229110835648" style="zoom: 67%;">

<p>其表示为</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229111202001.png" alt="image-20201229111202001"></p>
<h3 id="动态“左子右兄”表示法"><a href="#动态“左子右兄”表示法" class="headerlink" title="动态“左子右兄”表示法"></a>动态“左子右兄”表示法</h3><p>直接使用二叉树数据结构存储森林的方式称作动态“左子右兄”表示法。</p>
<p>简单的仅包括创建和打印树的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> L_C_R_S_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L_C_R_S_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	DataTy value;</span><br><span class="line">	TreeNode* left_child, * right_sibling;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeNode();</span><br><span class="line">	TreeNode(<span class="keyword">const</span> TreeNode&amp; item);</span><br><span class="line">	TreeNode(<span class="keyword">const</span> DataTy&amp; val, TreeNode&lt;DataTy&gt;* plchild = <span class="literal">nullptr</span>, TreeNode&lt;DataTy&gt;* prsibling = <span class="literal">nullptr</span>);</span><br><span class="line">	~TreeNode();</span><br><span class="line"></span><br><span class="line">	<span class="function">DataTy <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_left_child</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_right_sibling</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> DataTy&amp; val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_left_child</span><span class="params">(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> plchild)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_right_sibling</span><span class="params">(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> prsibling)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lcrsTree</span> &#123;</span></span><br><span class="line">	TreeNode&lt;DataTy&gt;* root;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs_print</span><span class="params">(TreeNode&lt;DataTy&gt;* node, <span class="keyword">size_t</span> <span class="built_in">floor</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	lcrsTree();</span><br><span class="line">	lcrsTree(TreeNode&lt;DataTy&gt;* proot);</span><br><span class="line">	~lcrsTree();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_root</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input_tree</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">	value = DataTy();</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = <span class="keyword">this</span>-&gt;right_sibling = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode(<span class="keyword">const</span> TreeNode&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;value = item.value;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = item.left_child;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = item.right_sibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode(<span class="keyword">const</span> DataTy&amp; val, TreeNode&lt;DataTy&gt;* plchild, TreeNode&lt;DataTy&gt;* prsibling)</span><br><span class="line">&#123;</span><br><span class="line">	value = val;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = plchild;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = prsibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::~TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">DataTy TreeNode&lt;DataTy&gt;::get_value() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* TreeNode&lt;DataTy&gt;::get_left_child() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;left_child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* TreeNode&lt;DataTy&gt;::get_right_sibling() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;right_sibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_value(<span class="keyword">const</span> DataTy&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_left_child(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> plchild)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = plchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_right_sibling(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> prsibling)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = prsibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::dfs_print(TreeNode&lt;DataTy&gt;* node, <span class="keyword">size_t</span> <span class="built_in">floor</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; node-&gt;get_value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;get_left_child())</span><br><span class="line">		dfs_print(node-&gt;get_left_child(), <span class="built_in">floor</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;get_right_sibling())</span><br><span class="line">		dfs_print(node-&gt;get_right_sibling(), <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::lcrsTree()</span><br><span class="line">&#123;</span><br><span class="line">	root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::lcrsTree(TreeNode&lt;DataTy&gt;* proot)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;root = proot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::~lcrsTree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode&lt;DataTy&gt;*&gt; aque;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root)	aque.push(<span class="keyword">this</span>-&gt;root);</span><br><span class="line">	<span class="keyword">while</span> (!aque.empty()) &#123;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* tmp = aque.front();</span><br><span class="line">		aque.pop();</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;get_left_child())	aque.push(tmp-&gt;get_left_child());</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;get_right_sibling())	aque.push(tmp-&gt;get_right_sibling());</span><br><span class="line">		<span class="keyword">delete</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">bool</span> lcrsTree&lt;DataTy&gt;::is_empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;root == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* lcrsTree&lt;DataTy&gt;::get_root() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::input_tree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode&lt;DataTy&gt;*&gt; aque;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入森林中子树的个数：&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt_tree;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; cnt_tree;</span><br><span class="line">	TreeNode&lt;DataTy&gt;* rights = <span class="literal">nullptr</span>;</span><br><span class="line">	TreeNode&lt;DataTy&gt;* node = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (cnt_tree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入各个子树的根节点的值：&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt_tree; i++) &#123;</span><br><span class="line">			DataTy val;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">			node = <span class="keyword">new</span> TreeNode&lt;DataTy&gt;(val, <span class="literal">nullptr</span>, rights);</span><br><span class="line">			rights = node;</span><br><span class="line">			aque.push(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;root = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!aque.empty()) &#123;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* subtree_root = aque.front();</span><br><span class="line">		aque.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点&quot;</span> &lt;&lt; subtree_root-&gt;get_value() &lt;&lt; <span class="string">&quot;的子结点的个数：&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* rights = <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* node = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入各个子结点的的值：&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">				DataTy val;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">				node = <span class="keyword">new</span> TreeNode&lt;DataTy&gt;(val, <span class="literal">nullptr</span>, rights);</span><br><span class="line">				rights = node;</span><br><span class="line">				aque.push(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		subtree_root-&gt;set_left_child(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;is_empty())	<span class="keyword">return</span>;</span><br><span class="line">	dfs_print(<span class="keyword">this</span>-&gt;root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !L_C_R_S_TREE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="父指针表示法"><a href="#父指针表示法" class="headerlink" title="父指针表示法"></a>父指针表示法</h3><p>在某些情况下，只需要知道父节点的情况（例如并查集操作）。因此每个结点仅需要保存一个指向其父节点的指针（或下标）。这种实现方法被称作父指针表示法。</p>
<h2 id="Ⅱ-顺序存储结构"><a href="#Ⅱ-顺序存储结构" class="headerlink" title="Ⅱ - 顺序存储结构"></a>Ⅱ - 顺序存储结构</h2>]]></content>
  </entry>
</search>
