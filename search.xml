<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDA调试方法与常见技巧</title>
    <url>/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li>使用IDA Remote Windows Debugger进行调试；</li>
<li>断点。</li>
</ul>
<a id="more"></a>

<h1 id="如何使用IDA进行调试"><a href="#如何使用IDA进行调试" class="headerlink" title="如何使用IDA进行调试"></a>如何使用IDA进行调试</h1><p>在Windows系统上使用IDA调试，需要用到两个文件<code>win32_remote.exe</code>和<code>win64_remote.exe</code>（在文件夹<code>\IDA 7.0\dbgsrv</code>中）:</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213183001919.png" alt="image-20201213183001919" style="zoom: 80%;">

<p>这两个文件分别对应32位的IDA和64位的IDA，<strong>在调试过程中，IDA和remote文件需要对应</strong>。</p>
<p>（以64位为例）首先打开remote文件（之后将其最小化即可）：</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213185817136.png" alt="image-20201213185817136" style="zoom: 67%;">

<p>在IDA界面选择<code>Remote Windows debugger</code>，</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190129549.png" alt="image-20201213190129549" style="zoom:80%;">

<p>点击左侧绿色的箭头开始调试。在第一次调试时可能会出现下面的错误：</p>
<img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190615181.png" alt="image-20201213190615181" style="zoom:80%;">

<p>不断点确定，会出现一个setup窗口。其中<code>Application</code>和<code>Input File</code>均填写待调试文件的<strong>绝对路径</strong>，<code>Directory</code>填写待调试文件所在的文件夹，<code>Hostname</code>填写<code>127.0.0.1</code>表示当前主机。</p>
<p><strong>为了防止之后每次调试都设置一遍，可以将<code>Save network settings as default</code>选中，保存网络设置。</strong>完整的填写示例如下：</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190544390.png" alt="image-20201213190544390"></p>
<p>之后即可正常出现调试界面。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213190816616.png" alt="image-20201213190816616"></p>
<h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>在反编译模式（F5）下，可以点击代码左侧的蓝色按钮设置（多个）断点，如下：</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191034981.png" alt="image-20201213191034981"></p>
<p>之后，进入调试，可以看到，程序在执行到断点的位置后会停止。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191147562.png" alt="image-20201213191147562"></p>
<p>此时，可以将鼠标悬停到某个变量实时预览变量的值，也可以进行其他工作。</p>
<p>在菜单<code>debuger</code>处可以执行各种和调试有关的操作（例如继续执行、结束调试等等）。<strong>通常在界面上方的工具栏也有这些选项</strong>。</p>
<p><img src="/2020/12/13/IDA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7/image-20201213191329335.png" alt="image-20201213191329335"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF密码学中RSA问题总结</title>
    <url>/2020/12/26/CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%ADRSA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>本文汇总CTF密码学中和RSA问题相关的问题。</strong></p>
<a id="more"></a>



<h1 id="RSA简介"><a href="#RSA简介" class="headerlink" title="RSA简介"></a>RSA简介</h1><p>RSA算法的具体描述如下：</p>
<ul>
<li>任意选择两个不同的大素数$p$和$q$，计算$n=pq$和$\phi(n)=(p-1)(q-1)$。</li>
<li>任意选择一个整数$e$，满足$gcd(e,\phi(n))=1$。</li>
<li>计算$d=e^{-1}(mod \space \phi(n))$。</li>
<li>公布公钥$(e,n)$，保存私钥$(d,n)$。</li>
</ul>
<p>（使用公钥）将明文$m(m&lt;n)$加密成密文$c$的加密算法为：<br>$$<br>c=E(m)=m^e(mod \space n)<br>$$</p>
<p>（使用私钥）将密文$c$解密的解密算法为：<br>$$<br>m=D(c)=c^d(mod \space n)<br>$$</p>
<h1 id="和RSA算法有关的Python-Libraries和Tools"><a href="#和RSA算法有关的Python-Libraries和Tools" class="headerlink" title="和RSA算法有关的Python Libraries和Tools"></a>和RSA算法有关的Python Libraries和Tools</h1><p><strong>利用Python中的库<a class="link" href="https://www.pycryptodome.org/en/latest/index.html">Crypto.Util.number<i class="fas fa-external-link-alt"></i></a>中的<code>long_to_bytes</code>、<code>bytes_to_long</code>函数可以进行<code>bytes</code>类型和<code>int</code>类型的互换</strong>。</p>
<p>使用方法：</p>
<p> <a class="link" href="https://www.programcreek.com/python/index/1372/Crypto.Util.number">https://www.programcreek.com/python/index/1372/Crypto.Util.number<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>Python中的库<a class="link" href="https://gmpy2.readthedocs.io/en/latest/index.html">gmpy2<i class="fas fa-external-link-alt"></i></a>可以进行包括扩展欧几里得、求逆、求<code>x</code>次方根等常见的操作。</strong></p>
<p>使用方法：</p>
<p><a class="link" href="https://blog.csdn.net/qq_42250840/article/details/105153227">https://blog.csdn.net/qq_42250840/article/details/105153227<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link" href="https://vimsky.com/examples/detail/python-module-gmpy2.html">https://vimsky.com/examples/detail/python-module-gmpy2.html<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>Python中的库<a class="link" href="https://github.com/hellman/libnum">libnum<i class="fas fa-external-link-alt"></i></a>集成了模运算、椭圆曲线运算等常见的操作。</strong></p>
<p><strong>常见的整数分解工具包括</strong></p>
<ul>
<li><p><strong><a class="link" href="https://sourceforge.net/projects/yafu/">Windows kafu<i class="fas fa-external-link-alt"></i></a>，使用命令<code>factor(N)</code>即可。</strong></p>
</li>
<li><p><strong>Python Library <a class="link" href="https://github.com/hellman/libnum">libnum<i class="fas fa-external-link-alt"></i></a>，使用命令<code>factorize(n)</code>即可（使用rho-Pollard method）。</strong></p>
</li>
</ul>
<h1 id="常见的攻击方法"><a href="#常见的攻击方法" class="headerlink" title="常见的攻击方法"></a>常见的攻击方法</h1><h2 id="暴力破解-N-pq"><a href="#暴力破解-N-pq" class="headerlink" title="暴力破解 $N=pq$"></a>暴力破解 $N=pq$</h2><p>如果题目中$n$较小，我们可以利用数学工具对$N$进行整数分解。</p>
<p><strong>有时候，将$N$进行整数分解后会得到三个或多个整数。</strong>可以根据如下定理</p>
<blockquote>
<p>设$m=p_1^{\alpha _1}p_2^{\alpha _2},…,p_r^{\alpha _r}$，其中$p_1,p_2,…,p_r$为不同的素因 子，则<br>$$<br>\phi(m)=\phi(p_1^{\alpha _1})\phi(p_2^{\alpha _2})…\phi(p_r^{\alpha _r})=p_1^{\alpha _1-1}(p_1-1)p_2^{\alpha _2-1}(p_2 -1)…p_r^{\alpha _r-1}(p_r -1)<br>$$</p>
</blockquote>
<p>计算出$\phi(N)$。</p>
<p>例如（CTF新生赛Crypto 2）：</p>
<blockquote>
<p>c=67692316911846383515666937548215377516026242122014572162117994514425606283681<br>N=103461035900816914121390101299049044413950405173712170434161686539878160984549<br>e=65537</p>
</blockquote>
<p>首先使用kafu计算出N的整数分解。</p>
<img src="/2020/12/26/CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%ADRSA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20201228090323794.png" alt="image-20201228090323794" style="zoom: 67%;">

<p>得到<br>$$<br>p=366669102002966856876605669837014229419, q=282164587459512124844245113950593348271<br>$$<br>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">c = <span class="number">67692316911846383515666937548215377516026242122014572162117994514425606283681</span></span><br><span class="line">N = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">q = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line"></span><br><span class="line">d = libnum.invmod(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, N)</span><br><span class="line">print(long_to_bytes(m).decode())</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;hello_hash_team&#125;</code>。</p>
<h2 id="RSA共模攻击"><a href="#RSA共模攻击" class="headerlink" title="RSA共模攻击"></a>RSA共模攻击</h2><p>在大多数情况下，$N$无法被有效地分解。此时，<strong>如果题目中出现了两对$(e_1,c_1),(e_2,c_2)$，并且有$gcd(e_1,e_2)=1$，则可以考虑使用RSA共模攻击</strong>。</p>
<p><strong>共模攻击原理</strong></p>
<p>由于$gcd(e_1,e_2)=1$，因此根据拓展欧几里得原理，可以得到唯一的$s_1,s_2$，使得<br>$$<br>e_1s_1+e_2s_2=1<br>$$<br>又由于<br>$$<br>c_1=m^{e_1}(mod \space n),\space c_2=m^{e_2}(mod\space n)<br>$$<br>可以得到<br>$$<br>c_1^{s_1}c_2^{s_2}=[m^{e_1}(mod \space n)]^{s_1}[m^{e_2}(mod \space n)]^{s_2}(mod \space n)<br>$$<br>根据同余性质和幂运算性质，可以得到<br>$$<br>c_1^{s_1}c_2^{s_2}=(m^{e_1})^{s_1}(m^{e_2})^{s_2}(mod \space n)=m^{e_1s_1+e_2s_2}(mod \space n)<br>$$<br>因此<br>$$<br>c_1^{s_1}c_2^{s_2}=m^1(mod \space n)=m(mod n)<br>$$</p>
<p><strong>利用共模攻击，可以在不求出$d$的情况下（即不需要分解大整数$N$）将$m$计算出来</strong>。</p>
<p>例如（CTF新生赛Crypto 3）：</p>
<blockquote>
<p>n = 0xa1d4d377001f1b8d5b2740514ce699b49dc8a02f12df9a960e80e2a6ee13b7a97d9f508721e3dd7a6842c24ab25ab87d1132358de7c6c4cee3fb3ec9b7fd873626bd0251d16912de1f0f1a2bba52b082339113ad1a262121db31db9ee1bf9f26023182acce8f84612bfeb075803cf610f27b7b16147f7d29cc3fd463df7ea31ca860d59aae5506479c76206603de54044e7b778e21082c4c4da795d39dc2b9c0589e577a773133c89fa8e3a4bd047b8e7d6da0d9a0d8a3c1a3607ce983deb350e1c649725cccb0e9d756fc3107dd4352aa18c45a65bab7772a4c5aef7020a1e67e6085cc125d9fc042d96489a08d885f448ece8f7f254067dfff0c4e72a63557L<br>e1 = 0xf4c1158fL<br>c1 = 12051796366524088489284445109295502686341498426965277230069915294159131976231473789977279364263965099422235647723775278060569378071469131866368399394772898224166518089593340803913798327451963589996734323497943301819051718709807518655868569656941242449109980876397661605271517459716669684900920279597477446629607627693769738733623143693170696779851882404994923673483971528314806130892416509854017091137325195201225617407959645788145876202882024723106204183257094755002924708009138560347432552090905489132135154932987521239299578509008290614398700799670928805692609756924823628055245227290288940649158862576448537833423L<br>e2 = 0xf493f7d1L<br>c2 = 16648382384980770705624348910895797622774711113202207693584907182552301186239613809347201161450012615995859738410661452438496756353485538305614949211776668793864984429696790944750894691957799234264508530084026894611228513698963347402329109838109621609770406925700520983387811451074838470370044678634099202003480925903267508744006195455234025325060817223813858985074720872124168142943926467694676717713503559007112874381750005406371400109962943508349497151148446064846096531445037416174913915923050332242843403926133165817310272633884358263778516770288515592959832151762499526363131801945163501999337808208074381212795L</p>
</blockquote>
<p>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0xa1d4d377001f1b8d5b2740514ce699b49dc8a02f12df9a960e80e2a6ee13b7a97d9f508721e3dd7a6842c24ab25ab87d1132358de7c6c4cee3fb3ec9b7fd873626bd0251d16912de1f0f1a2bba52b082339113ad1a262121db31db9ee1bf9f26023182acce8f84612bfeb075803cf610f27b7b16147f7d29cc3fd463df7ea31ca860d59aae5506479c76206603de54044e7b778e21082c4c4da795d39dc2b9c0589e577a773133c89fa8e3a4bd047b8e7d6da0d9a0d8a3c1a3607ce983deb350e1c649725cccb0e9d756fc3107dd4352aa18c45a65bab7772a4c5aef7020a1e67e6085cc125d9fc042d96489a08d885f448ece8f7f254067dfff0c4e72a63557</span></span><br><span class="line">e1 = <span class="number">0xf4c1158f</span></span><br><span class="line">c1 = <span class="number">12051796366524088489284445109295502686341498426965277230069915294159131976231473789977279364263965099422235647723775278060569378071469131866368399394772898224166518089593340803913798327451963589996734323497943301819051718709807518655868569656941242449109980876397661605271517459716669684900920279597477446629607627693769738733623143693170696779851882404994923673483971528314806130892416509854017091137325195201225617407959645788145876202882024723106204183257094755002924708009138560347432552090905489132135154932987521239299578509008290614398700799670928805692609756924823628055245227290288940649158862576448537833423</span></span><br><span class="line">e2 = <span class="number">0xf493f7d1</span></span><br><span class="line">c2 = <span class="number">16648382384980770705624348910895797622774711113202207693584907182552301186239613809347201161450012615995859738410661452438496756353485538305614949211776668793864984429696790944750894691957799234264508530084026894611228513698963347402329109838109621609770406925700520983387811451074838470370044678634099202003480925903267508744006195455234025325060817223813858985074720872124168142943926467694676717713503559007112874381750005406371400109962943508349497151148446064846096531445037416174913915923050332242843403926133165817310272633884358263778516770288515592959832151762499526363131801945163501999337808208074381212795</span></span><br><span class="line"></span><br><span class="line">s1, s2, g = libnum.xgcd(e1, e2)</span><br><span class="line"><span class="keyword">assert</span> g == <span class="number">1</span>, <span class="string">&quot;gcd(e1, e2) is not 1&quot;</span></span><br><span class="line"></span><br><span class="line">ans = (<span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n)) % n</span><br><span class="line">print(long_to_bytes(ans).decode())</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;8c16c91be3f3287ff5a10167e922b33b&#125;</code>。</p>
<h2 id="低加密指数分解攻击"><a href="#低加密指数分解攻击" class="headerlink" title="低加密指数分解攻击"></a>低加密指数分解攻击</h2><p><strong>在 RSA 中$ e $也称为加密指数。由于$ e $是可以随意选取的，选取小一点的$ e $可以缩短加密时间，但是选取不当的话，就会造成安全问题。</strong></p>
<p>由于（使用公钥）将明文$m(m&lt;n)$加密成密文$c$的加密算法为：<br>$$<br>c=E(m)=m^e(mod \space n)<br>$$<br>因此，当$e$过小时，例如$e=2,e=3$，就会有<br>$$<br>m^e=c+kn(k=0,1,…)<br>$$<br>即，<strong>RSA问题转换为了求$c+kn(k=…,-1,0,1,…)$的二次方根或者三次方根问题。和大整数分解问题相比，该算法的时间复杂度非常低，因此可以利用这种方法获得$m$。</strong></p>
<p>例如（CTF训练赛Crypto 2）：</p>
<blockquote>
<p>n =     0x504422886880999134164106129232979493447288711838128518343366212225318903644618300817499198750840212643148846352592538512783005736164297583799147064883313355294028416687642306709706943887551457028035973777229371815062651312421640647068096189113496379135101287943752591797440940734536167859259186040466011910888475712958297303535087426800506564240900638884432216737231731773972981109497611446103590015141017384041792747752222369077462487716099140258216028669719577413647641486036733175734648934918607792606929986333056819301666536526344527151782292255144358594370104124433857693900000227671975512733846188265519758430055649020007978758166309930265697614982513218273073454928983660048528331097010828958096468299776488744993182315936148627876851809422331280471073551417956563668197068676126722734534188127471611402864677938887115908916553544845110143563736559450970252229445667691496767868123951081712872604935508183737147849971835008184807472987711316180320099624812832405397468923025162496735247263616654895797084799784974584932678025655358910480843010221725985491740823985360121695310692419773463141212113933823487148306326402421665145808422963033346161969635009951581265915013730077344870284008003690168143322781170105437085918993663<br>c = 0x10652CDFAA8D984F5B582D65A9357ADA464CA4E9BF0C3914A5AD2DC291D9EC8310E9BFF83E4B0545B61806A4FC0DAC3FCA5A0917D98052320317208292B6F4B472AA032D4E48CFFEAFF387A44F7FCDD91DC103BB2B9C66FFA987C4A3E038F65C46CC66A00965<br>e = 3</p>
</blockquote>
<p>编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">0x504422886880999134164106129232979493447288711838128518343366212225318903644618300817499198750840212643148846352592538512783005736164297583799147064883313355294028416687642306709706943887551457028035973777229371815062651312421640647068096189113496379135101287943752591797440940734536167859259186040466011910888475712958297303535087426800506564240900638884432216737231731773972981109497611446103590015141017384041792747752222369077462487716099140258216028669719577413647641486036733175734648934918607792606929986333056819301666536526344527151782292255144358594370104124433857693900000227671975512733846188265519758430055649020007978758166309930265697614982513218273073454928983660048528331097010828958096468299776488744993182315936148627876851809422331280471073551417956563668197068676126722734534188127471611402864677938887115908916553544845110143563736559450970252229445667691496767868123951081712872604935508183737147849971835008184807472987711316180320099624812832405397468923025162496735247263616654895797084799784974584932678025655358910480843010221725985491740823985360121695310692419773463141212113933823487148306326402421665145808422963033346161969635009951581265915013730077344870284008003690168143322781170105437085918993663</span></span><br><span class="line">c = <span class="number">0x10652CDFAA8D984F5B582D65A9357ADA464CA4E9BF0C3914A5AD2DC291D9EC8310E9BFF83E4B0545B61806A4FC0DAC3FCA5A0917D98052320317208292B6F4B472AA032D4E48CFFEAFF387A44F7FCDD91DC103BB2B9C66FFA987C4A3E038F65C46CC66A00965</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">x = c</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg, istrue = gmpy2.iroot(gmpy2.mpz(x), (gmpy2.mpz(e)))</span><br><span class="line">    <span class="keyword">if</span>(istrue):</span><br><span class="line">        print(long_to_bytes(<span class="built_in">int</span>(msg)).decode())</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:   x += n</span><br></pre></td></tr></table></figure>

<p>得到答案<code>flag&#123;you_are_clever_than_i_thount&#125;</code>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>CRYPTO</tag>
        <tag>NUMBER THEORY &amp; CRYPTO &amp; CODING</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数参数的提供和接收方式</title>
    <url>/2020/12/21/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%8F%90%E4%BE%9B%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>本文包括Python函数参数的提供和接收方式。</strong></p>
<p>包括位置参数、关键字参数和默认值、参数收集等。</p>
<a id="more"></a>

<h1 id="各种参数提供和接收方式的介绍"><a href="#各种参数提供和接收方式的介绍" class="headerlink" title="各种参数提供和接收方式的介绍"></a>各种参数提供和接收方式的介绍</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>最常见的Python参数的提供和接收方式是使用<strong>位置参数</strong>，使用方法和绝大多数其他编程语言（如C++）相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c, d</span>):</span></span><br><span class="line">    print(a, b, c, d)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>随着程序规模的扩大，记住各个函数的参数的位置会更加困难。因此Python引入了<strong>关键字参数</strong>，将<strong>参数名称</strong>作为判断依据（而不是位置参数中的参数的位置）。</p>
<p>和位置参数相比，定义使用关键字参数的函数并不需要对原函数进行任何修改，向函数传递形参时，需要使用类似于赋值语句的形式将值显式地交给某个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c, d</span>):</span></span><br><span class="line">    print(a, b, c, d)</span><br><span class="line"></span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">func(a=<span class="number">1</span>, c=<span class="number">2</span>, b=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">func(a=<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="number">3</span>, c=<span class="number">4</span>)</span><br><span class="line">func(d=<span class="number">1</span>, c=<span class="number">2</span>, b=<span class="number">3</span>, a=<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在使用关键字参数的情况下，参数的顺序就无关轻重了。Python将根据参数名称进行匹配赋值（即使顺序和定义函数时的顺序不一致）。</strong></p>
<h2 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h2><p>在C++语言中，有默认值参数。例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">int</span>* beg, <span class="keyword">int</span>* ed, <span class="keyword">unsigned</span> <span class="keyword">int</span> gap = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* i = beg; i != ed; i += gap)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Python中，也有同样的用法，即<strong>默认值参数</strong>。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabin_miller</span>(<span class="params">num, s=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Choose s random numbers ranging from 1 to (num - 1) to test WITNESS.&quot;&quot;&quot;</span></span><br><span class="line">    t, u = <span class="number">0</span>, num - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> u % <span class="number">2</span> == <span class="number">0</span>:  t, u = t + <span class="number">1</span>, u // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">        a = random.randrange(<span class="number">1</span>, num)</span><br><span class="line">        au1, au2 = <span class="number">0</span>, <span class="built_in">pow</span>(a, u, num)</span><br><span class="line">        <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">            au1, au2 = au2, <span class="built_in">pow</span>(au2, <span class="number">2</span>, num)</span><br><span class="line">            <span class="keyword">if</span> au2 == <span class="number">1</span> <span class="keyword">and</span> au1 != <span class="number">1</span> <span class="keyword">and</span> au1 != num - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> au2 != <span class="number">1</span>:    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_encode</span>(<span class="params">text, lookup=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(text, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> text])</span><br><span class="line">    remainder = <span class="built_in">len</span>(bin_str) % <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        bin_str += <span class="string">&quot;0&quot;</span> * (<span class="number">6</span> - remainder)</span><br><span class="line">    bin_str += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    code = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_str) // <span class="number">6</span>):</span><br><span class="line">        code += lookup[<span class="built_in">int</span>(bin_str[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        code += <span class="string">&quot;=&quot;</span> * ((<span class="number">6</span> - remainder) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在定义了默认值参数后，<strong>如果调用该函数而跳过默认值参数（不论是位置参数还是关键字参数），则程序将使用该默认值。如果现实地传递了参数，将按照传入的参数为准</strong>。</p>
<p>实际上，Python很多内置函数就是使用了默认值参数，例如<code>range(start, stop[, step=1])</code>等。</p>
<p>在使用默认值参数时，有一个需要注意的地方，即<strong>默认值应该设置为不可变的量（例如字符串、整型、元组等），而不应该设置为可变的量（如列表、字典等）</strong>。</p>
<blockquote>
<p>在每个程序里，Python函数的默认值仅被声明一次。因此如果多次调用使用默认值参数的函数，并且函数内的操作会修改该（可变的）默认值，那么在下一次调用该函数时，该默认值将是修改后的值。</p>
<p>例如下面的python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">val, arr=[]</span>):</span></span><br><span class="line">    arr.append(val)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">2</span>)</span><br><span class="line">func(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>的运行结果是</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="分配和收集参数（-和-的使用）"><a href="#分配和收集参数（-和-的使用）" class="headerlink" title="分配和收集参数（*和**的使用）"></a>分配和收集参数（<code>*</code>和<code>**</code>的使用）</h2><h3 id="收集参数（对应函数形参）"><a href="#收集参数（对应函数形参）" class="headerlink" title="收集参数（对应函数形参）"></a>收集参数（对应函数形参）</h3><p>有时候，允许用户提供任意数量的参数很有用。（对于C++和其他编程语言来说，想实现这样的功能很困难，并且条件非常苛刻，但是）使用Python实现这样的功能并不困难。</p>
<p>函数<strong>形参上的（在这里需要严格区分形参和实参）</strong><code>*</code>和<code>**</code>用于<strong>将任意多个传入的形参进行封装</strong>。</p>
<p><strong>对于一个星号<code>*</code>来说，其用于收集位置参数，将所有值都放在一个元组中，也就是说将这些值收集起来。如果没有可供收集的参数，该参数将会是一个空元组（也就是说无论如何该位置都是一个储存着所有传递给它的参数的元组）。</strong></p>
<p><strong>对于两个星号<code>**</code>来说，其用于收集关键字参数，将所有的关键字实参<code>name=val</code>按照<code>&#123;str(name): val&#125;</code>的形式放入一个字典中。同样的，如果没有可供收集的参数，该参数将是一个空字典。</strong></p>
<p><code>*</code>和<code>**</code>是有区别并且严格区分的。也就是说，**<code>**</code>不能用来收集位置参数，而<code>*</code>不能用来收集关键字参数**。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params</span>(<span class="params">*argv, **argd</span>):</span></span><br><span class="line">    print(argv)</span><br><span class="line">    print(argd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">4</span>, b=<span class="number">5</span>, e=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1, 2, 3)</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分配参数（对应函数实参）"><a href="#分配参数（对应函数实参）" class="headerlink" title="分配参数（对应函数实参）"></a>分配参数（对应函数实参）</h3><p>前面介绍的是如何将参数收集到元组和字典中。同样的两个运算符也可以执行相反的操作。</p>
<p><strong>一个星号<code>*</code>用于将可迭代序列解包，并形成位置参数。两个星号<code>**</code>用于将字典解包，并形成关键字参数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%d + %d + %d = %d.&quot;</span> % (a, b, c, a + b + c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(*(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">add(*[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">add(**&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">9</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>+ <span class="number">3</span> + <span class="number">5</span> = <span class="number">9</span>.</span><br><span class="line"><span class="symbol">3 </span>+ <span class="number">4</span> + <span class="number">5</span> = <span class="number">12</span>.</span><br><span class="line"><span class="symbol">3 </span>+ <span class="number">2</span> + <span class="number">9</span> = <span class="number">14</span>.</span><br></pre></td></tr></table></figure>



<h1 id="同时使用多种参数"><a href="#同时使用多种参数" class="headerlink" title="同时使用多种参数"></a>同时使用多种参数</h1><h2 id="混用原则"><a href="#混用原则" class="headerlink" title="混用原则"></a>混用原则</h2><p><strong>不论同时使用哪几种参数，首先要满足的一点是，函数的每个（非默认值）实参都需要被赋值，并且实参最多能被显式赋值一次。</strong></p>
<blockquote>
<p>下面的函数调用都是错误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c=<span class="number">2</span></span>):</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">1</span>)        	<span class="comment">#b没有被赋值</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">3</span>)     	<span class="comment">#a被重复赋值</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, c=<span class="number">3</span>)		<span class="comment">#c被重复赋值（形参中c=2不属于显式赋值）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>如果一个函数中仅有位置参数和关键字参数，则关键字参数必须在位置参数之后</strong>。</p>
<blockquote>
<p>如果关键字参数在位置参数之前，Python在遇到关键字参数后的位置参数时无法解释是跳过关键字参数还是对关键字参数进行了多次重复赋值。</p>
</blockquote>
<p><strong>如果在函数形参中有<code>*</code>，并且星号之后有其他的参数，则后面的参数只能使用关键字参数</strong>。</p>
<blockquote>
<p>由于<code>*</code>具有贪心的性质（即吸收直到无法继续吸收），因此只能使用关键字参数防止被星号吸收。</p>
</blockquote>
<p><strong>如果在一个函数形参中同时使用<code>**</code>，则<code>**</code>必须放在所有参数的最后一个，即<code>**</code>之后不能再有任何位置参数或关键字参数</strong>。</p>
<blockquote>
<p><code>**</code>之后不能有位置参数，否则将会与“关键字参数必须在位置参数之后”这一原则相矛盾。</p>
<p>由于<code>**</code>有贪心的性质（即吸收直到无法继续吸收）。因此即使其后面又有关键字参数，也无法被赋值。因此Python规定了这样的操作是非法的。</p>
</blockquote>
<p>如果将所有类型的参数都混合在一起，他们的形式一定为</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">def <span class="function"><span class="keyword">func</span><span class="params">(位置参数, 带默认值的关键字参数, *元组参数收集, （带默认值的）关键字参数, **字典参数收集)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c=<span class="number">3</span>, *argv, e=<span class="number">3</span>, f=<span class="number">3</span>, g, **argd</span>):</span></span><br><span class="line">    print(a, b, c, argv, e, f, g, argd, sep= <span class="string">&#x27; # &#x27;</span>)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, g=<span class="number">3</span>)  <span class="comment">#g的关键字赋值必不可少，然而e和f可以使用默认值</span></span><br><span class="line">func(<span class="number">19</span>, <span class="number">54</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, g=<span class="number">10</span>, h=<span class="number">2</span>, i=<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span># <span class="number">2</span> # <span class="number">3</span> # (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) # <span class="number">3</span> # <span class="number">3</span> # <span class="number">3</span> # &#123;&#125;</span><br><span class="line"><span class="symbol">19 </span># <span class="number">54</span> # [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>] # (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) # <span class="number">3</span> # <span class="number">3</span> # <span class="number">10</span> # &#123;<span class="comment">&#x27;h&#x27;: 2, &#x27;i&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>【WP】逆向-CrackMe</title>
    <url>/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/</url>
    <content><![CDATA[<p><strong>CrackMe.exe  2020年12月15日</strong></p>
<ul>
<li>通过引导字符串确定关键函数；</li>
<li>常见的比较字符串相同的函数；</li>
<li>使用断点调试确定函数功能；</li>
<li>Base 64加密。</li>
</ul>
<a id="more"></a>

<h1 id="确定关键函数"><a href="#确定关键函数" class="headerlink" title="确定关键函数"></a>确定关键函数</h1><p>在IDA中打开CrackMe.exe文件，进入反编译窗口，可以看到主函数：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215192616383.png" alt="image-20201215192616383"></p>
<p>主函数中有</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">puts(<span class="string">&quot;input your flag:&quot;</span>)<span class="comment">;</span></span><br><span class="line">scanf(<span class="string">&quot;%s&quot;</span>, <span class="symbol">&amp;v5</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>非常明显的标志，因此可以看出<code>sub_4020A0()</code>函数没有实际用途，并且<code>v5</code>是输入的字符串。</p>
<p>此外，进入函数<code>sub_401540(&amp;v6, &quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;)</code>，可以看到：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215192952032.png" alt="image-20201215192952032"></p>
<p>下面的语句是<strong>常见的比较两个字符串是相同的</strong>函数。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">if</span> ( *<span class="built_in">a1</span> == *<span class="built_in">a2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">v3</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span> ( len != ++<span class="built_in">v3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">if</span> ( <span class="built_in">a1</span>[<span class="built_in">v3</span>] != <span class="built_in">a2</span>[<span class="built_in">v3</span>] )</span><br><span class="line">        return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return puts(<span class="string">&quot;you win!!&quot;</span>)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return puts(<span class="string">&quot;wrong!&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>因此， 我们可以初步得出程序的结构，即</p>
<p><strong>程序输入一个字符串<code>v5</code>后，通过函数<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>得到一个字符串<code>v6</code>，如果该字符串为<code>&quot;5GRB5XNU6jlT3TlT3WpB8W0WtldF+msR42ZH5yld&quot;</code>,则说明该字符串为最后的flag。</strong></p>
<p>因此，我们需要重点关注<code>sub_401500(aAbcdefghijklmn)</code>和<code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code>函数。</p>
<h1 id="函数逆向"><a href="#函数逆向" class="headerlink" title="函数逆向"></a>函数逆向</h1><h2 id="sub-401500-aAbcdefghijklmn"><a href="#sub-401500-aAbcdefghijklmn" class="headerlink" title="sub_401500(aAbcdefghijklmn)"></a><code>sub_401500(aAbcdefghijklmn)</code></h2><p>通过IDA可以看到：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">.data:<span class="number">00403040</span> aAbcdefghijklmn db &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz<span class="number">0123456789</span>+/&#x27;,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>变量<code>aAbcdefghijklmn</code>是一个字符串。该函数如下：</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215194438600.png" alt="image-20201215194438600"></p>
<p>该函数对传入的数组进行了一些修改。<strong>由于我们传入的是一个已知的字符串变量，因此我们可以利用调试查出执行该函数后的变量值</strong>。</p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215194802943.png" alt="image-20201215194802943"></p>
<p>从这里可以看出，修改后的变量为</p>
<p><code>ghijklmnopqrstuvxxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef</code></p>
<h2 id="sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4"><a href="#sub-4015B0-amp-input-strlen-amp-input-amp-v6-amp-v4" class="headerlink" title="sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)"></a><code>sub_4015B0(&amp;input, strlen(&amp;input), &amp;v6, &amp;v4)</code></h2><p><strong>如果对Base 64编码比较熟悉的话， 从上一个函数得到的字符串来看，包括A-Z、a-z、0-9以及+和/，很容易想到这可能是一个Base 64的换表加密。再加上一些比较明显的标记，例如</strong></p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215195712853.png" alt="image-20201215195712853"></p>
<p><strong>和</strong></p>
<p><img src="/2020/12/15/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-CrackMe/image-20201215195755086.png" alt="image-20201215195755086"></p>
<p><strong>应该可以确定该函数就是一个换表Base 64加密</strong>。</p>
<p>我们可以利用将最后一个函数的比较字符串通过换表Base 64函数还原到原字符串来确定我们猜测的正确性。</p>
<p>经过换表Base 64的反编码，我们得到了字符串</p>
<p><code>flag&#123;th1s_1s_base64_exc1ange!&#125;</code></p>
<p>我们能够断定我们的猜测是正确的。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的周游</title>
    <url>/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/</url>
    <content><![CDATA[<p><strong>二叉树的周游包括深度优先遍历（包括前序遍历、中序遍历和后序遍历）以及广度优先遍历。</strong></p>
<a id="more"></a>

<p>本文假定二叉树的数据类型如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br></pre></td></tr></table></figure>

<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p><strong>深度优先遍历包括前序遍历、中序遍历和后续遍历。</strong></p>
<h2 id="前序遍历（pre-order-traversal）"><a href="#前序遍历（pre-order-traversal）" class="headerlink" title="前序遍历（pre-order traversal）"></a>前序遍历（pre-order traversal）</h2><p><strong>前序遍历的递归定义为：</strong></p>
<ul>
<li><strong>访问根节点</strong></li>
<li><strong>按照前序遍历左子树</strong></li>
<li><strong>按照前序遍历右子树</strong></li>
</ul>
<h3 id="根据二叉树实例写出前序遍历序列"><a href="#根据二叉树实例写出前序遍历序列" class="headerlink" title="根据二叉树实例写出前序遍历序列"></a>根据二叉树实例写出前序遍历序列</h3><p>根据二叉树写前序遍历序列时，最方便稳妥的方法时按照递归定义进行遍历。</p>
<p>例如，对于如下的二叉树</p>
<img src="/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/1.jpg" alt="1" style="zoom:50%;">

<p>按照根节点、左子树、右子树的方式遍历，可以得到：</p>
<p><code>8 [tree of node 3] [tree of node 10]</code></p>
<p>对两个子树进行递归遍历，有：</p>
<p><code>8 3 [tree of node 1] [tree of node 6] 10 [tree of node 14]</code></p>
<p>有：</p>
<p><code>8 3 1 6 [tree of node 4] [tree of node 7] 10 14 [tree of node 13]</code></p>
<p>最后有前序遍历序列：</p>
<p><code>8 3 1 6 4 7 10 14 13</code></p>
<h3 id="递归实现前序遍历"><a href="#递归实现前序遍历" class="headerlink" title="递归实现前序遍历"></a>递归实现前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		pre_traversal(tree-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		pre_traversal(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现前序遍历"><a href="#非递归实现前序遍历" class="headerlink" title="非递归实现前序遍历"></a>非递归实现前序遍历</h3><p>前序遍历可以使用栈<strong>完全模拟函数递归的过程</strong>。其方法为<strong>首先将根节点放入栈中完成初始化，之后当栈不为空时进入循环，从栈中弹出一个结点，将其输出，再将其右子结点、左子结点（如果有）按顺序放入栈中，完成本轮循环。</strong></p>
<p>如果将递归实现前序遍历的过程完全模拟一遍，会发现其过程和上述过程完全相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;Tree&gt; sta;</span><br><span class="line">	sta.push(tree);</span><br><span class="line">	<span class="keyword">while</span> (!sta.empty()) &#123;</span><br><span class="line">		Tree root = sta.top();</span><br><span class="line">		sta.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;right)		sta.push(root-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;left)		sta.push(root-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用前序遍历构建二叉树"><a href="#使用前序遍历构建二叉树" class="headerlink" title="使用前序遍历构建二叉树"></a>使用前序遍历构建二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">createTree</span><span class="params">(Tree father = <span class="literal">nullptr</span>, <span class="keyword">bool</span> isLeft = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!father)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of root node, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isLeft)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of the left node of node &quot;</span> &lt;&lt; father-&gt;data &lt;&lt; <span class="string">&quot;, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the index of the right node of node &quot;</span> &lt;&lt; father-&gt;data &lt;&lt; <span class="string">&quot;, -1 means nullptr: &quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> ind;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ind;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ind == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	Tree root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">	root-&gt;data = ind;</span><br><span class="line">	root-&gt;left = createTree(root);</span><br><span class="line">	root-&gt;right = createTree(root, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中序遍历（in-order-traversal）"><a href="#中序遍历（in-order-traversal）" class="headerlink" title="中序遍历（in-order traversal）"></a>中序遍历（in-order traversal）</h2><p><strong>中序遍历的递归定义为：</strong></p>
<ul>
<li><strong>按照中序遍历左子树</strong></li>
<li><strong>访问根节点</strong></li>
<li><strong>按照中序遍历右子树</strong></li>
</ul>
<h3 id="根据二叉树实例写出中序遍历序列"><a href="#根据二叉树实例写出中序遍历序列" class="headerlink" title="根据二叉树实例写出中序遍历序列"></a>根据二叉树实例写出中序遍历序列</h3><p>方法和前序遍历序列的方法是一样的，最严谨的方法是按照递归定义进行遍历。</p>
<p>同样对于上面的二叉树，可以依次得到：</p>
<p><code>[tree of node 3] 8 [tree of node 10]</code></p>
<p><code>[tree of node 1] 3 [tree of node 6] 8 10 [tree of node 14]</code></p>
<p><code>1 3 [tree of node 4] 6 [tree of node 7] 8 10 [tree of node 13] 14</code></p>
<p>最后得到中序遍历序列为</p>
<p><code>1 3 4 6 7 8 10 13 14</code></p>
<h3 id="递归实现中序遍历"><a href="#递归实现中序遍历" class="headerlink" title="递归实现中序遍历"></a>递归实现中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		in_traversal(tree-&gt;left);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		in_traversal(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现中序遍历"><a href="#非递归实现中序遍历" class="headerlink" title="非递归实现中序遍历"></a>非递归实现中序遍历</h3><p>中序遍历无法完全利用栈模拟递归操作。为了非递归实现中序遍历，我们将递归实现中序遍历的操作分为两大部分。</p>
<ol>
<li><p><strong>第一部分</strong>包括<code>if (tree-&gt;left) in_traversal(tree-&gt;left);</code>，即访问其左子树。</p>
</li>
<li><p><strong>第二部分</strong>包括<code>cout &lt;&lt; tree-&gt;data &lt;&lt; &quot; &quot;;</code>和<code>if (tree-&gt;right) in_traversal(tree-&gt;right);</code>，即输出当前根节点并访问其右子树。</p>
</li>
</ol>
<p>将两部分区分开来之后，我们用得到当前结点的方法作为执行哪一种操作的依据。具体方法如下。</p>
<ul>
<li>如果当前结点（不为<code>nullptr</code>）是从其父节点访问得到的（则该该结点是第一次被访问），则执行第一部分的操作。并将当前（根）结点压入栈中。</li>
<li>如果当前结点为<code>nullptr</code>，则从栈中取出一个结点（此时该结点一定已经访问完其左子树），因此执行第二部分操作，即输出当前根节点，并将当前结点指向其右子结点。</li>
</ul>
<p>总结起来，<strong>我们使用获取结点的方式来判断其是首次访问还是已经访问结束其左子树后回溯到该结点的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;Tree&gt; sta;</span><br><span class="line">	Tree root = tree;</span><br><span class="line">	<span class="keyword">while</span> (root || !sta.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root) &#123;</span><br><span class="line">			sta.push(root);</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root = sta.top();</span><br><span class="line">			sta.pop();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="后序遍历（post-order-traversal）"><a href="#后序遍历（post-order-traversal）" class="headerlink" title="后序遍历（post-order traversal）"></a>后序遍历（post-order traversal）</h2><p><strong>后序遍历的递归定义为：</strong></p>
<ul>
<li><strong>按照后序遍历左子树</strong></li>
<li><strong>按照后序遍历右子树</strong></li>
<li><strong>访问根节点</strong></li>
</ul>
<h3 id="根据二叉树实例写出中序遍历序列-1"><a href="#根据二叉树实例写出中序遍历序列-1" class="headerlink" title="根据二叉树实例写出中序遍历序列"></a>根据二叉树实例写出中序遍历序列</h3><p>对于上面的二叉树，可以依次得到：</p>
<p><code>[tree of node 3] [tree of node 10] 8</code></p>
<p><code>[tree of node 1] [tree of node 6] 3 [tree of node 14] 10 8</code></p>
<p><code>1 [tree of node 4] [tree of node 7] 6 3 [tree of node 13] 14 10 8</code></p>
<p>最后得到后序遍历序列为</p>
<p><code>1 4 7 6 3 13 14 10 8</code></p>
<h3 id="递归实现后序遍历"><a href="#递归实现后序遍历" class="headerlink" title="递归实现后序遍历"></a>递归实现后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;left)		post_traversal(tree-&gt;left);</span><br><span class="line">	<span class="keyword">if</span> (tree-&gt;right)		post_traversal(tree-&gt;right);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递归实现后序遍历"><a href="#非递归实现后序遍历" class="headerlink" title="非递归实现后序遍历"></a>非递归实现后序遍历</h3><p>和中序遍历相似地，我们将递归后序遍历的过程分为三大部分。</p>
<ol>
<li><strong>第一部分</strong>包括<code>if (tree-&gt;left)        post_traversal(tree-&gt;left);</code>，即访问其左子结点。</li>
<li><strong>第二部分</strong>包括<code>if (tree-&gt;right)        post_traversal(tree-&gt;right);</code>，即访问其右子结点。</li>
<li><strong>第三部分</strong>包括<code>cout &lt;&lt; tree-&gt;data &lt;&lt; &quot; &quot;;</code>，即输出根节点。</li>
</ol>
<p>由于我们将整个过程分为三个部分，因此就无法仅利用获取结点的方式进行判断（执行哪一部分）。<strong>我们对每个结点引入一个布尔类型变量<code>isRight</code>，以判断该结点是否是访问完右子结点后入栈的</strong>。具体方法如下。</p>
<ul>
<li>如果当前结点（不为<code>nullptr</code> ）是从其父节点访问得到的，则为其引入一个<code>isRight</code>变量并置为<code>false</code>，将该结点和辅助变量一并放入栈中，并将当前结点设置为该结点的左子结点。</li>
<li>如果当前结点为<code>nullptr</code>，则从栈中取出一个结点。<ul>
<li>如果该结点的<code>isRight</code>变量为<code>false</code>，则将<code>isRight</code>置为<code>true</code>，并将该结点和辅助变量一并放入栈中，并将当前结点设置为该结点的右子结点。</li>
<li>如果该结点的<code>isRight</code>变量为<code>true</code>，则输出该结点，以该结点为根节点的子树访问结束，<strong>因此要将当前结点更新为<code>nullptr</code>，以代表该结点没有其他任何子结点可以访问了</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal_sta</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;&gt; sta;</span><br><span class="line">	Tree root = tree;</span><br><span class="line">	<span class="keyword">while</span> (root || !sta.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root) &#123;</span><br><span class="line">			sta.push(<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;(root, <span class="literal">false</span>));</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			root = sta.top().first;</span><br><span class="line">			<span class="keyword">bool</span> isRight = sta.top().second;</span><br><span class="line">			sta.pop();</span><br><span class="line">			<span class="keyword">if</span> (!isRight) &#123;</span><br><span class="line">				sta.push(<span class="built_in">pair</span>&lt;Tree, <span class="keyword">bool</span>&gt;(root, <span class="literal">true</span>));</span><br><span class="line">				root = root-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				root = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="根据遍历序列恢复二叉树"><a href="#根据遍历序列恢复二叉树" class="headerlink" title="根据遍历序列恢复二叉树"></a>根据遍历序列恢复二叉树</h2><p>还是以该树为例。</p>
<img src="/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8/1.jpg" alt="1" style="zoom:50%;">

<p>其前序、中序和后序遍历序列分别为：</p>
<p><strong>前序遍历序列：<code>8 3 1 6 4 7 10 14 13</code></strong></p>
<p><strong>中序遍历序列：<code>1 3 4 6 7 8 10 13 14</code></strong></p>
<p><strong>后序遍历序列：<code>1 4 7 6 3 13 14 10 8</code></strong></p>
<h3 id="前序遍历和中序遍历"><a href="#前序遍历和中序遍历" class="headerlink" title="前序遍历和中序遍历"></a>前序遍历和中序遍历</h3><p><strong>前序遍历可以方便地确定根节点，中序遍历可以方便地根据根节点确定左子树和右子树包括哪些结点。</strong></p>
<p>根据前序遍历第一个结点为<code>8</code>，可以得到：</p>
<p><code>root:8 [left-tree of 8: 1 3 4 6 7] [right-tree of 8: 10 13 14]</code></p>
<p>因为<code>[1 3 4 6 7 ] 8 [10 13 14]</code></p>
<p>对左右子树进行递归操作，可以依次得到：</p>
<p><code>8 root:3 [left-tree of 3: 1] [right-tree of 3: 4 6 7] root:10 [right-tree of 10: 13 14]</code></p>
<p>因为<code>[1] 3 [4 6 7] 8 10 [13 14]</code></p>
<p><code>8 3 1 root:6 [left-tree of 6: 4] [right-tree of 6: 7] 10 root:14 [left-tree of 14: 13]</code></p>
<p>因为<code>1 3 [4] 6 [7] 8 10 [13] 14</code></p>
<h3 id="前序遍历和后序遍历"><a href="#前序遍历和后序遍历" class="headerlink" title="前序遍历和后序遍历"></a>前序遍历和后序遍历</h3><p><strong>仅仅直到前序遍历和后序遍历有时候无法唯一确定树的确定形态（例如对于上面的二叉树来说，将13作为右子结点得到的前序遍历、后序遍历和原来完全相同）。</strong></p>
<p><strong>如果可以的话，前序遍历和后序遍历进行结合可以方便地确定某一个根节点的左右子结点分别是什么。</strong>对于某个序列（可能是子序列），如果将前序遍历的第一个结点作为根节点，则考虑其后面的第一个结点，并在后序遍历中找到该结点。则再后序遍历中该结点左侧的结点属于该子树，将这些结点再前序遍历序列中划分开来，则剩下的结点属于根节点的右子树。</p>
<p><strong>一次迭代</strong></p>
<p>前序遍历序列：<code>[root:8] [3 1 6 4 7] [10 14 13]</code></p>
<p>后序遍历序列：<code>[1 4 7 6 3] [13 14 10] [root:8]</code></p>
<p><strong>二次迭代</strong></p>
<p>前序遍历序列：<code>3 [1] [6 4 7]</code> <code>10 [14 13]</code></p>
<p>后序遍历序列：<code>[1] [4 7 6] 3</code> <code>[13 14] 10</code></p>
<p><strong>三次迭代</strong></p>
<p>前序遍历序列：<code>3</code> <code>1</code> <code>6 [4] [7]</code> <code>10</code> <code>14 13</code></p>
<p>后序遍历序列：<code>1</code>  <code>[4] [7] 6</code> <code>3</code> <code>13 14</code> <code>10</code></p>
<p>这里<code>14 13</code>无法继续判断，<strong>但我们已经从前序序列和后序序列得到了足够多的信息了。</strong></p>
<p><strong>进一步地，如果子结点的左右顺序无关，或者二叉树中要不是叶结点，要不是出度为2的结点的话，我们就可以根据前序遍历和后序遍历完全恢复出树的状态。</strong></p>
<h3 id="中序遍历和后序遍历"><a href="#中序遍历和后序遍历" class="headerlink" title="中序遍历和后序遍历"></a>中序遍历和后序遍历</h3><p>后序遍历和前序遍历有很多相似性。因此和利用前序遍历、中序遍历恢复二叉树的方法非常类似。</p>
<p>例如：</p>
<p>中序遍历序列：<code>[1 3 4 6 7] root:8 [10 13 14]</code></p>
<p>后序遍历序列：[]<code>1 4 7 6 3] [13 14 10] root:8</code></p>
<p>对剩余的序列进行递归即可。</p>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索一般使用队列进行模拟。其思路非常简单，不断从队列中取出结点，输出该结点信息，并将该结点的左右子节点放入队列中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b_traversal</span><span class="params">(Tree tree)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Tree&gt; que;</span><br><span class="line">	que.push(tree);</span><br><span class="line">	<span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">		Tree root = que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;left)		que.push(root-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;right)		que.push(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的应用——二叉搜索树</title>
    <url>/2020/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p><strong>在数据存储过程中，为了满足高效的插入、删除以及检索功能，需要用到二叉搜索树这一数据结构。</strong></p>
<p>二叉搜索树是一种满足以下属性的特殊的二叉树：<strong>二叉搜索树中每个非空结点表示一个记录，若某节点左子树不为空，则左子树上所有结点的值均小于该结点的关键码值；若其右子树不为空，则右子树上所有结点的值均大于该结点的关键码值。</strong></p>
<p>简单地说，二叉搜索树在理想情况下递归地将数据分为左右两部分，在搜索过程中，每次比较可以将所搜范围减少一半。</p>
<a id="more"></a>

<h1 id="二叉搜索树相关操作"><a href="#二叉搜索树相关操作" class="headerlink" title="二叉搜索树相关操作"></a>二叉搜索树相关操作</h1><p>本文假定二叉搜索树的结点数据定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br></pre></td></tr></table></figure>



<h2 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h2><p>通常在考虑元素的插入时要额外判断是否插入的是根节点。<strong>如果是根节点，则直接创建根节点即可</strong>。</p>
<p>如果不是根节点，设待插入结点的关键码为<code>val</code>。引入一个辅助变量<code>cur</code>，从根结点开始，进入循环，判断：</p>
<ul>
<li>如果<code>cur-&gt;value == val</code>，则说明插入元素已经存在，则抛出异常。</li>
<li>如果<code>cur-&gt;value &gt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明插入元素应该在当前结点的左子树中。因此<code>cur = cur-&gt;left</code>。</li>
<li>如果<code>cur-&gt;value &lt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明插入元素应该在当前结点的右子树中。因此<code>cur = cur-&gt;right</code>。</li>
</ul>
<p>如果在上面的后两个判断条件中，出现了<code>cur-&gt;left</code>或者<code>cur-&gt;right</code>为<code>nullptr</code>，则退出循环。此时，<code>cur-&gt;left</code>（或者<code>cur-&gt;right</code>）即为待插入的位置。</p>
<p>插入元素的代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search_tree::insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">		root-&gt;value = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Repeating Element Error.&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val &amp;&amp; cur-&gt;left) &#123;</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &lt; val &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur-&gt;left = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">else</span>		cur-&gt;right = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的检索"><a href="#元素的检索" class="headerlink" title="元素的检索"></a>元素的检索</h2><p>检索元素引入辅助变量<code>cur</code>，从根节点开始循环，判断：</p>
<ul>
<li>如果<code>cur-&gt;value == val</code>，则查找结束，返回结果。</li>
<li>如果<code>cur-&gt;value &gt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明待查找元素应该在当前结点的左子树中。因此<code>cur = cur-&gt;left</code>。</li>
<li>如果<code>cur-&gt;value &lt; val</code>并且<code>cur-&gt;left</code>不为<code>nullptr</code>，则说明待查找元素应该在当前结点的右子树中。因此<code>cur = cur-&gt;right</code>。</li>
</ul>
<p>如果在上面的后两个判断条件中，出现了<code>cur-&gt;left</code>或者<code>cur-&gt;right</code>为<code>nullptr</code>，则说明待查找元素不在搜索树中。因此退出循环。</p>
<p><strong>实际上元素插入和元素删除实质是等价的，如果查找一个元素失败，则失败的位置就可以插入这个元素。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur = cur-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; val)	cur = cur-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><p>二叉搜索树的结点删除算法思想为：<strong>如果待删除结点<code>pos</code>没有左子树，则用其右子树的根节点代替该结点。若有左子树，则在左子树中找到最大的一个结点（设为<code>rep</code>），将<code>rep</code>和<code>pos</code>结点交换，并删除<code>rep</code>。</strong></p>
<p>删除元素的逻辑比较复杂，有很多情况需要考虑。下面进行详细的说明。</p>
<p>在删除函数中，我们<strong>一共引入了四个辅助变量，分别为<code>toDel</code>、<code>father_toDel</code>、<code>replace</code>、<code>father_replace</code>，分别表示待删除结点指针、待删除结点的父节点指针（如果待删除结点为<code>root</code>，则<code>father_toDel == nullptr</code>）、待替换结点指针（如果需要）和待替换结点的父节点指针（如果需要）</strong>。    </p>
<ul>
<li><strong>首先函数根据关键码在二叉搜索树中查找待删除的结点<code>toDel</code>，并在向下搜索的过程中保存<code>father_toDel</code>（初始化<code>father_toDel == nullptr</code>）。如果没有找到，则返回<code>false</code>。</strong></li>
</ul>
<p>删除结点需要分为两种情况考虑。</p>
<p><strong>Situation 1</strong></p>
<ul>
<li><strong>如果该结点的左子树不为空，则需要在左子树中找到一个最大的替换结点<code>replace</code>。</strong>寻找方法是首先进入左子树**(即<code>replace = toDel-&gt;left, father_replace = toDel</code>)<strong>，之后不断向当前结点的右子树深入，直到当前节点的右子树为空。</strong>在搜索过程中，更新<code>father_replace</code>使其始终为<code>toDel</code>的父节点**。<ul>
<li>之后，分析一下我们的思路。我们需要做的是将<code>replace</code>和<code>toDel</code>互换。之后将替换后的<code>toDel</code>删除。</li>
</ul>
</li>
<li>我们按照顺序做如下的操作：<ol>
<li>将<code>father_replace</code>和<code>replace</code>的连接断开，并将<code>father_replace</code>和<code>replace-&gt;left</code>连接上（**即<code>father_replace-&gt;left/right = replace-&gt;left</code>**）。（我们可以断定<code>replace</code>右子树一定为空。否则在查找替换结点的过程中一定会进入该右子树）。【到这一步，我们将<code>replace</code>从二叉搜索树中抽出来（并保持其他的结构不变）】</li>
<li>之后，我们将抽出的<code>replace</code>结点插到<code>father_toDel</code>的子树上。<strong>这里需要考虑<code>father_toDel</code>为空的情况。此时，需要删除的结点即为<code>root</code>，这种情况我们只需要将<code>root = replace</code>即可。</strong>如果<code>father_toDel</code>不为空，则令<code>father_toDel-&gt;left/right = replace</code>。</li>
<li>之后，**<code>replace</code>将继承<code>toDel</code>的左右子树**。即<code>replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right</code>。</li>
<li>最后，删除<code>toDel</code>即可。</li>
</ol>
</li>
</ul>
<p><strong>总结一下，我们的思路是将<code>replace</code>从原位置抽出来（保持其他结构不变），插入到<code>toDel</code>的位置，并继承<code>toDel</code>的左右子树，完成替换。</strong></p>
<p><strong>Situation 2</strong></p>
<p>如果该子树的左结点为空，则我们仅需要<strong>用右子树的根节点代替当前结点即可</strong>。在这里，我们同样需要考虑<code>father_toDel</code>为空的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::erase</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree toDel = root, father_toDel = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (toDel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value == val)	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &gt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;left;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &lt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!toDel)		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDel-&gt;left) &#123;</span><br><span class="line">		Tree replace = toDel-&gt;left, father_replace = toDel;</span><br><span class="line">		<span class="keyword">while</span> (replace-&gt;right)</span><br><span class="line">			father_replace = replace, replace = replace-&gt;right;</span><br><span class="line">	</span><br><span class="line">		(father_replace-&gt;left == replace ? father_replace-&gt;left : father_replace-&gt;right) = replace-&gt;left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)</span><br><span class="line">			root = replace;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = replace;</span><br><span class="line"></span><br><span class="line">		replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;		<span class="comment">//if toDel-&gt;left == nullptr</span></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)	</span><br><span class="line">			root = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">else</span>	 </span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = toDel-&gt;right;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>最后给出完整的C++代码实现。</p>
<p><code>binary_search_tree.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARY_SEARCH_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARY_SEARCH_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> Tree = TreeNode*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_search_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Tree root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	binary_search_tree();</span><br><span class="line">	binary_search_tree(<span class="keyword">int</span>* _Arr, <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">	~binary_search_tree();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !BINARY_SEARCH_TREE_H</span></span></span><br></pre></td></tr></table></figure>

<p><code>binary_search_tree.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binary_search_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">binary_search_tree::binary_search_tree()</span><br><span class="line">&#123;</span><br><span class="line">	root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binary_search_tree::binary_search_tree(<span class="keyword">int</span>* _Arr, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		insert(_Arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search_tree::insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">		root-&gt;value = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;Repeating Element Error.&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val &amp;&amp; cur-&gt;left) &#123;</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &lt; val &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur-&gt;left = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">else</span>		cur-&gt;right = <span class="keyword">new</span> TreeNode&#123; val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::find</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value == val)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;value &gt; val)		cur = cur-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; val)	cur = cur-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search_tree::erase</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree toDel = root, father_toDel = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (toDel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value == val)	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &gt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;left;</span><br><span class="line">		<span class="keyword">if</span> (toDel-&gt;value &lt; val)	</span><br><span class="line">			father_toDel = toDel, toDel = toDel-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!toDel)		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDel-&gt;left) &#123;</span><br><span class="line">		Tree replace = toDel-&gt;left, father_replace = toDel;</span><br><span class="line">		<span class="keyword">while</span> (replace-&gt;right)</span><br><span class="line">			father_replace = replace, replace = replace-&gt;right;</span><br><span class="line">	</span><br><span class="line">		(father_replace-&gt;left == replace ? father_replace-&gt;left : father_replace-&gt;right) = replace-&gt;left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)</span><br><span class="line">			root = replace;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = replace;</span><br><span class="line"></span><br><span class="line">		replace-&gt;left = toDel-&gt;left, replace-&gt;right = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;		<span class="comment">//if toDel-&gt;left == nullptr</span></span><br><span class="line">		<span class="keyword">if</span> (!father_toDel)	</span><br><span class="line">			root = toDel-&gt;right;</span><br><span class="line">		<span class="keyword">else</span>	 </span><br><span class="line">			(father_toDel-&gt;left == toDel ? father_toDel-&gt;left : father_toDel-&gt;right) = toDel-&gt;right;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> toDel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binary_search_tree::~binary_search_tree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Tree&gt; que;</span><br><span class="line">	<span class="keyword">if</span> (root)		que.push(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">		Tree cur = que.front();</span><br><span class="line">		que.pop();</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;left)	que.push(cur-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;right)	que.push(cur-&gt;right);</span><br><span class="line">		<span class="keyword">delete</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的应用——堆与优先队列</title>
    <url>/2020/12/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>在现实应用中，经常会遇到频繁地在一组对象中查找最大值和最小值的情况。</strong>堆可以为这样的操作提供更加高效的算法。</p>
<p>最小堆（min-heap，最大堆类似）是关键码序列${K_0,K_1,…,K_{n-1}}$，它具有如下的性质：<br>$$<br>K_i\leq K_{2i+1}， \<br>K_i \leq K_{2i+2} \space \space(i=0,1,…,\lfloor n/2 \rfloor-1)<br>$$<br>通俗地说，最小堆是一棵二叉树，其根节点为整个序列中关键码最小的元素。并且对于任意一个结点来说，其父节点一定小于该结点，其左右子结点一定大于该结点。换言之，从根节点到所有叶结点的路径都是一个单调不减序列。</p>
<p>从形式上来说，<strong>堆属于完全二叉树</strong>，因此虽然是一种树形结构，我们仍然可以使用使用（顺序表）存储。</p>
<a id="more"></a>

<p>在引入堆之前，首先引入一些和完全二叉树有关的性质。</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>如果按照层次顺序将一棵有$n$个结点的完全二叉树中的所有节点<strong>从$0$到$n-1$进行编号</strong>，并将其存储在一个顺序表（如数组）中。则有如下性质。</p>
<ul>
<li>对于任意一个二叉树结点，<strong>如果它存储在数组下标为$i$的位置，那么它的父节点下标为$\lfloor (i-1)/2 \rfloor$，它的左子结点下标为$2i+1$，它的右子结点下标为$2i+2$。</strong></li>
<li>二叉树中非叶子结点（即有左子树或者左右子树的结点）的个数为$\lfloor n/2 \rfloor$。换言之，<strong>如果$i \geq \lfloor n/2 \rfloor$，则说明该结点为叶子结点</strong>。</li>
</ul>
<blockquote>
<p>对于第二条性质的证明，需要如下引理：</p>
<ul>
<li>对于一棵满二叉树来说（即结点的度要不为0，要不为2），其叶结点数目$n_0$等于其分分支结点树$n_2$加1.</li>
</ul>
<p>对于完全二叉树来说，只有两种情况：</p>
<ol>
<li>如果$n=2k$，则在其最后补充一个结点，使得$n+1=2k+1$，则该完全二叉树被扩充为一个满二叉树。此时，有$2k+1=n_0+n_2=2n_2+1$，即得到$n_2=k$。</li>
<li>如果$n=2k+1$，则该二叉树本身就构成一个满二叉树。同样地，可以得到$n_2=k$。</li>
</ol>
<p>综上，$n_2=\lfloor n/2 \rfloor$.</p>
</blockquote>
<h1 id="（最小）堆"><a href="#（最小）堆" class="headerlink" title="（最小）堆"></a>（最小）堆</h1><h2 id="adjust-函数"><a href="#adjust-函数" class="headerlink" title="adjust()函数"></a><code>adjust()</code>函数</h2><p>构建堆最关键的一个函数为<code>adjust</code>。该函数的参数为<code>adjust(size_t node_index)</code>。其目的是<strong>在假定除结点<code>node_index</code>外的其他部分都符合堆的性质的情况下，单独调整下标为<code>node_index</code>的结点使该结点也符合堆的性质</strong>。</p>
<p>该函数其分为向上调整函数<code>adjust_up</code>和向下调整函数<code>adjust_down</code>。</p>
<ul>
<li>对于向上调整函数来说，其仅考虑以该结点为叶子结点的子树。<strong>并且该结点是该堆中唯一一个不满足堆的性质的结点（即该节点的关键码值小于其父节点的关键码值</strong>。此时，需要将该结点在该子树上向上移动。最后，<strong>该函数达到的效果是其保证了以该结点为叶结点的子树满足堆的性质</strong>。</li>
<li>对于向上调整函数来说，其仅考虑以该结点为叶根节点的子树。<strong>并且该结点是该堆中唯一一个不满足堆的性质的结点（即该节点的关键码值大于其左右节点的关键码值</strong>。此时，需要将该结点在该子树上向下移动。最后，<strong>该函数达到的效果是其保证了以该结点为根结点的子树满足堆的性质</strong>。</li>
</ul>
<p>调整函数<strong>使用迭代的方式</strong>依次将结点向上（或下）移动，即<strong>在循环中不断判断当前结点是否符合堆的性质，如果符合，则退出循环，否则，继续调整。</strong>实现代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::adjust(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= vec.size())		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">		<span class="keyword">while</span> (index &amp;&amp; vec[FATHER(index)] &gt; vec[index] ) &#123;</span><br><span class="line">			swap(vec[FATHER(index)], vec[index]);</span><br><span class="line">			index = FATHER(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (LEFTC(index) &lt; vec.size()) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> left_child = LEFTC(index), rihgt_child = RIGHTC(index);</span><br><span class="line">			<span class="keyword">size_t</span> prob;</span><br><span class="line">			<span class="keyword">if</span> (rihgt_child &gt;= vec.size())		</span><br><span class="line">				prob = left_child;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				prob = vec[left_child] &lt;= vec[rihgt_child] ? left_child : rihgt_child;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vec[index] &gt; vec[prob]) &#123;</span><br><span class="line">				swap(vec[index], vec[prob]);</span><br><span class="line">				index = prob;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆的构建"><a href="#堆的构建" class="headerlink" title="堆的构建"></a>堆的构建</h2><p>在有<code>adjust()</code>函数的条件下，我们思考如何根据给定的序列构建一个堆。</p>
<p>首先，将所有序列放到一个一维数组中，此时形成的完全二叉树并不符合最小堆的特性。但是，<strong>所有的叶子结点所构成的子树（由于之后一个结点）满足堆的性质</strong>。因此，如果我们最底层向最高层按下标顺序遍历非叶子结点，则会发现，当访问到任意一个结点时，其左右子树均满足堆的性质，因此该结点（如果不符合堆的性质）符合向下调整函数的条件，即<strong>通过向下调整函数可以将以该结点为根节点的子树调整为一个堆</strong>。</p>
<p>就这样逆序遍历所有的非叶结点直到根节点，并对每一个结点执行向下调整函数，就可以将整个完全二叉树构建为一个堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len)</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;(_Arr, _Arr + _Len);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (vec.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		adjust(i, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h2><p>首先将新的元素插入到数组的末尾。此时，以该新添加的结点为叶结点的子树满足向上调整的性质。因此，对该结点执行向上调整函数，即可保持整个堆的性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::insert(<span class="keyword">const</span> Tid&amp; _Value)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push_back(_Value);</span><br><span class="line">	adjust(vec.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="元素的删除"><a href="#元素的删除" class="headerlink" title="元素的删除"></a>元素的删除</h2><p>为了删除某一个元素，首先将该元素与数组末尾的元素进行交换。并将最后一个元素删除。此时，该结点（由于其关键码增加）可能会不满足堆的性质。如果不满足，以该结点为根节点的子树满足向下调整的性质。因此，对该结点执行向下调整函数即可保持整个堆的性质。</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>优先队列（priority-queue）是一种有用的数据结构。它是0个或者多个元素的集合，每个元素都有一个关键码值，执行的操作有查找、插入、删除等等。优先队列主要特点是可以快速查找并移出具有最小值（或者最大值）的元素。</p>
<p>堆是实现优先队列非常合适的数据结构。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>最后，给出最小值堆（优先队列）的完整C++实现代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_HEAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FATHER(ind) ((int(ind) - 1) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFTC(ind) ((ind &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHTC(ind)	 ((ind &lt;&lt; 1) + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myheap</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt; vec;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myheap();</span><br><span class="line">	myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> Tid&amp; _Value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Tid <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::adjust(<span class="keyword">size_t</span> index, <span class="keyword">bool</span> isUp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= vec.size())		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">		<span class="keyword">while</span> (index &amp;&amp; vec[FATHER(index)] &gt; vec[index] ) &#123;</span><br><span class="line">			swap(vec[FATHER(index)], vec[index]);</span><br><span class="line">			index = FATHER(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (LEFTC(index) &lt; vec.size()) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> left_child = LEFTC(index), rihgt_child = RIGHTC(index);</span><br><span class="line">			<span class="keyword">size_t</span> prob;</span><br><span class="line">			<span class="keyword">if</span> (rihgt_child &gt;= vec.size())		</span><br><span class="line">				prob = left_child;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				prob = vec[left_child] &lt;= vec[rihgt_child] ? left_child : rihgt_child;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vec[index] &gt; vec[prob]) &#123;</span><br><span class="line">				swap(vec[index], vec[prob]);</span><br><span class="line">				index = prob;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap()</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">myheap&lt;Tid&gt;::myheap(<span class="keyword">const</span> Tid* <span class="keyword">const</span> _Arr, <span class="keyword">size_t</span> _Len)</span><br><span class="line">&#123;</span><br><span class="line">	vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tid&gt;(_Arr, _Arr + _Len);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (vec.size() &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		adjust(i, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : vec)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::insert(<span class="keyword">const</span> Tid&amp; _Value)</span><br><span class="line">&#123;</span><br><span class="line">	vec.push_back(_Value);</span><br><span class="line">	adjust(vec.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> myheap&lt;Tid&gt;::is_empty()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec.size() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> myheap&lt;Tid&gt;::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line">Tid myheap&lt;Tid&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tid&gt;</span><br><span class="line"><span class="keyword">void</span> myheap&lt;Tid&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	erase(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MY_HEAP_H</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDA的技巧汇总</title>
    <url>/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong>本文汇总了一些使用IDA调试的技巧。掌握这些技巧可以极大方便日常使用。</strong></p>
<a id="more"></a>

<h1 id="自定义类型和变量"><a href="#自定义类型和变量" class="headerlink" title="自定义类型和变量"></a>自定义类型和变量</h1><h2 id="修改变量标识符"><a href="#修改变量标识符" class="headerlink" title="修改变量标识符"></a>修改变量标识符</h2><p>例如在反汇编状态下有如下的一个函数：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213192949341.png" alt="image-20201213192949341"></p>
<p>可以看出以下的一些信息：</p>
<blockquote>
<p><code>a1</code>是函数形参，并且是一个<code>char</code>类型的数组；</p>
<p><code>v4</code>表示了数组<code>a1</code>的长度；</p>
</blockquote>
<p>因此，为了便于我们阅读，我们可以修改这些变量的标识符。<strong>其方法为将光标放在需要修改的变量上，右键，可以看到<code>Rename Ival</code>选项，单击该选项，（也可以直接使用快捷键<code>N</code>）即可以进行修改。</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213193630775.png" alt="image-20201213193630775"></p>
<p>下面是修改后的代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213193802256.png" alt="image-20201213193802256"></p>
<h2 id="修改变量类型"><a href="#修改变量类型" class="headerlink" title="修改变量类型"></a>修改变量类型</h2><p>再看下面的函数：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213194334019.png" alt="image-20201213194334019"></p>
<p>我们可以发现：<strong>虽然<code>v9</code>在这里是一个<code>long long </code>类型的变量，但是后续的使用全部将其看作<code>char</code>类型数组进行访问。</strong>因此我们有必要，也完全可以将其进行类型转换。**转换方法和前述相同，在右键菜单中选择<code>Set Ival type</code>，或者使用快捷键<code>y</code>**。下面是转换过后的函数代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213194911482.png" alt="image-20201213194911482"></p>
<p>可以看到，转换后的代码更加清晰明了。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>例如如下代码：</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213195145545.png" alt="image-20201213195145545"></p>
<p>我们可以看到如下的信息：</p>
<blockquote>
<p><code>Dst</code>是一个16字节的变量，初始状态下为0。<code>v5</code>（一个指向内存大小为16个字节的指针）指向<code>Dst</code>的地址。在循环中，<code>v1</code>同样是一个16字节的变量，其前八个字节被定义为一个变量，值为<code>Str[i]</code>，后八个字节被设置为全0.而<code>v5</code>的后八个字节存储着<code>v1</code>的地址。之后<code>v5</code>更新为<code>v1</code>，在后续的循环中<code>v1</code>又重新声明内存。</p>
</blockquote>
<p>因此我们猜测这是一个添加链表元素的过程。因此我们可以在IDA中新建一个结构体，显式地定义List结构体。</p>
<p><strong>打开<code>View-Open subviews-Local types</code>窗口</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201115105.png" alt="image-20201213201115105"></p>
<p><strong>点<code>insert</code>，在新出现的窗口输入希望创建的结构体对应的C代码</strong></p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201441268.png" alt="image-20201213201441268"></p>
<p>之后，就可以将其看作正常的结构，使用上面的方法进行修改。</p>
<p><img src="/2020/12/13/%E4%BD%BF%E7%94%A8IDA%E7%9A%84%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/image-20201213201630912.png" alt="image-20201213201630912"></p>
<p>可以看到，在使用自定义结构体之后，整个函数就变得非常简洁明了。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配——KMP算法</title>
    <url>/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>KMP算法是由Knuth、Morris和Pratt三人设计的线性时间字符串匹配算法。该算法通过预先计算辅助函数$\pi$使匹配时间减少一个因子$n$，总的复杂度为$O(N)$。</strong></p>
<p>参考《算法导论》。</p>
<a id="more"></a>

<h1 id="模式的前缀函数-pi"><a href="#模式的前缀函数-pi" class="headerlink" title="模式的前缀函数 $\pi$"></a>模式的前缀函数 $\pi$</h1><h2 id="什么是前缀函数-pi"><a href="#什么是前缀函数-pi" class="headerlink" title="什么是前缀函数 $\pi$"></a>什么是前缀函数 $\pi$</h2><p>首先考虑朴素的字符串匹配算法的操作过程。</p>
<p>假设文本$T$和模式$P=ababaca$.在下面这个情况下，模式$P$的前5个字符已经匹配成功，但是在匹配第6个字符时失败了。对于朴素的字符串匹配算法来说，下一次匹配将尝试匹配$P[1]$和$T[4]$。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219201107723.png" alt="image-20201219201229846" style="zoom:80%;">

<p>但是，在该实例里面，利用我们已知的信息（即模式串$P$和文本串$T[1…7]$），我们可以知道，将$P[1]$和$T[4]$进行匹配一定是失败的，因为在这个偏移量下，<strong>在重新匹配到$T[8]$位置前就会发生失败</strong>。此外，我们还可以看出来，下一个可能的匹配过程出现在将$P$右移两个单位处，因为<strong>如果将模式串向右移动两个距离，直到匹配到$T[7]$，该位置之前的模式字串依然是匹配的</strong>。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219201605890.png" alt="image-20201219201605890" style="zoom:80%;">

<p>从上面的例子抽象出我们的目的，<strong>在朴素字符串匹配过程中，当我们检测到偏移量$s$是无效的时，我们忽略了检测无效$s$时所获得的信息（即当前匹配位置前的字串）。因此，如果我们能够有效地利用我们已知的信息，计算出可能匹配成功的偏移量，我们就能提高匹配的效率。</strong>这种情况下，我们无需让文本$T$上的指针向前移动，而是可以继续匹配当前位置上的字符（因为我们可以确定之前的位置都是匹配的）。</p>
<p>因此，我们的目的是，对于模式的每一个位置，我们都可以知道<strong>在该位置如果出现不匹配之后，需要将$P$向右移动多少各单位，保证该位置前的模式字串依然是匹配的</strong>，这就是前缀函数$\pi$的目的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设文本是一个长度为$n$的数组$T[1…n]$，而模式是一个长度为$m$的数组$P[1…m]$。则一般地来说，我们希望知道</p>
<p><strong>如果$P[q]$和$T[s+q]$是最后一个匹配的位置（即$P[1…q]=T[s+1…s+q]，P[q+1]\neq T[s+q+1]$），那么满足</strong><br>$$<br>P[1…q-k]=T[s+1+k…s+q]<br>$$<br><strong>的最小的偏移量$k$是多少。</strong></p>
<p>换句话说，**我们希望知道 $P[1…q]$的是$P[1…q]$的真后缀的最长真前缀 **。</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219203554704.png" alt="image-20201219203554704" style="zoom:80%;">

<p>而<strong>前缀函数$\pi$并不直接定义为上面的$k$ 。</strong>其形式化定义为<br>$$<br>\pi [q]=max(k:0\leq k&lt;q且P[1…k]是P[1…q]的后缀)<br>$$<br>也就是说，如果可以找到前述的最小偏移量$k$，那么<br>$$<br>\pi [q]=q-k<br>$$<br>否则<br>$$<br>\pi [q]=0<br>$$</p>
<p>即<strong>在$P[q+1]$的位置匹配失败了（即$P[1…q]$和$T[s+1…s+q]$是最后一个匹配的位置）后，如果位置$q$的前缀函数不为0，那么可以在不移动文本$T$的指针的情况下将模式$P$的指针移动到$P[\pi[q]]=P[q-k]$继续尝试匹配</strong>。</p>
<p>例如对于模式串$P=ababaca$，其前缀函数为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219204344861.png" alt="image-20201219204344861" style="zoom: 80%;">

<p>即</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201219210301510.png" alt="image-20201219210301510" style="zoom:80%;">

<h1 id="如何利用前缀函数-pi-进行字符串匹配"><a href="#如何利用前缀函数-pi-进行字符串匹配" class="headerlink" title="如何利用前缀函数 $\pi$ 进行字符串匹配"></a>如何利用前缀函数 $\pi$ 进行字符串匹配</h1><p>利用前缀函数$\pi$进行字符串匹配的KMP算法的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KMP-MATCHER(T, P):</span><br><span class="line">	n = T.length()</span><br><span class="line">	m = P.length()</span><br><span class="line">	PI[<span class="number">1.</span>..m] <span class="keyword">is</span> prefix function.</span><br><span class="line">	</span><br><span class="line">	matched_num = <span class="number">0</span>	<span class="comment">#number of characters matched.</span></span><br><span class="line">	<span class="keyword">for</span> (t_ptr=<span class="number">1</span> to n):</span><br><span class="line">		<span class="keyword">while</span> (P[matched_num + <span class="number">1</span>] != T[t_ptr] <span class="keyword">and</span> matched_num &gt; <span class="number">0</span>):</span><br><span class="line">            matched_num = PI[matched_num]</span><br><span class="line">        <span class="keyword">if</span> (P[matched_num + <span class="number">1</span>] == T[t_ptr]):</span><br><span class="line">           	matched_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (matched_num == m):</span><br><span class="line">            <span class="string">&#x27;MATCH_SUCCESSFULLY&#x27;</span></span><br><span class="line">        	matched_num = PI[matched_num]	<span class="comment">#Next mathch.      </span></span><br></pre></td></tr></table></figure>

<p>该算法中，<code>t_ptr</code>是文本$T$的指针，<code>matched_num</code>是当前已经匹配的字串长度。在每层循环中，如果该位置匹配失败，则利用前缀函数寻找下一个可能的匹配位置，不断重复直到已匹配字串为空或者该位置匹配成功。</p>
<p>以$T=ababababaca，P=ababaca$为例的KMP匹配过程如下。 </p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220000604237.png" alt="image-20201220000911132" style="zoom: 67%;">

<h1 id="如何计算前缀函数-pi"><a href="#如何计算前缀函数-pi" class="headerlink" title="如何计算前缀函数 $\pi$"></a>如何计算前缀函数 $\pi$</h1><p>实际上计算前缀函数的过程类似于模式串和自身进行匹配的过程，因此他和KMP算法的形式非常类似。计算前缀函数的伪代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION(P):</span><br><span class="line">    let PI[<span class="number">1.</span>..m] be a new array.</span><br><span class="line">    PI[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span> to m):</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> <span class="keyword">and</span> P[k+<span class="number">1</span>] != P[q]):</span><br><span class="line">            k = PI[k]	<span class="comment">#如果当前位置不匹配，利用已经计算出的PI函数进行偏移，以寻找下一个可能的匹配。</span></span><br><span class="line">        <span class="keyword">if</span> (P[k+<span class="number">1</span>] == P[i])</span><br><span class="line">        	k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时，如果P[k+1] == P[q]，则k为模式与自身在该位置之前的最大匹配串长度 + 1</span></span><br><span class="line">        <span class="comment"># 否则，k=0，表示该位置前没有可以匹配的字串</span></span><br><span class="line">      	PI[i] = k</span><br></pre></td></tr></table></figure>

<p>以$P=ababaca$为例的前缀函数计算过程如下。 </p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220002442115.png" alt="image-20201220002442115" style="zoom:80%;">

<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220002709819.png" alt="image-20201220002709819" style="zoom:80%;">

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><code>Kmp.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> pat;</span><br><span class="line">	<span class="keyword">int</span>* prefix_func;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat);</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !KMP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Kmp.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KMP.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kmp::Kmp(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Pat)</span><br><span class="line">&#123;</span><br><span class="line">	pat = <span class="string">&quot; &quot;</span> + _Pat;	<span class="comment">// Start at pat[1]</span></span><br><span class="line">	<span class="keyword">int</span> m = _Pat.size();</span><br><span class="line">	prefix_func = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];	<span class="comment">//Start at prefix_func[1]</span></span><br><span class="line">	prefix_func[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; pat[matched + <span class="number">1</span>] != pat[i])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (pat[matched + <span class="number">1</span>] == pat[i])</span><br><span class="line">			matched++;</span><br><span class="line">		prefix_func[i] = matched;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kmp::search_in</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; _Text, <span class="keyword">const</span> <span class="keyword">int</span>&amp; _Start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = _Text.size();</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = _Start; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (matched &amp;&amp; _Text[i] != pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched = prefix_func[matched];</span><br><span class="line">		<span class="keyword">if</span> (_Text[i] == pat[matched + <span class="number">1</span>])</span><br><span class="line">			matched++;</span><br><span class="line">		<span class="keyword">if</span> (matched == pat.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - (pat.size() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span>(<span class="params">text, pat, start = <span class="number">0</span>, end = -<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">isinstance</span>(text, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(pat, <span class="built_in">str</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError</span><br><span class="line">    n, m = <span class="built_in">len</span>(text), <span class="built_in">len</span>(pat)</span><br><span class="line">    pat = <span class="string">&quot; &quot;</span> + pat     <span class="comment">#Start at 1</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    prefix_func = [<span class="number">0</span>] * (m + <span class="number">1</span>)     <span class="comment">#Start at 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">and</span> pat[k + <span class="number">1</span>] != pat[i]):</span><br><span class="line">            k = prefix_func[k]</span><br><span class="line">        <span class="keyword">if</span> pat[k + <span class="number">1</span>] == pat[i]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        prefix_func[i] = k</span><br><span class="line"></span><br><span class="line">    matched, ind = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text[start:end]:</span><br><span class="line">        <span class="keyword">if</span> (matched <span class="keyword">and</span> pat[matched + <span class="number">1</span>] != i):</span><br><span class="line">            matched = prefix_func[matched]</span><br><span class="line">        <span class="keyword">if</span> pat[matched + <span class="number">1</span>] ==i:</span><br><span class="line">            matched += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matched == m:</span><br><span class="line">            <span class="keyword">return</span> start + ind - m + <span class="number">1</span></span><br><span class="line">        ind += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串的特征向量-next-i"><a href="#字符串的特征向量-next-i" class="headerlink" title="字符串的特征向量 $next[i]$"></a>字符串的特征向量 $next[i]$</h1><p>《数据结构与算法》在讲到KMP算法时没有使用前缀函数$\pi$，而是字符串的特征向量 $next[i]$。使用特征向量在理解上要困难与前缀函数，但<strong>使用字符串的特征向量遵守了在绝大多数编程语言中，数组（包括字符串）下标从0开始的约定，并且减少了不匹配情况出现时的循环次数</strong>，使得在实际实现时更方便一些。</p>
<h2 id="优化前的特征向量"><a href="#优化前的特征向量" class="headerlink" title="优化前的特征向量"></a>优化前的特征向量</h2><p>字符串的特征向量定义为<br>$$<br>next[i]=<br>\begin{cases}<br>-1,如果i=0,\<br>max(k:0&lt;k&lt;i并且P[0…k-1]=P[i-k…i-1]),如果k存在,\<br>0,otherwise.<br>\end{cases}<br>$$</p>
<p>和前缀函数进行比较，<strong>在含义上，除了$next[0]$之外，$next[i]$表示如果在位置$i$处匹配失败，则应该将模式$P$上的指针移动到哪一个位置（的下标）</strong>。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和前缀函数为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220103510586.png" alt="image-20201220103510586" style="zoom:80%;">

<h2 id="特征向量的优化"><a href="#特征向量的优化" class="headerlink" title="特征向量的优化"></a>特征向量的优化</h2><p>假设求出的$next[i]=k$，当匹配时发现$P[i] \neq T[j]$，按照特征向量的定义，需要把模式向右移动$i-k$位，即用$P[k]$与$T[j]$进行比较。<strong>如果$P[i]=P[k]$，则$T[j] \neq P[k]$。</strong></p>
<p>因此，在按照上面的步骤计算出特征向量之后，再遍历一次特征向量，不断比较$P[i]$和$P[next[i]]$，如果$P[i]=P[next[i]]$，则令$next[i]=next[next[i]]$，直到$P[i] \neq P[next[i]]$或者$next[i]=-1$。</p>
<p>对于模式串$P=abcdaabcab$，其特征向量和优化后的特征向量为</p>
<img src="/2020/12/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95/image-20201220105721483.png" alt="image-20201220105721483" style="zoom:80%;">]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
      </tags>
  </entry>
  <entry>
    <title>编码算法——Base 64</title>
    <url>/2020/12/13/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Base%2064/</url>
    <content><![CDATA[<p><strong>Base 64编码算法详解</strong></p>
<a id="more"></a>

<h1 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h1><p>在计算机中。字符一般使用8位（即1个字节）大小的内存进行存储，该1个字节大小的内存可以表示从0到255之间的整数。而ASCII编码表在这里就定义了数字到字符的一一对应关系。因此，给定一个二进制串，计算机可以按照每八位为一个单位，查表得到整个字符串；反过来，给定一个字符串，也可以查表得到该字符串对应的二进制串。</p>
<p><strong>而对于Base 64来说，其使用六位来表示一个字符</strong>。因此，编码后的字符串仅包括64个不同的字符（还有一个字符<code>=</code>用于补位，因此准确地说是65个不同的字符）。下面通过实例来说明Base 64的编码原理。</p>
<p>标准的Base 64也有一个<strong>编码表</strong>，通常表示为</p>
<p><code>lookup = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</code></p>
<p>具体如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
<th align="center"><strong>索引</strong></th>
<th align="center"><strong>对应字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><strong>A</strong></td>
<td align="center">17</td>
<td align="center"><strong>R</strong></td>
<td align="center">34</td>
<td align="center"><strong>i</strong></td>
<td align="center">51</td>
<td align="center"><strong>z</strong></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><strong>B</strong></td>
<td align="center">18</td>
<td align="center"><strong>S</strong></td>
<td align="center">35</td>
<td align="center"><strong>j</strong></td>
<td align="center">52</td>
<td align="center"><strong>0</strong></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>C</strong></td>
<td align="center">19</td>
<td align="center"><strong>T</strong></td>
<td align="center">36</td>
<td align="center"><strong>k</strong></td>
<td align="center">53</td>
<td align="center"><strong>1</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><strong>D</strong></td>
<td align="center">20</td>
<td align="center"><strong>U</strong></td>
<td align="center">37</td>
<td align="center"><strong>l</strong></td>
<td align="center">54</td>
<td align="center"><strong>2</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>E</strong></td>
<td align="center">21</td>
<td align="center"><strong>V</strong></td>
<td align="center">38</td>
<td align="center"><strong>m</strong></td>
<td align="center">55</td>
<td align="center"><strong>3</strong></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><strong>F</strong></td>
<td align="center">22</td>
<td align="center"><strong>W</strong></td>
<td align="center">39</td>
<td align="center"><strong>n</strong></td>
<td align="center">56</td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><strong>G</strong></td>
<td align="center">23</td>
<td align="center"><strong>X</strong></td>
<td align="center">40</td>
<td align="center"><strong>o</strong></td>
<td align="center">57</td>
<td align="center"><strong>5</strong></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><strong>H</strong></td>
<td align="center">24</td>
<td align="center"><strong>Y</strong></td>
<td align="center">41</td>
<td align="center"><strong>p</strong></td>
<td align="center">58</td>
<td align="center"><strong>6</strong></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><strong>I</strong></td>
<td align="center">25</td>
<td align="center"><strong>Z</strong></td>
<td align="center">42</td>
<td align="center"><strong>q</strong></td>
<td align="center">59</td>
<td align="center"><strong>7</strong></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><strong>J</strong></td>
<td align="center">26</td>
<td align="center"><strong>a</strong></td>
<td align="center">43</td>
<td align="center"><strong>r</strong></td>
<td align="center">60</td>
<td align="center"><strong>8</strong></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><strong>K</strong></td>
<td align="center">27</td>
<td align="center"><strong>b</strong></td>
<td align="center">44</td>
<td align="center"><strong>s</strong></td>
<td align="center">61</td>
<td align="center"><strong>9</strong></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><strong>L</strong></td>
<td align="center">28</td>
<td align="center"><strong>c</strong></td>
<td align="center">45</td>
<td align="center"><strong>t</strong></td>
<td align="center">62</td>
<td align="center"><strong>+</strong></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><strong>M</strong></td>
<td align="center">29</td>
<td align="center"><strong>d</strong></td>
<td align="center">46</td>
<td align="center"><strong>u</strong></td>
<td align="center">63</td>
<td align="center"><strong>/</strong></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><strong>N</strong></td>
<td align="center">30</td>
<td align="center"><strong>e</strong></td>
<td align="center">47</td>
<td align="center"><strong>v</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><strong>O</strong></td>
<td align="center">31</td>
<td align="center"><strong>f</strong></td>
<td align="center">48</td>
<td align="center"><strong>w</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><strong>P</strong></td>
<td align="center">32</td>
<td align="center"><strong>g</strong></td>
<td align="center">49</td>
<td align="center"><strong>x</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><strong>Q</strong></td>
<td align="center">33</td>
<td align="center"><strong>h</strong></td>
<td align="center">50</td>
<td align="center"><strong>y</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101</code></p>
<p>如果我们将其按照三个一组进行分组，就可以得到<code>001 110 101 110 101 011 101 011 101 010 000 101</code></p>
<p>现在，我们每两组作为一个单位，可以得到<code>\14\46\43\43\42\5</code></p>
<p>通过查表，既可以得到编码后的字符串为**<code>OurrqF</code>**</p>
</blockquote>
<p>上面说的是理想的情况，通常情况下，<strong>字符串对应的二进制串的长度是8的倍数，但很有可不是6的倍数</strong>。为了解决这个办法，Base 64要求在原二进制串后填0，将该字符串扩充为长度是6的倍数，并使用字符<code>=</code>进行补位（等号的个数取决于补位的0的数量）。补位有两种可能出现的情况，接下来将分别说明。</p>
<blockquote>
<p>假设我们现在有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111 1110</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 111 10</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 111111 10[0000]</code></strong></p>
<p>另一种情况，假设我们有一个二进制串为<code>0011 1010 1110 1010 1110 1011 1010 1000 0101 1111</code></p>
<p>同样的：<code>001 110 101 110 101 011 101 011 101 010 000 101 111 1</code></p>
<p>此时，整个二进制串长度不是6的倍数，因此我们使用0进行补位：</p>
<p><strong><code>001110 101110 101011 101011 101010 000101 1111[00]</code></strong></p>
</blockquote>
<p>实际上我们可以证明，补位仅有两种情况。因此Base 64编码规定，如果在二进制串末尾补0的个数为2，则在编码后字符串末尾添加一个等号<code>=</code>。如果补0的个数为4，则添加两个等号<code>==</code>。</p>
<blockquote>
<p>因此，上面两个二进制串经过编码得到的字符串为：</p>
<p><strong><code>OurrqF/g==</code>**和</strong><code>OurrqF8=</code>**</p>
</blockquote>
<p>在知道编码原理之后，解码的过程就容易理解了。</p>
<h1 id="换表Base-64"><a href="#换表Base-64" class="headerlink" title="换表Base 64"></a>换表Base 64</h1><p>由上面的讨论可以看出，如果知道了Base 64的检索表，就可以完全将编码反编码。因此，为了保证更高的安全性（或者提高问题的难度），通常会使用新的检索表（而不是标准检索表）。</p>
<p>对于换表Base 64，一种方法是在函数中定义新的检索表，直接进行编码和文本之间的转换，另一种方法是做两次变换，将换表Base 64看作<strong>Text &lt;-&gt; 旧表下的Code &lt;-&gt;新表下的Code</strong>这样的函数的复合。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong><a class="link" href="https://base64.us/">在线编码网站<i class="fas fa-external-link-alt"></i></a></strong></p>
<p>Python中内置了Base 64编码库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;加密&quot;&quot;&quot;</span></span><br><span class="line">byte_text = text.encode()   </span><br><span class="line">		<span class="comment">#base64模块使用byte而不是str类型</span></span><br><span class="line">code = base64.b64encode(byte_text).decode()</span><br><span class="line">		<span class="comment">#b64encode()函数用于将字符串进行转换，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(code)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;解密&quot;&quot;&quot;</span></span><br><span class="line">de_text = base64.b64decode(code.encode()).decode()   </span><br><span class="line">		<span class="comment">#b64decode()函数是b64encode()的逆过程，其返回一byte类型变量，因此需要解码</span></span><br><span class="line">print(de_text)</span><br></pre></td></tr></table></figure>

<p>Python函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_encode</span>(<span class="params">text, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(text, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> text])</span><br><span class="line">    remainder = <span class="built_in">len</span>(bin_str) % <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        bin_str += <span class="string">&quot;0&quot;</span> * (<span class="number">6</span> - remainder)</span><br><span class="line">    bin_str += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    code = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_str) // <span class="number">6</span>):</span><br><span class="line">        code += lookup[<span class="built_in">int</span>(bin_str[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>], <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">if</span> remainder:</span><br><span class="line">        code += <span class="string">&quot;=&quot;</span> * ((<span class="number">6</span> - remainder) // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_decode</span>(<span class="params">code, lookup = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(code, <span class="built_in">str</span>), <span class="string">&quot;param &#x27;text&#x27; must be type &lt;str&gt;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> code[-<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>:    code = code[<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elif</span> code[-<span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>:  code = code[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line">    bin_code = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:])) + <span class="built_in">bin</span>(lookup.index(ch))[<span class="number">2</span>:] <span class="keyword">for</span> ch <span class="keyword">in</span> code])</span><br><span class="line">    text = <span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_code) // <span class="number">8</span>):</span><br><span class="line">        text += <span class="built_in">chr</span>(<span class="built_in">int</span>(bin_code[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>CRYPTO</tag>
        <tag>NUMBER THEORY &amp; CRYPTO &amp; CODING</tag>
      </tags>
  </entry>
  <entry>
    <title>树、森林的存储与访问</title>
    <url>/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>树的<strong>递归定义</strong>如下：</p>
<p>树是包括$n$个结点的有限集合，使得</p>
<ol>
<li>有且仅有一个特定的称为<strong>根（root）</strong>的结点。</li>
<li>除根以外的其他节点被分为$m(m\geq 0)$不相交的有限集合$T_1,T_2,…,T_m$，而每一个集合都是树。其中树$T_1,T_2,…,T_m$称作这个根的子树。</li>
</ol>
<p><strong>树的存储包括链式存储结构和顺序存储结构。</strong>由于计算机的存储是有序的，为方便处理，往往把子结点按照从左到右的次序顺序编号，即把树作为有序树（ordered tree）来看待。</p>
<p><strong>森林（forest）是零棵或者多颗不相交的树的集合。</strong></p>
<a id="more"></a>



<h1 id="一、树的逻辑表示方法"><a href="#一、树的逻辑表示方法" class="headerlink" title="一、树的逻辑表示方法"></a>一、树的逻辑表示方法</h1><p><strong>树的逻辑表示方法包括树形表示法、凹入表示法、文氏图表示法、嵌套括号表示法</strong>。</p>
<p><strong>树形表示法是最直观，也最常用的树的逻辑表示方法</strong>。</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/tree.jpg" alt="tree"></p>
<p><strong>凹入表示法主要用于树的屏幕和打印机形式</strong>。例如，Windows上的文件夹管理即为一个凹入表示法。</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201228202803676.png" alt="image-20201228202803676"></p>
<p><strong>文氏图表示法</strong></p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/960a304e251f95ca2e491195ca177f3e67095251.png" alt="960a304e251f95ca2e491195ca177f3e67095251"></p>
<p><strong>嵌套括号表示法</strong></p>
<p>例如对文氏图表示法表示的树来说，其嵌套括号表示法为<code>(A(B(E)D(H)C(F(I)G)))</code></p>
<h1 id="二、森林与二叉树的等价转换"><a href="#二、森林与二叉树的等价转换" class="headerlink" title="二、森林与二叉树的等价转换"></a>二、森林与二叉树的等价转换</h1><p>森林（或者树）与二叉树之间的转化是一一对应的（如果考虑每个结点的顺序的话）。<strong>首先给出森林（或树）与二叉树转换的步骤</strong>。</p>
<ul>
<li>如何从森林（或者树）转换到二叉树？</li>
</ul>
<blockquote>
<p>连线：将兄弟结点用线连起来。</p>
<p>切线：保留父结点与其第一个子结点的连线，将父结点到其他子结点的连线切掉。</p>
<p>旋转：以根为轴，平面向下顺时针方向旋转一定的角度。（旋转只是为了调整画面，使得转化后的二叉树看起来比较规整。）</p>
</blockquote>
<ul>
<li>如何从二叉树转化到森林？</li>
</ul>
<blockquote>
<p>旋转：以根为轴，平面逆时针方向旋转。</p>
<p>补线：如果结点A是父节点F的左子节点，则把A的所有右子结点（即不断向右子树深入直到叶节点）与F连接起来。</p>
<p>删线：去掉所有父节点到右子结点的连线。</p>
</blockquote>
<p><strong>实际上，森林到二叉树的转换是常见的左孩子右兄弟表示法，即对于任意一个节点来说，其所有右节点（即不断向右子树深入直到叶结点）在森林表示法中都是它的兄弟，而其左子结点是它的第一个子结点。</strong>关于这种表示法的详细讲解，可以参考 <a class="link" href="https://www.manongdao.com/article-1127144.html">https://www.manongdao.com/article-1127144.html<i class="fas fa-external-link-alt"></i></a> </p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/u=4047292885,2751585858&fm=26&gp=0.jpg" alt="u=4047292885,2751585858&amp;fm=26&amp;gp=0"></p>
<h1 id="三、树的周游"><a href="#三、树的周游" class="headerlink" title="三、树的周游"></a>三、树的周游</h1><p><strong>树的周游分为深度优先周游和广度优先周游。</strong></p>
<h2 id="深度优先周游"><a href="#深度优先周游" class="headerlink" title="深度优先周游"></a>深度优先周游</h2><p><strong>类似于二叉树的周游，树的深度优先周游分为先根次序周游和后跟次序周游</strong>。</p>
<p>先根次序的递归化定义为，<strong>首先访问森林中第一棵树的根节点</strong>，<strong>再在先根次序下周游根节点的子结点构成的子树森林</strong>。<strong>最后在先根次序下周游其他的树构成的森林</strong>。</p>
<p>后根次序的递归化定义为，<strong>首先在后根次序下周游根节点的子结点构成的子树森林，再访问森林中第一棵树的根节点。最后在先根次序下周游其他的树构成的森林</strong>。</p>
<p><strong>先根次序周游森林的序列正好等同于其对应的二叉树的前序序列，而后跟次序周游森林的序列正好等同于其对应的二叉树的中序遍历。</strong></p>
<blockquote>
<p><strong>比较森林先根次序周游（后）和二叉树前序遍历（前）的递归定义</strong>：</p>
<ul>
<li>访问根节点【访问森林中第一棵树的根节点】</li>
<li>按照前序遍历左子树【先根次序下周游根节点的子结点构成的子树森林】</li>
<li>按照前序遍历右子树【在先根次序下周游其他的树构成的森林】</li>
</ul>
<p><strong>比较森林后根次序周游（后）和二叉树中序遍历（前）的递归定义：</strong></p>
<ul>
<li>按照中序遍历左子树【在后根次序下周游根节点的子结点构成的子树森林】</li>
<li>访问根节点【访问森林中第一棵树的根节点】</li>
<li>按照中序遍历右子树【在先根次序下周游其他的树构成的森林】</li>
</ul>
</blockquote>
<h2 id="广度优先周游"><a href="#广度优先周游" class="headerlink" title="广度优先周游"></a>广度优先周游</h2><p>广度优先周游也称层次周游。广度优先周游从树的第0层开始，自上而下逐层周游；在同一层中，按照从左到右的顺序逐一访问。</p>
<h1 id="四、树的存储结构"><a href="#四、树的存储结构" class="headerlink" title="四、树的存储结构"></a>四、树的存储结构</h1><p><strong>树的存储包括链式存储和顺序存储。</strong></p>
<h2 id="Ⅰ-链式存储结构"><a href="#Ⅰ-链式存储结构" class="headerlink" title="Ⅰ - 链式存储结构"></a>Ⅰ - 链式存储结构</h2><h3 id="（动态）“子结点表”表示法"><a href="#（动态）“子结点表”表示法" class="headerlink" title="（动态）“子结点表”表示法"></a>（动态）“子结点表”表示法</h3><p>“子结点表”表示法的<strong>主体是一个存储了树中各结点信息的数组，数组中的每个元素包括3个域，分别用来存放该结点的值、其父节点指针（或数组下标）以及指向其子结点表的指针</strong>。子结点表是指每个分支结点的子结点按照从左到右的顺序形成一个链表存储在该分支结点中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子结点表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> index;</span><br><span class="line">	ListNode* next_node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> cList = ListNode*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素（包含三个域）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	DataType data_value;</span><br><span class="line">	<span class="keyword">size_t</span>* father_index;</span><br><span class="line">	cList children_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储了树中各个结点信息的数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Forest</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode&gt; node_arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="静态“左子右兄”表示法"><a href="#静态“左子右兄”表示法" class="headerlink" title="静态“左子右兄”表示法"></a>静态“左子右兄”表示法</h3><p>静态“左子右兄”表示法是对“子结点表”表示法的一个改进，使得访问结点的右侧兄弟结点更加方便，并且空间效率更高。</p>
<p>静态“左子右兄”表示法的主题仍然是一个存储各结点的的数组。数组的各个结点包含四个域，分别用于存储结点的值、指向其父节点的指针（或者下标）、指向其最左子结点和右侧（第一个）兄弟结点的指针（或者下标）。</p>
<p>例如对于森林</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229110835648.png" alt="image-20201229110835648"></p>
<p>其表示为</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229111202001.png" alt="image-20201229111202001"></p>
<h3 id="动态“左子右兄”表示法"><a href="#动态“左子右兄”表示法" class="headerlink" title="动态“左子右兄”表示法"></a>动态“左子右兄”表示法</h3><p>直接使用二叉树数据结构存储森林的方式称作动态“左子右兄”表示法。</p>
<p>简单的仅包括创建和打印树的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> L_C_R_S_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L_C_R_S_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	DataTy value;</span><br><span class="line">	TreeNode* left_child, * right_sibling;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeNode();</span><br><span class="line">	TreeNode(<span class="keyword">const</span> TreeNode&amp; item);</span><br><span class="line">	TreeNode(<span class="keyword">const</span> DataTy&amp; val, TreeNode&lt;DataTy&gt;* plchild = <span class="literal">nullptr</span>, TreeNode&lt;DataTy&gt;* prsibling = <span class="literal">nullptr</span>);</span><br><span class="line">	~TreeNode();</span><br><span class="line"></span><br><span class="line">	<span class="function">DataTy <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_left_child</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_right_sibling</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> DataTy&amp; val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_left_child</span><span class="params">(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> plchild)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_right_sibling</span><span class="params">(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> prsibling)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lcrsTree</span> &#123;</span></span><br><span class="line">	TreeNode&lt;DataTy&gt;* root;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs_print</span><span class="params">(TreeNode&lt;DataTy&gt;* node, <span class="keyword">size_t</span> <span class="built_in">floor</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	lcrsTree();</span><br><span class="line">	lcrsTree(TreeNode&lt;DataTy&gt;* proot);</span><br><span class="line">	~lcrsTree();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">TreeNode&lt;DataTy&gt;* <span class="title">get_root</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input_tree</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">	value = DataTy();</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = <span class="keyword">this</span>-&gt;right_sibling = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode(<span class="keyword">const</span> TreeNode&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;value = item.value;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = item.left_child;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = item.right_sibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::TreeNode(<span class="keyword">const</span> DataTy&amp; val, TreeNode&lt;DataTy&gt;* plchild, TreeNode&lt;DataTy&gt;* prsibling)</span><br><span class="line">&#123;</span><br><span class="line">	value = val;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = plchild;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = prsibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;::~TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">DataTy TreeNode&lt;DataTy&gt;::get_value() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* TreeNode&lt;DataTy&gt;::get_left_child() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;left_child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* TreeNode&lt;DataTy&gt;::get_right_sibling() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;right_sibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_value(<span class="keyword">const</span> DataTy&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_left_child(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> plchild)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left_child = plchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;DataTy&gt;::set_right_sibling(TreeNode&lt;DataTy&gt;* <span class="keyword">const</span> prsibling)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right_sibling = prsibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::dfs_print(TreeNode&lt;DataTy&gt;* node, <span class="keyword">size_t</span> <span class="built_in">floor</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; node-&gt;get_value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;get_left_child())</span><br><span class="line">		dfs_print(node-&gt;get_left_child(), <span class="built_in">floor</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;get_right_sibling())</span><br><span class="line">		dfs_print(node-&gt;get_right_sibling(), <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::lcrsTree()</span><br><span class="line">&#123;</span><br><span class="line">	root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::lcrsTree(TreeNode&lt;DataTy&gt;* proot)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;root = proot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">lcrsTree&lt;DataTy&gt;::~lcrsTree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode&lt;DataTy&gt;*&gt; aque;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;root)	aque.push(<span class="keyword">this</span>-&gt;root);</span><br><span class="line">	<span class="keyword">while</span> (!aque.empty()) &#123;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* tmp = aque.front();</span><br><span class="line">		aque.pop();</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;get_left_child())	aque.push(tmp-&gt;get_left_child());</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;get_right_sibling())	aque.push(tmp-&gt;get_right_sibling());</span><br><span class="line">		<span class="keyword">delete</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">bool</span> lcrsTree&lt;DataTy&gt;::is_empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;root == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">TreeNode&lt;DataTy&gt;* lcrsTree&lt;DataTy&gt;::get_root() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::input_tree()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode&lt;DataTy&gt;*&gt; aque;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入森林中子树的个数：&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt_tree;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; cnt_tree;</span><br><span class="line">	TreeNode&lt;DataTy&gt;* rights = <span class="literal">nullptr</span>;</span><br><span class="line">	TreeNode&lt;DataTy&gt;* node = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (cnt_tree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入各个子树的根节点的值：&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt_tree; i++) &#123;</span><br><span class="line">			DataTy val;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">			node = <span class="keyword">new</span> TreeNode&lt;DataTy&gt;(val, <span class="literal">nullptr</span>, rights);</span><br><span class="line">			rights = node;</span><br><span class="line">			aque.push(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>-&gt;root = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!aque.empty()) &#123;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* subtree_root = aque.front();</span><br><span class="line">		aque.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入结点&quot;</span> &lt;&lt; subtree_root-&gt;get_value() &lt;&lt; <span class="string">&quot;的子结点的个数：&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* rights = <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode&lt;DataTy&gt;* node = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入各个子结点的的值：&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">				DataTy val;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">				node = <span class="keyword">new</span> TreeNode&lt;DataTy&gt;(val, <span class="literal">nullptr</span>, rights);</span><br><span class="line">				rights = node;</span><br><span class="line">				aque.push(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		subtree_root-&gt;set_left_child(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> lcrsTree&lt;DataTy&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;is_empty())	<span class="keyword">return</span>;</span><br><span class="line">	dfs_print(<span class="keyword">this</span>-&gt;root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !L_C_R_S_TREE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="父指针表示法"><a href="#父指针表示法" class="headerlink" title="父指针表示法"></a>父指针表示法</h3><p>在某些情况下，只需要知道父节点的情况（例如并查集操作）。因此每个结点仅需要保存一个指向其父节点的指针（或下标）。这种实现方法被称作父指针表示法。</p>
<h2 id="Ⅱ-顺序存储结构"><a href="#Ⅱ-顺序存储结构" class="headerlink" title="Ⅱ - 顺序存储结构"></a>Ⅱ - 顺序存储结构</h2><p><strong>顺序存储表示法要求把树中的结点按照一定的顺序存储到一片连续的存储单元中。通常的选择有使用先根次序、后根次序或者层次遍历次序作为连续存储单元中的存储顺序，并辅以足够的信息保证我们能够将其还原。</strong>下面的介绍均以下面的森林为准。</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229110835648.png" alt="image-20201229110835648"></p>
<h3 id="带右链的先根次序表示"><a href="#带右链的先根次序表示" class="headerlink" title="带右链的先根次序表示"></a><strong>带右链的先根次序表示</strong></h3><p>带右链的先根次序表示将先根次序作为连续存储单元的存储顺序。</p>
<p>带右链的先根次序表示引入辅助数组<code>ltag[]</code>和<code>rlink[]</code>。</p>
<p><strong>每个结点的<code>ltag[i]</code>是一个标记位，当该结点为叶结点时<code>ltag[i] = 1</code>，否则<code>ltag[i] = 0</code>。</strong></p>
<p><strong>每个结点的<code>rlink[i]</code>是一个辅助指针，其指向该森林所对应二叉树的右子结点（或者为<code>null</code>）。</strong></p>
<p>在该规则下，实例中的森林可以表示为</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229160804501.png" alt="image-20201229160804501"></p>
<p>下面来说明如何根据这些信息还原出原来的森林。</p>
<ul>
<li><strong>首先根据<code>ltag</code>得到每一个非叶子结点的第一个子结点，即如果<code>ltag[i] = 0</code>，则该结点的第一个子结点是第<code>i+1</code>个结点。</strong></li>
<li><strong>之后根据<code>rlink</code>和<code>index</code>还原出每个结点的兄弟结点，即<code>rlink</code>就是链式存储结构中“子结点表”表示法的子结点链表。</strong></li>
</ul>
<h3 id="带双标记的先根次序表示"><a href="#带双标记的先根次序表示" class="headerlink" title="带双标记的先根次序表示"></a>带双标记的先根次序表示</h3><p>带双标记的先根次序表示将先根次序作为连续存储单元的存储顺序。</p>
<p>带双标记的先根次序表示使用另一个标记位<code>rtag[]</code>替换<code>rlink[]</code>。</p>
<p><strong>每个结点的<code>ltag[i]</code>是一个标记位，当该结点为叶结点时<code>ltag[i] = 1</code>，否则<code>ltag[i] = 0</code>。</strong></p>
<p><strong>每个结点的<code>rtag[i]</code>是一个标记为，当在该森林对应的二叉树中，该结点没有右兄弟（即右子结点为<code>nullptr</code>）时<code>ltag[i] = 1</code>，否则<code>ltag[i] = 0</code>。</strong></p>
<p>对于实例，有</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229172921270.png" alt="image-20201229172921270"></p>
<p>接下来说明如何根据带双标记的先根次序来还原森林。还原时将引入一个辅助栈<code>sta</code>、辅助指针<code>cur_ptr</code>。</p>
<p><strong>当每一次读入数据时，该数据被存入结点<code>cur_ptr</code>中。在处理该结点结束之后，根据需要将<code>cur_ptr</code>移动到下一个结点需要存储的位置。</strong></p>
<p>由于根据先根次序遍历规则，当访问该结点的兄弟结点前一定已经访问了所有叶结点，所以<strong>使用辅助栈<code>sta</code>将所有有右兄弟（即<code>rtag[i] = 0</code>）的结点入栈，以便回溯</strong>。</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229192930967.png" alt="image-20201229192930967"></p>
<p>下面给出实现代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	TreeNode* left_child;</span><br><span class="line">	TreeNode* right_sibling;</span><br><span class="line">	<span class="keyword">char</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">ltag_rtag_tree</span><span class="params">(<span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> value, <span class="keyword">const</span> <span class="keyword">bool</span>* <span class="keyword">const</span> ltag, <span class="keyword">const</span> <span class="keyword">bool</span>* <span class="keyword">const</span> rtag)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">	TreeNode* cur_ptr = <span class="keyword">new</span> TreeNode();</span><br><span class="line">	TreeNode* root = cur_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cur_ptr-&gt;value = value[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ltag[i] &amp;&amp; !rtag[i]) &#123;</span><br><span class="line">			sta.push(cur_ptr);</span><br><span class="line">			cur_ptr-&gt;left_child = <span class="keyword">new</span> TreeNode();</span><br><span class="line">			cur_ptr = cur_ptr-&gt;left_child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!ltag[i] &amp;&amp; rtag[i]) &#123;</span><br><span class="line">			cur_ptr-&gt;right_sibling = <span class="literal">nullptr</span>;</span><br><span class="line">			cur_ptr-&gt;left_child = <span class="keyword">new</span> TreeNode();</span><br><span class="line">			cur_ptr = cur_ptr-&gt;left_child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ltag[i] &amp;&amp; !rtag[i]) &#123;</span><br><span class="line">			cur_ptr-&gt;left_child = <span class="literal">nullptr</span>;</span><br><span class="line">			cur_ptr-&gt;right_sibling = <span class="keyword">new</span> TreeNode();</span><br><span class="line">			cur_ptr = cur_ptr-&gt;right_sibling;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ltag[i] &amp;&amp; rtag[i]) &#123;</span><br><span class="line">			cur_ptr-&gt;left_child = cur_ptr-&gt;right_sibling = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">if</span> (!sta.empty()) &#123;</span><br><span class="line">				cur_ptr = sta.top();</span><br><span class="line">				sta.pop();</span><br><span class="line">				cur_ptr-&gt;right_sibling = <span class="keyword">new</span> TreeNode();</span><br><span class="line">				cur_ptr = cur_ptr-&gt;right_sibling;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_print</span><span class="params">(TreeNode* root, <span class="keyword">size_t</span> <span class="built_in">floor</span> = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left_child)	dfs_print(root-&gt;left_child, <span class="built_in">floor</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;right_sibling)		dfs_print(root-&gt;right_sibling, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> value[] = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;I&#x27;</span> &#125;;</span><br><span class="line">	<span class="keyword">bool</span> ltag[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">bool</span> rtag[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	dfs_print(ltag_rtag_tree(<span class="number">10</span>, value, ltag, rtag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="带度数的后根次序表示"><a href="#带度数的后根次序表示" class="headerlink" title="带度数的后根次序表示"></a>带度数的后根次序表示</h3><p>带度数的后根次序表示将后根次序作为连续存储单元的存储顺序。</p>
<p><strong>在该存储结构中，每个结点有两个域，<code>value</code>用于存放结点的数据，<code>degree</code>用于存储结点的出度（即子结点的个数）。</strong></p>
<p>对于实例来说，有</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229173940876.png" alt="image-20201229173940876"></p>
<p>恢复森林的原理非常简单。</p>
<p>例如，对于<code>value == G</code>的结点来说，其度数为2，因此<code>H</code>和<code>I</code>都是其子结点。对于<code>value == A</code>来说，其度数为3，而<code>value == C</code>度数为2，因此<code>E</code>和<code>F</code>是<code>C</code>的子结点，<code>B</code>、<code>C</code>和<code>D</code>都是<code>A</code>的子结点。</p>
<p>在计算机中可以使用栈进行模拟。</p>
<h3 id="带双标记的层次次序表示"><a href="#带双标记的层次次序表示" class="headerlink" title="带双标记的层次次序表示"></a>带双标记的层次次序表示</h3><p>带双标记的层次次序表示将层次遍历次序作为连续存储单元的存储顺序。</p>
<p><strong>在该存储结构中，每个结点有三个域，<code>value</code>用于存放结点的数据，<code>ltag</code>和<code>rtag</code>均为在前面提到的标记位。</strong></p>
<p>对于实例来说，有</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229173940876.png" alt="image-20201229173940876"></p>
<p>接下来说明如何根还原森林。还原时将引入一个辅助队列<code>que</code>、辅助指针<code>cur_ptr</code>。</p>
<p><strong>当每一次读入数据时，该数据被存入结点<code>cur_ptr</code>中。在处理该结点结束之后，根据需要将<code>cur_ptr</code>移动到下一个结点需要存储的位置。</strong></p>
<p>由于根据层次遍历规则，当访问该结点的叶子结点前一定已经访问了所有兄弟结点，所以<strong>使用辅助队列<code>que</code>将所有子结点（即<code>ltag[i] = 0</code>）的结点入队列，以便回溯</strong>。</p>
<p><img src="/2020/12/28/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE/image-20201229192952508.png" alt="image-20201229192952508"></p>
<p>下面给出实现代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	TreeNode* left_child;</span><br><span class="line">	TreeNode* right_sibling;</span><br><span class="line">	<span class="keyword">char</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">ltag_rtag_b_tree</span><span class="params">(<span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> value, <span class="keyword">const</span> <span class="keyword">bool</span>* <span class="keyword">const</span> ltag, <span class="keyword">const</span> <span class="keyword">bool</span>* <span class="keyword">const</span> rtag)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">	TreeNode* cur_ptr = <span class="keyword">new</span> TreeNode();</span><br><span class="line">	TreeNode* root = cur_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cur_ptr-&gt;value = value[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ltag[i])		cur_ptr-&gt;left_child = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">else</span>	que.push(cur_ptr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rtag[i]) &#123;</span><br><span class="line">			cur_ptr-&gt;right_sibling = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">if</span> (!que.empty()) &#123;</span><br><span class="line">				cur_ptr = que.front();</span><br><span class="line">				que.pop();</span><br><span class="line">				cur_ptr-&gt;left_child = <span class="keyword">new</span> TreeNode();</span><br><span class="line">				cur_ptr = cur_ptr-&gt;left_child;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cur_ptr-&gt;right_sibling = <span class="keyword">new</span> TreeNode();</span><br><span class="line">			cur_ptr = cur_ptr-&gt;right_sibling;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_print</span><span class="params">(TreeNode* root, <span class="keyword">size_t</span> <span class="built_in">floor</span> = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left_child)	dfs_print(root-&gt;left_child, <span class="built_in">floor</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;right_sibling)		dfs_print(root-&gt;right_sibling, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> value[] = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;J&#x27;</span> &#125;;</span><br><span class="line">	<span class="keyword">bool</span> ltag[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">bool</span> rtag[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	dfs_print(ltag_rtag_b_tree(<span class="number">10</span>, value, ltag, rtag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/12/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p><strong>并查集有关的讲解见文章<a class="link" href="https://zhuanlan.zhihu.com/p/93647900/">https://zhuanlan.zhihu.com/p/93647900/<i class="fas fa-external-link-alt"></i></a></strong> 。</p>
<p>这里仅给出使用重量权衡合并规则以及路径压缩优化方法的类模板实现。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNION_FIND_SET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNION_FIND_SET_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">union_find_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span>* father_arr;</span><br><span class="line">	DataTy* data_arr;</span><br><span class="line">	<span class="keyword">size_t</span>* rank_arr;</span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	union_find_set(<span class="keyword">size_t</span> len, <span class="keyword">const</span> DataTy* <span class="keyword">const</span> arr);</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">get_father_index</span><span class="params">(<span class="keyword">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="function">DataTy <span class="title">get_data</span><span class="params">(<span class="keyword">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_different</span><span class="params">(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">is_same</span><span class="params">(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">union_sets</span><span class="params">(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line">union_find_set&lt;DataTy&gt;::union_find_set(<span class="keyword">size_t</span> len, <span class="keyword">const</span> DataTy* <span class="keyword">const</span> arr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;len = len;</span><br><span class="line">	father_arr = <span class="keyword">new</span> <span class="keyword">size_t</span>[len];</span><br><span class="line">	data_arr = <span class="keyword">new</span> DataTy[len];</span><br><span class="line">	rank_arr = <span class="keyword">new</span> <span class="keyword">size_t</span>[len];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		data_arr[i] = arr[i];</span><br><span class="line">		father_arr[i] = i;</span><br><span class="line">		rank_arr[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">size_t</span> union_find_set&lt;DataTy&gt;::size()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">size_t</span> union_find_set&lt;DataTy&gt;::get_father_index(<span class="keyword">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//with path compression.</span></span><br><span class="line">	<span class="keyword">if</span> (father_arr[index] == index)</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> (father_arr[index] = get_father_index(father_arr[index]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">inline</span> DataTy union_find_set&lt;DataTy&gt;::get_data(<span class="keyword">size_t</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> data_arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> union_find_set&lt;DataTy&gt;::is_different(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> get_father_index(pos1) != get_father_index(pos2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">bool</span> union_find_set&lt;DataTy&gt;::is_same(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> get_father_index(pos1) == get_father_index(pos2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataTy&gt;</span><br><span class="line"><span class="keyword">void</span> union_find_set&lt;DataTy&gt;::union_sets(<span class="keyword">size_t</span> pos1, <span class="keyword">size_t</span> pos2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//follow the weighted union rule</span></span><br><span class="line">	<span class="keyword">if</span> (rank_arr[pos1] &lt;= rank_arr[pos2]) &#123;</span><br><span class="line">		father_arr[get_father_index(pos1)] = get_father_index(pos2);</span><br><span class="line">		<span class="keyword">if</span> (rank_arr[pos1] == rank_arr[pos2])</span><br><span class="line">			rank_arr[pos2]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		father_arr[get_father_index(pos2)] = get_father_index(pos1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !UNION_FIND_SET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MATHEMATICS &amp; ALGORITHM</category>
      </categories>
      <tags>
        <tag>MATHEMATICS &amp; ALGORITHM</tag>
        <tag>DATA STRUCTURE</tag>
        <tag>TREE &amp; GRAPH</tag>
      </tags>
  </entry>
  <entry>
    <title>加壳与脱壳</title>
    <url>/2021/01/11/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<p><strong>1. 介绍CTF加壳与脱壳的含义</strong></p>
<p><strong>2. 收集常见的加壳脱壳方式</strong></p>
<p>在一些计算机软件里有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。这个过程被称为加壳。脱壳一般是指除掉程序的保护，用来修改程序资源。</p>
<p>在CTF逆向中，程序加壳可以保证其不被反汇编和破解。因此，对于一个被加壳的二进制文件，我们首先需要对其脱壳。</p>
<a id="more"></a>



<h1 id="ExeinfoPe-exe"><a href="#ExeinfoPe-exe" class="headerlink" title="ExeinfoPe.exe"></a><code>ExeinfoPe.exe</code></h1><p><code>ExeinfoPe.exe</code>是常见的检测加壳种类的软件。</p>
<p>下载地址： <a class="link" href="http://www.sd173.com/soft/63.html">http://www.sd173.com/soft/63.html<i class="fas fa-external-link-alt"></i></a></p>
<p>打开软件后将带检测文件拖到程序中， 在最下方可以看到文件的信息以及加壳方式。</p>
<p><img src="/2021/01/11/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/image-20210111092205116.png" alt="image-20210111092205116"></p>
<h1 id="常见加壳类型收集"><a href="#常见加壳类型收集" class="headerlink" title="常见加壳类型收集"></a>常见加壳类型收集</h1><h2 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h2><p>题目链接：</p>
<p><a class="link" href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1<i class="fas fa-external-link-alt"></i></a></p>
<p>使用<code>ExeinfoPe</code>可以查出该程序使用的是UPX加壳。</p>
<p><strong>Kali系统中自带了UPX的脱壳程序。</strong>在Kali系统中使用<code>upx -d &#39;filename&#39;</code>即可对其脱壳。</p>
<img src="/2021/01/11/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/image-20210111092544075.png" alt="image-20210111092544075" style="zoom:80%;">

<p>脱壳之后的程序可以正常地使用IDA进行反汇编，得到</p>
<p><img src="/2021/01/11/%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/image-20210111092636208.png" alt="image-20210111092636208"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【WP】逆向-re_easyvm</title>
    <url>/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/</url>
    <content><![CDATA[<p><strong>SDU CTF第一次实训 <code>re_easyvm</code></strong></p>
<p><strong><a class="link" href="http://10.102.32.142:8000/challenges#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%AE%AD%20re_easyvm">http://10.102.32.142:8000/challenges#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%AE%AD%20re_easyvm<i class="fas fa-external-link-alt"></i></a></strong></p>
<a id="more"></a>

<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>首先将文件拖入IDA中执行反汇编，并进入<code>main</code>函数中。</p>
<p><img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111103523147.png" alt="image-20210111103523147"></p>
<p><strong>破解该程序的第一步是要理解这些循环跳转的逻辑。</strong>下面是在分析代码逻辑的基础上对一些标识符、函数的命名和注释。</p>
<img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111104432120.png" alt="image-20210111104432120" style="zoom:67%;">

<ul>
<li>在初始化下，<code>v5 == 0</code>，因此进入循环后首先到第46行，输出欢迎语句，并赋值<code>v5 = 65324</code>。</li>
<li>之后到达第24行，赋值<code>v5 = 2541</code>，并输入字符串。**<code>Handler[0] = input</code>可以看出来<code>Handler[0]</code>是一个数组指针，在这里它指向输入字符串的第一个字符。**</li>
<li>之后到达第22行，<code>DoSomething</code>函数是整个程序的核心函数，该函数返回值包括<code>28</code>和<code>31</code>。</li>
<li>如果上面一步返回的是<code>28</code> ，程序将到53行，在执行<code>sub_401340</code>函数之后，重新回到第22行。因此，我们可以看出来<strong>程序的第22行<code>DoSomething</code>函数和第53行<code>sub_401340</code>函数之间构成了一个循环</strong>。而如果上一步程序返回<code>31</code>，啧执行到第33到第42行，这一块是一个检查程序，<code>sub_401360</code>函数即为检查程序是否通过的函数。</li>
</ul>
<p>因此，理解程序的核心就是理解<code>DoSomething</code>和<code>sub_401340</code>两个函数。</p>
<h1 id="DoSomething和sub-401340两个函数构成的循环"><a href="#DoSomething和sub-401340两个函数构成的循环" class="headerlink" title="DoSomething和sub_401340两个函数构成的循环"></a><code>DoSomething</code>和<code>sub_401340</code>两个函数构成的循环</h1><h2 id="函数DoSomething"><a href="#函数DoSomething" class="headerlink" title="函数DoSomething"></a>函数<code>DoSomething</code></h2><img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111110040088.png" alt="image-20210111110040088" style="zoom: 80%;">

<p>理解该函数有一个核心的点需要理解，将这个点理解清楚之后，整个函数就可以很容易地理解。</p>
<p><strong><code>a1 + 4</code>和<code>a1 + 8</code>是什么意思？</strong></p>
<p>为了理解这两个的含义，我们首先跳出该函数。在调用该函数的地方，我们可以看到<code>v5 = DoSomething(&amp;v5);</code>。因此在这里<code>a1</code>是一个指针，因此<code>a1 + 4</code>和<code>a1 + 8</code>是基于偏移量的指针移动。那么下一个问题就是它偏移到什么位置了。</p>
<p>在<code>main</code>函数的开始部分，有这样的变量声明。</p>
<img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111111105695.png" alt="image-20210111111105695" style="zoom: 80%;">

<p>在一个函数内部，<strong>变量在内存中的存储是相邻的，并且是遵照声明的顺序</strong>。<strong>因此<code>a1 + 4</code>指向的就是<code>Handler[0]</code>，而<code>a1 + 8</code>指向的就是<code>Handler[1]</code>。</strong></p>
<p>因此，我们就可以掌握该函数的逻辑，<code>return 31</code>是判断循环结束的标志，当<code>Handler[0]</code>（前面说过是一个字符串数组指针）位置的字符为<code>\0</code>（即字符串结束标志），则结束整个循环。（因此我们可以首先猜测这个函数需要对每一位字符串进行处理）如果没有结束，则将该位置的字符异或上<code>Handler[1]</code>（<strong>的低八位</strong>），并递增<code>Handler[1]++</code>。最后返回<code>28</code>。</p>
<h2 id="函数sub-401340"><a href="#函数sub-401340" class="headerlink" title="函数sub_401340"></a>函数<code>sub_401340</code></h2><img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111111703713.png" alt="image-20210111111703713" style="zoom:80%;">

<p>在这里，**<code>a1</code>是<code>main</code>函数中的<code>Handler</code>，而<code>Handler</code>是一个数组。因此<code>*a1</code>即<code>*Handler</code>即<code>Handler[0]</code>**。因此，该函数第3行的目的是令<code>Handler[0]++</code>，（之前提到过<code>Handler</code>是一个字符串指针），即指向字符串的下一个位置。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>结合两个函数各自的功能，我们就可以总结出整个程序的目的是<strong>将输入字符串的第零位异或上0，第一位异或上1，第二位异或上2……依次类推</strong>。</p>
<h1 id="Check块"><a href="#Check块" class="headerlink" title="Check块"></a>Check块</h1><p>最后我们关注程序的最后检查部分。</p>
<img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111113945414.png" alt="image-20210111113945414" style="zoom:80%;">



<p><strong>在这里，我们还有一个点需要注意。计算机的存储是小端开始的，因此，例如上面的<code>Jl2d</code>是输入字符串的前四位，但是<code>d</code>应该是这四位字符串的最低位，而<code>J</code>则是这四位字符串的最高位。</strong></p>
<p>最后，我们可以看出来，在对原始字符串进行处理之后，得到的新的字符串应该是<code>d2lJft|E_pUy=8j5</code>。</p>
<p>编写脚本获得转换前的字符串（<code>b XOR (a XOR b) == a</code>）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = <span class="string">&#x27;d2lJft|E_pUy=8j5&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    print(<span class="built_in">chr</span>(<span class="built_in">ord</span>(code[i]) ^ i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>得到输入<code>d3nIbqzBWy_r15d:</code></p>
<p><img src="/2021/01/11/%E3%80%90WP%E3%80%91%E9%80%86%E5%90%91-re_easyvm/image-20210111114200558.png" alt="image-20210111114200558"></p>
<p>最后用MD5进行加密，就可以得到flag为<code>flag&#123;579243b4c7b52756583888d9e7bfbf2f&#125;</code>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【WP】answer_to_everything elrond32</title>
    <url>/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/</url>
    <content><![CDATA[<p><strong>题目1： answer_to_everything</strong></p>
<p><a class="link" href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=1&amp;id=5511&amp;page=1">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=1&amp;id=5511&amp;page=1<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>题目2：elrond32</strong></p>
<p><a class="link" href="https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=1&amp;id=4750&amp;page=1">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=1&amp;id=4750&amp;page=1<i class="fas fa-external-link-alt"></i></a></p>
<a id="more"></a>

<h1 id="answer-to-everything"><a href="#answer-to-everything" class="headerlink" title="answer_to_everything"></a>answer_to_everything</h1><p>拖到IDA中，是一个非常简单的程序。</p>
<img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114194523044.png" alt="image-20210114194523044" style="zoom:80%;">

<p>可以看出来flag就是<code>kdudpeh</code>。但是如果直接将<code>flag&#123;kdudpeh&#125;</code>提交是错误的。这里要关注题目。</p>
<img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114194646180.png" alt="image-20210114194646180" style="zoom:80%;">

<p>因此需要将<code>kdudpeh</code>进行SHA1加密。得到的最后的flag是<code>flag&#123;80ee2a3fe31da904c596d993f7f1de4827c1450a&#125;</code>。</p>
<h1 id="elrond32"><a href="#elrond32" class="headerlink" title="elrond32"></a>elrond32</h1><p>拖到IDA中。</p>
<img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114195004613.png" alt="image-20210114195004613" style="zoom:80%;">

<p>这里<code>a2[1]</code>就是输入字符串的指针，函数<code>do_something</code>首先对输入字符串进行检查，如果通过了，则继续执行<code>change_input</code>函数。</p>
<h2 id="do-something"><a href="#do-something" class="headerlink" title="do_something"></a><code>do_something</code></h2><img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114195207424.png" alt="image-20210114195207424" style="zoom:80%;">

<p>函数实际上完成了一个迭代。<code>a1</code>是输入字符串的指针，<code>ival</code>在初始条件下<code>ival = 0</code>，之后每次迭代都有<code>ival = 7 * (ival + 1) % 11</code>，我们已经计算出来（在图中）<code>ival</code>的序列为<code>0 7 1 3 6 5 9 4 2 0</code>。</p>
<p>实际上<code>switch</code>对字符串进行了一个检查，将字符串的每个位置与<code>ival</code>序列进行对应（例如<code>0</code>对应<code>*a1 = &#39;i&#39;</code>，<code>7</code>对应<code>*(a1 + 1) = s</code>等），可以看出我们的输入字符串应该是<code>isengard</code>。</p>
<h2 id="change-input"><a href="#change-input" class="headerlink" title="change_input"></a><code>change_input</code></h2><img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114195837272.png" alt="image-20210114195837272" style="zoom:80%;">

<p><code>change_input</code>实际上就是将输入字符串按顺序循环与<code>unk_8048760</code>进行异或。我们首先需要知道<code>unk_8048760</code>的信息。</p>
<img src="/2021/01/14/%E3%80%90WP%E3%80%91answer_to_everything%20elrond32/image-20210114195944959.png" alt="image-20210114195944959" style="zoom:80%;">

<p>由于数组在内存中是按顺序存储的，所以我们可以直接在内存中查看信息。<strong>另外这里同样用到的一个知识点是计算机是小端存储的，因此进行异或的应该是每四个字节中的第一个字节。</strong></p>
<p>编写脚本辅助我们进行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [</span><br><span class="line">    <span class="number">0xf</span>, <span class="number">0x1f</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0x1c</span>, <span class="number">0x12</span>, <span class="number">0x42</span>, <span class="number">9</span>, </span><br><span class="line">    <span class="number">0xc</span>, <span class="number">0x44</span>, <span class="number">0xd</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0x2d</span>, <span class="number">0x37</span>, </span><br><span class="line">    <span class="number">0x59</span>, <span class="number">0x1e</span>, <span class="number">0</span>, <span class="number">0x59</span>, <span class="number">0xf</span>, <span class="number">8</span>, <span class="number">0x1c</span>, <span class="number">0x23</span>, </span><br><span class="line">    <span class="number">0x36</span>, <span class="number">0x7</span>, <span class="number">0x55</span>, <span class="number">0x2</span>, <span class="number">0xc</span>, <span class="number">8</span>, <span class="number">0x41</span>, <span class="number">0xa</span>,</span><br><span class="line">    <span class="number">0x14</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="string">&quot;isengard&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">    print(<span class="built_in">chr</span>(lst[i] ^ <span class="built_in">ord</span>(<span class="built_in">input</span>[i % <span class="number">8</span>])), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print()</span><br></pre></td></tr></table></figure>

<p>就可以得到flag为<code>flag&#123;s0me7hing_S0me7hinG_t0lki3n&#125;</code>。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>REVERSE</tag>
      </tags>
  </entry>
</search>
